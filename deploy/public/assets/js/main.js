/*!
 * jQuery JavaScript Library v1.11.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:42Z
 */
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    // Can't do this because several apps including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    // Support: Firefox 18+
    //
    var deletedIds = [];
    var slice = deletedIds.slice;
    var concat = deletedIds.concat;
    var push = deletedIds.push;
    var indexOf = deletedIds.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var version = "1.11.1", // Define a local copy of jQuery
    jQuery = function(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
    }, // Support: Android<4.1, IE<9
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            // Return just the one element from the set
            // Return all the elements in a clean array
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);
            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;
            // Return the newly-formed element set
            return ret;
        },
        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            // skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }
        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        // extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        // Return the modified object
        return target;
    };
    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray || function(obj) {
            return jQuery.type(obj) === "array";
        },
        isWindow: function(obj) {
            /* jshint eqeqeq: false */
            return obj != null && obj == obj.window;
        },
        isNumeric: function(obj) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        isPlainObject: function(obj) {
            var key;
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            try {
                // Not own constructor property must be Object
                if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }
            // Support: IE<9
            // Handle iteration over inherited properties before own properties.
            if (support.ownLast) {
                for (key in obj) {
                    return hasOwn.call(obj, key);
                }
            }
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            for (key in obj) {}
            return key === undefined || hasOwn.call(obj, key);
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function(data) {
            if (data && jQuery.trim(data)) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                (window.execScript || function(data) {
                    window["eval"].call(window, data);
                })(data);
            }
        },
        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        // args is for internal usage only
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (;i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        // Support: Android<4.1, IE<9
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            var len;
            if (arr) {
                if (indexOf) {
                    return indexOf.call(arr, elem, i);
                }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (;i < len; i++) {
                    // Skip accessing in sparse arrays
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }
            return -1;
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            while (j < len) {
                first[i++] = second[j++];
            }
            // Support: IE<9
            // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
            if (len !== len) {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            // Go through the array, only saving the items
            // that pass the validator function
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            // Go through the array, translating each of the items to their new values
            if (isArray) {
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            // Flatten any nested arrays
            return concat.apply([], ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var args, proxy, tmp;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: function() {
            return +new Date();
        },
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });
    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
    function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, // Instance-specific data
        expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, // General-purpose constants
        strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, // Instance methods
        hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf if we can't use a native one
        indexOf = arr.indexOf || function(elem) {
            var i = 0, len = this.length;
            for (;i < len; i++) {
                if (this[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/css3-syntax/#characters
        characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", // Loosely modeled on CSS identifier characters
        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = characterEncoding.replace("w", "w#"), // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            // BMP codepoint
            // Supplemental Plane codepoint (surrogate pair)
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        };
        // Optimize for push.apply( _, NodeList )
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length, i = 0;
                    // Can't trust NodeList.length
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, // QSA vars
            i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== "string") {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                // Shortcuts
                if (match = rquickExpr.exec(selector)) {
                    // Speed-up: Sizzle("#ID")
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document (jQuery #6963)
                            if (elem && elem.parentNode) {
                                // Handle the case where IE, Opera, and Webkit return items
                                // by name instead of ID
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            // Context is not a document
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                // QSA path
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    // qSA works strangely on Element-rooted queries
                    // We can work around this by specifying an extra ID on the root
                    // and working up from there (Thanks to Andrew Dupont for the technique)
                    // IE 8 doesn't work on object elements
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector);
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&");
                        } else {
                            context.setAttribute("id", nid);
                        }
                        nid = "[id='" + nid + "'] ";
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(",");
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {} finally {
                            if (!old) {
                                context.removeAttribute("id");
                            }
                        }
                    }
                }
            }
            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
        function createCache() {
            var keys = [];
            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                // Remove from its parent by default
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                // release memory in IE
                div = null;
            }
        }
        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            // Use IE sourceIndex if available on both nodes
            if (diff) {
                return diff;
            }
            // Check if b follows a
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        // Expose support vars for convenience
        support = Sizzle.support = {};
        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
        isXML = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            // If no document and documentElement is available, return
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            // Set our document
            document = doc;
            docElem = doc.documentElement;
            // Support tests
            documentIsHTML = !isXML(doc);
            // Support: IE>8
            // If iframe document is assigned to "document" variable and if iframe has been reloaded,
            // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
            // IE6-8 do not support the defaultView property so parent will be undefined
            if (parent && parent !== parent.top) {
                // IE11 does not have attachEvent, so all must suffer
                if (parent.addEventListener) {
                    parent.addEventListener("unload", function() {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", function() {
                        setDocument();
                    });
                }
            }
            /* Attributes
	---------------------------------------------------------------------- */
            // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            /* getElement(s)By*
	---------------------------------------------------------------------- */
            // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(doc.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            // Check if getElementsByClassName can be trusted
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                div.innerHTML = "<div class='a'></div><div class='a i'></div>";
                // Support: Safari<4
                // Catch class over-caching
                div.firstChild.className = "i";
                // Support: Opera<10
                // Catch gEBCN failure to find non-leading classes
                return div.getElementsByClassName("i").length === 2;
            });
            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            // ID find and filter
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                // Support: IE6/7
                // getElementById is not reliable as a find shortcut
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                // Filter out possible comments
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            /* QSA/matchesSelector
	---------------------------------------------------------------------- */
            // QSA and matchesSelector support
            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];
            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See http://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";
                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (div.querySelectorAll("[msallowclip^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });
                assert(function(div) {
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = doc.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(div, "div");
                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            /* Contains
	---------------------------------------------------------------------- */
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            // Element contains another
            // Purposefully does not implement inclusive descendent
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            /* Sorting
	---------------------------------------------------------------------- */
            // Document order sorting
            sortOrder = hasCompare ? function(a, b) {
                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                1;
                // Disconnected nodes
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    // Choose the first element that is related to our preferred document
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    // Maintain original order
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                // Walk down the tree looking for a discrepancy
                while (ap[i] === bp[i]) {
                    i++;
                }
                // Do a sibling check if the nodes have a common ancestor
                // Otherwise nodes in our document sort first
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;
            return results;
        };
        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while (node = elem[i++]) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    // Traverse its children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes
            return ret;
        };
        Expr = Sizzle.selectors = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    // Accept quoted arguments as-is
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (// Get excess from tokenize (recursively)
                    excess = tokenize(unquoted, true)) && (// advance to the next closing parenthesis
                    excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    // Shortcut for :nth-*(n)
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {
                                // Seek `elem` from a previously-cached index
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (// Fallback to seeking `elem` from the start
                                diff = nodeIndex = 0) || start.pop()) {
                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                // Use the same loop as above to seek `elem` from the start
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        // Cache the index of each encountered element
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                // Potentially complex pseudos
                not: markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                lang: markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                // Miscellaneous
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                // Contents
                empty: function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        // Add button/input type pseudos
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                // Combinators
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            // Cache the tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            // Check against closest ancestor/preceding element
            // Check against all ancestor/preceding elements
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                // Assign to newCache so results back-propagate to previous elements
                                return newCache[2] = oldCache[2];
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                outerCache[dir] = newCache;
                                // A match means we're done; a fail means we have to keep checking
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                [] : // ...otherwise use results directly
                results : matcherIn;
                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context !== document && context;
                }
                // Add elements passing elementMatchers directly to results
                // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        // Lengthen the array for every element, matched or not
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                // Apply set filters to unmatched elements
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }
                    // Add matches to results
                    push.apply(results, setMatched);
                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        };
        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            // Try to minimize operations if there is no seed and only one group
            if (match.length === 1) {
                // Take a shortcut and set the context if the root selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    // Abort if we hit a combinator
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        // Search, expanding context for leading sibling combinators
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        // One-time assignments
        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        // Support: Chrome<14
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;
        // Initialize against the default document
        setDocument();
        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(div1) {
            // Should return 1, but returns 4 (following)
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret = [], self = this, len = self.length;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    // Initialize a jQuery object
    // A central reference to the root jQuery(document)
    var rootjQuery, // Use the correct document accordingly with window argument (sandbox)
    document = window.document, // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) {
            return this;
        }
        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {
                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    // scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            // Properties of context are called as methods if possible
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if (elem && elem.parentNode) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if (elem.id !== match[2]) {
                            return rootjQuery.find(selector);
                        }
                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            // Execute immediately if ready is not present
            return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    // Initialize central reference
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function(n, elem) {
            var r = [];
            for (;n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }
            return r;
        }
    });
    jQuery.fn.extend({
        has: function(target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function() {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    // Always skip document fragments
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        // Determine the position of an element within
        // the matched set of elements
        index: function(elem) {
            // No argument, return index in parent
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            // index in selector
            if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
            }
            // Locate the position of the desired element
            // If it receives a jQuery object, the first element is used
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }
            if (this.length > 1) {
                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    ret = jQuery.unique(ret);
                }
                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    ret = ret.reverse();
                }
            }
            return this.pushStack(ret);
        };
    });
    var rnotwhite = /\S+/g;
    // String to Object options format cache
    var optionsCache = {};
    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function(options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var // Flag to know if list is currently firing
        firing, // Last fire value (for non-forgettable lists)
        memory, // Flag to know if list was already fired
        fired, // End of the loop when firing
        firingLength, // Index of currently firing callback (modified by remove if needed)
        firingIndex, // First callback to fire (used internally by add and fireWith)
        firingStart, // Actual callback list
        list = [], // Stack of fire calls for repeatable lists
        stack = !options.once && [], // Fire callbacks
        fire = function(data) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for (;list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                    memory = false;
                    // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if (list) {
                if (stack) {
                    if (stack.length) {
                        fire(stack.shift());
                    }
                } else if (memory) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        }, // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {
                    // First, we save the current length
                    var start = list.length;
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            if (type === "function") {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && type !== "string") {
                                // Inspect recursively
                                add(arg);
                            }
                        });
                    })(arguments);
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if (firing) {
                        firingLength = list.length;
                    } else if (memory) {
                        firingStart = start;
                        fire(memory);
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if (list) {
                    jQuery.each(arguments, function(_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            // Handle firing indexes
                            if (firing) {
                                if (index <= firingLength) {
                                    firingLength--;
                                }
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if (!memory) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if (firing) {
                        stack.push(args);
                    } else {
                        fire(args);
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ // action, add listener, listener list, final state
            [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            // Keep pipe for back-compat
            promise.pipe = promise.then;
            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;
                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            // Make the deferred a promise
            promise.promise(deferred);
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            // All done!
            return deferred;
        },
        // Deferred helper
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, // the count of uncompleted subordinates
            remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(), // Update function for both resolve and progress values
            updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    // The deferred used on DOM ready
    var readyList;
    jQuery.fn.ready = function(fn) {
        // Add the callback
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Hold (or release) the ready event
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        // Handle when the DOM is ready
        ready: function(wait) {
            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!document.body) {
                return setTimeout(jQuery.ready);
            }
            // Remember that the DOM is ready
            jQuery.isReady = true;
            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            // If there are functions bound, to execute
            readyList.resolveWith(document, [ jQuery ]);
            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    /**
 * Clean-up method for dom ready events
 */
    function detach() {
        if (document.addEventListener) {
            document.removeEventListener("DOMContentLoaded", completed, false);
            window.removeEventListener("load", completed, false);
        } else {
            document.detachEvent("onreadystatechange", completed);
            window.detachEvent("onload", completed);
        }
    }
    /**
 * The ready event handler and self cleanup method
 */
    function completed() {
        // readyState === "complete" is good enough for us to call the dom ready in oldIE
        if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
            detach();
            jQuery.ready();
        }
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready);
            } else if (document.addEventListener) {
                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed, false);
                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed, false);
            } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent("onreadystatechange", completed);
                // A fallback to window.onload, that will always work
                window.attachEvent("onload", completed);
                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;
                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {}
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                // Use the trick by Diego Perini
                                // http://javascript.nwbox.com/IEContentLoaded/
                                top.doScroll("left");
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }
                            // detach all dom ready events
                            detach();
                            // and execute any waiting functions
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };
    var strundefined = typeof undefined;
    // Support: IE<9
    // Iteration over object's inherited properties before its own
    var i;
    for (i in jQuery(support)) {
        break;
    }
    support.ownLast = i !== "0";
    // Note: most support tests are defined in their respective modules.
    // false until the test is run
    support.inlineBlockNeedsLayout = false;
    // Execute ASAP in case we need to set body.style.zoom
    jQuery(function() {
        // Minified: var a,b,c,d
        var val, div, body, container;
        body = document.getElementsByTagName("body")[0];
        if (!body || !body.style) {
            // Return for frameset docs that don't have a body
            return;
        }
        // Setup
        div = document.createElement("div");
        container = document.createElement("div");
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild(container).appendChild(div);
        if (typeof div.style.zoom !== strundefined) {
            // Support: IE<8
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
            support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
            if (val) {
                // Prevent IE 6 from affecting layout for positioned elements #11048
                // Prevent IE from shrinking the body in IE 7 mode #12869
                // Support: IE<8
                body.style.zoom = 1;
            }
        }
        body.removeChild(container);
    });
    (function() {
        var div = document.createElement("div");
        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        // Null elements to avoid leaks in IE.
        div = null;
    })();
    /**
 * Determines whether an object can have data
 */
    jQuery.acceptData = function(elem) {
        var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()], nodeType = +elem.nodeType || 1;
        // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
        // Nodes accept data unless otherwise specified; rejection can be conditional
        return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute("classid") === noData;
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            // if the public data object is empty, the private is still empty
            if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== "toJSON") {
                return false;
            }
        }
        return true;
    }
    function internalData(elem, name, data, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var ret, thisCache, internalKey = jQuery.expando, // We have to handle DOM nodes and JS objects differently because IE6-7
        // can't GC object references properly across the DOM-JS boundary
        isNode = elem.nodeType, // Only DOM nodes need the global jQuery cache; JS object data is
        // attached directly to the object so GC can occur automatically
        cache = isNode ? jQuery.cache : elem, // Only defining an ID for JS objects if its cache already exists allows
        // the code to shortcut on the same path as a DOM node with no cache
        id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
        // Avoid doing any more work than we need to when trying to get data on an
        // object that has no data at all
        if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === "string") {
            return;
        }
        if (!id) {
            // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            if (isNode) {
                id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }
        if (!cache[id]) {
            // Avoid exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            cache[id] = isNode ? {} : {
                toJSON: jQuery.noop
            };
        }
        // An object can be passed to jQuery.data instead of a key/value pair; this gets
        // shallow copied over onto the existing cache
        if (typeof name === "object" || typeof name === "function") {
            if (pvt) {
                cache[id] = jQuery.extend(cache[id], name);
            } else {
                cache[id].data = jQuery.extend(cache[id].data, name);
            }
        }
        thisCache = cache[id];
        // jQuery data() is stored in a separate object inside the object's internal data
        // cache in order to avoid key collisions between internal data and user-defined
        // data.
        if (!pvt) {
            if (!thisCache.data) {
                thisCache.data = {};
            }
            thisCache = thisCache.data;
        }
        if (data !== undefined) {
            thisCache[jQuery.camelCase(name)] = data;
        }
        // Check for both converted-to-camel and non-converted data property names
        // If a data property was specified
        if (typeof name === "string") {
            // First Try to find as-is property data
            ret = thisCache[name];
            // Test for null|undefined property data
            if (ret == null) {
                // Try to find the camelCased property
                ret = thisCache[jQuery.camelCase(name)];
            }
        } else {
            ret = thisCache;
        }
        return ret;
    }
    function internalRemoveData(elem, name, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var thisCache, i, isNode = elem.nodeType, // See jQuery.data for more information
        cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
        // If there is already no cache entry for this object, there is no
        // purpose in continuing
        if (!cache[id]) {
            return;
        }
        if (name) {
            thisCache = pvt ? cache[id] : cache[id].data;
            if (thisCache) {
                // Support array or space separated string names for data keys
                if (!jQuery.isArray(name)) {
                    // try the string as a key before any manipulation
                    if (name in thisCache) {
                        name = [ name ];
                    } else {
                        // split the camel cased version by spaces unless a key with the spaces exists
                        name = jQuery.camelCase(name);
                        if (name in thisCache) {
                            name = [ name ];
                        } else {
                            name = name.split(" ");
                        }
                    }
                } else {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = name.concat(jQuery.map(name, jQuery.camelCase));
                }
                i = name.length;
                while (i--) {
                    delete thisCache[name[i]];
                }
                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                    return;
                }
            }
        }
        // See jQuery.data for more information
        if (!pvt) {
            delete cache[id].data;
            // Don't destroy the parent cache unless the internal data object
            // had been the only thing left in it
            if (!isEmptyDataObject(cache[id])) {
                return;
            }
        }
        // Destroy the cache
        if (isNode) {
            jQuery.cleanData([ elem ], true);
        } else if (support.deleteExpando || cache != cache.window) {
            /* jshint eqeqeq: true */
            delete cache[id];
        } else {
            cache[id] = null;
        }
    }
    jQuery.extend({
        cache: {},
        // The following elements (space-suffixed to avoid Object.prototype collisions)
        // throw uncatchable exceptions if you attempt to set expando properties
        noData: {
            "applet ": true,
            "embed ": true,
            // ...but Flash objects (which have this classid) *can* handle expandos
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },
        data: function(elem, name, data) {
            return internalData(elem, name, data);
        },
        removeData: function(elem, name) {
            return internalRemoveData(elem, name);
        },
        // For internal use only.
        _data: function(elem, name, data) {
            return internalData(elem, name, data, true);
        },
        _removeData: function(elem, name) {
            return internalRemoveData(elem, name, true);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            // Special expections of .data basically thwart jQuery.access,
            // so implement the relevant behavior ourselves
            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        jQuery._data(elem, "parsedAttrs", true);
                    }
                }
                return data;
            }
            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function() {
                    jQuery.data(this, key);
                });
            }
            // Sets one value
            // Gets one value
            // Try to fetch any internally stored data first
            return arguments.length > 1 ? this.each(function() {
                jQuery.data(this, key, value);
            }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
        },
        removeData: function(key) {
            return this.each(function() {
                jQuery.removeData(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = jQuery._data(elem, type);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                // clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    jQuery._removeData(elem, type + "queue");
                    jQuery._removeData(elem, key);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                // ensure a hooks for this queue
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = jQuery._data(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, length = elems.length, bulk = key == null;
        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < length; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        // Gets
        return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function() {
        // Minified: var a,b,c
        var input = document.createElement("input"), div = document.createElement("div"), fragment = document.createDocumentFragment();
        // Setup
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        // IE strips leading whitespace when .innerHTML is used
        support.leadingWhitespace = div.firstChild.nodeType === 3;
        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        support.tbody = !div.getElementsByTagName("tbody").length;
        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        support.htmlSerialize = !!div.getElementsByTagName("link").length;
        // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        support.html5Clone = document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>";
        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        input.type = "checkbox";
        input.checked = true;
        fragment.appendChild(input);
        support.appendChecked = input.checked;
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE6-IE11+
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        // #11217 - WebKit loses check when the name is after the checked attribute
        fragment.appendChild(div);
        div.innerHTML = "<input type='radio' checked='checked' name='t'/>";
        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        // Support: IE<9
        // Opera does not clone events (and typeof div.attachEvent === undefined).
        // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
        support.noCloneEvent = true;
        if (div.attachEvent) {
            div.attachEvent("onclick", function() {
                support.noCloneEvent = false;
            });
            div.cloneNode(true).click();
        }
        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
    })();
    (function() {
        var i, eventName, div = document.createElement("div");
        // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
        for (i in {
            submit: true,
            change: true,
            focusin: true
        }) {
            eventName = "on" + i;
            if (!(support[i + "Bubbles"] = eventName in window)) {
                // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                div.setAttribute(eventName, "t");
                support[i + "Bubbles"] = div.attributes[eventName].expando === false;
            }
        }
        // Null elements to avoid leaks in IE.
        div = null;
    })();
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }
            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }
            // Handle multiple events separated by a space
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }
                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};
                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;
                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};
                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }
            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery._removeData(elem, "events");
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                // jQuery handler
                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        try {
                            elem[type]();
                        } catch (e) {}
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);
            var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;
            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    // Triggered event must either 1) have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                /* jshint eqeqeq: false */
                for (;cur != this; cur = cur.parentNode || this) {
                    /* jshint eqeqeq: true */
                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            // Support: IE<9
            // Fix target property (#1925)
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }
            // Support: Chrome 23+, Safari?
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            // Support: IE<9
            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        try {
                            this.focus();
                            return false;
                        } catch (e) {}
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (jQuery.nodeName(this, "input") && this.type === "checkbox" && this.click) {
                        this.click();
                        return false;
                    }
                },
                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } : function(elem, type, handle) {
        var name = "on" + type;
        if (elem.detachEvent) {
            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if (typeof elem[name] === strundefined) {
                elem[name] = null;
            }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: IE < 9, Android < 4.0
            src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }
        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();
        // Mark it as fixed
        this[jQuery.expando] = true;
    };
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (!e) {
                return;
            }
            // If preventDefault exists, run it on the original event
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (!e) {
                return;
            }
            // If stopPropagation exists, run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // Support: IE
            // Set the cancelBubble property of the original event to true
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    // IE submit delegation
    if (!support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function() {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }
                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target, form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                    if (form && !jQuery._data(form, "submitBubbles")) {
                        jQuery.event.add(form, "submit._submit", function(event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, "submitBubbles", true);
                    }
                });
            },
            postDispatch: function(event) {
                // If form was submitted by the user, bubble the event up the tree
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate("submit", this.parentNode, event, true);
                    }
                }
            },
            teardown: function() {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }
                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, "._submit");
            }
        };
    }
    // IE change delegation and checkbox/radio fix
    if (!support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function() {
                if (rformElems.test(this.nodeName)) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function(event) {
                            if (event.originalEvent.propertyName === "checked") {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, "click._change", function(event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            // Allow triggered, simulated change events (#11500)
                            jQuery.event.simulate("change", this, event, true);
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, "beforeactivate._change", function(e) {
                    var elem = e.target;
                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles")) {
                        jQuery.event.add(elem, "change._change", function(event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate("change", this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, "changeBubbles", true);
                    }
                });
            },
            handle: function(event) {
                var elem = event.target;
                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== "radio" && elem.type !== "checkbox") {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },
            teardown: function() {
                jQuery.event.remove(this, "._change");
                return !rformElems.test(this.nodeName);
            }
        };
    }
    // Create "bubbling" focus and blur events
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    jQuery._data(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        jQuery._removeData(doc, fix);
                    } else {
                        jQuery._data(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
            var type, origFn;
            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    function createSafeFragment(document) {
        var list = nodeNames.split("|"), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement("div"));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || "*") : undefined;
        if (!found) {
            for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                if (!tag || jQuery.nodeName(elem, tag)) {
                    found.push(elem);
                } else {
                    jQuery.merge(found, getAll(elem, tag));
                }
            }
        }
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], found) : found;
    }
    // Used in buildFragment, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }
    // Support: IE<8
    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (jQuery.find.attr(elem, "type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var elem, i = 0;
        for (;(elem = elems[i]) != null; i++) {
            jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"));
        }
    }
    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }
        var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
        if (events) {
            delete curData.handle;
            curData.events = {};
            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }
        // make the cloned public data object a copy from the original
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }
    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;
        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }
        nodeName = dest.nodeName.toLowerCase();
        // IE6-8 copies events bound via attachEvent when using cloneNode.
        if (!support.noCloneEvent && dest[jQuery.expando]) {
            data = jQuery._data(dest);
            for (e in data.events) {
                jQuery.removeEvent(dest, e, data.handle);
            }
            // Event data gets referenced instead of copied if the expando gets copied too
            dest.removeAttribute(jQuery.expando);
        }
        // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
        if (nodeName === "script" && dest.text !== src.text) {
            disableScript(dest).text = src.text;
            restoreScript(dest);
        } else if (nodeName === "object") {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }
            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === "input" && rcheckableType.test(src.type)) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set
            dest.defaultChecked = dest.checked = src.checked;
            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }
        } else if (nodeName === "option") {
            dest.defaultSelected = dest.selected = src.defaultSelected;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
                clone = elem.cloneNode(true);
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }
            if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);
                // Fix all IE cloning issues
                for (i = 0; (node = srcElements[i]) != null; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        fixCloneNodeIssues(node, destElements[i]);
                    }
                }
            }
            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0; (node = srcElements[i]) != null; i++) {
                        cloneCopyEvent(node, destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            destElements = srcElements = node = null;
            // Return the cloned set
            return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, // Ensure a safe fragment
            safe = createSafeFragment(context), nodes = [], i = 0;
            for (;i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    // Add nodes directly
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || safe.appendChild(context.createElement("div"));
                        // Deserialize a standard representation
                        tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        // Manually add leading whitespace removed by IE
                        if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                        }
                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!support.tbody) {
                            // String was a <table>, *may* have spurious <tbody>
                            elem = tag === "table" && !rtbody.test(elem) ? tmp.firstChild : // String was a bare <thead> or <tfoot>
                            wrap[1] === "<table>" && !rtbody.test(elem) ? tmp : 0;
                            j = elem && elem.childNodes.length;
                            while (j--) {
                                if (jQuery.nodeName(tbody = elem.childNodes[j], "tbody") && !tbody.childNodes.length) {
                                    elem.removeChild(tbody);
                                }
                            }
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        // Fix #12392 for WebKit and IE > 9
                        tmp.textContent = "";
                        // Fix #12392 for oldIE
                        while (tmp.firstChild) {
                            tmp.removeChild(tmp.firstChild);
                        }
                        // Remember the top-level container for proper cleanup
                        tmp = safe.lastChild;
                    }
                }
            }
            // Fix #11356: Clear elements from fragment
            if (tmp) {
                safe.removeChild(tmp);
            }
            // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            if (!support.appendChecked) {
                jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
            }
            i = 0;
            while (elem = nodes[i++]) {
                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                // Append to fragment
                tmp = getAll(safe.appendChild(elem), "script");
                // Preserve script evaluation history
                if (contains) {
                    setGlobalEval(tmp);
                }
                // Capture executables
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            tmp = null;
            return safe;
        },
        cleanData: function(elems, /* internal */ acceptData) {
            var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
            for (;(elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        // Remove cache only if it was not already removed by jQuery.event.remove
                        if (cache[id]) {
                            delete cache[id];
                            // IE does not allow us to delete expando properties from nodes,
                            // nor does it have a removeAttribute function on Document nodes;
                            // we must handle all of these cases
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (typeof elem.removeAttribute !== strundefined) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }
                            deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function(selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (;(elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                }
                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
                // If this is a select, ensure that it displays empty (#12336)
                // Support: IE<9
                if (elem.options && jQuery.nodeName(elem, "select")) {
                    elem.options.length = 0;
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined) {
                    return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined;
                }
                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;i < l; i++) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            // Make the changes, replacing each context element with the new content
            this.domManip(arguments, function(elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, true);
        },
        domManip: function(args, callback) {
            // Flatten any nested arrays
            args = concat.apply([], args);
            var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            // We can't cloneNode fragments that contain checked, in WebKit
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function(index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                    hasScripts = scripts.length;
                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for (;i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            // Keep references to cloned scripts for later restoration
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        // Reenable scripts
                        jQuery.map(scripts, restoreScript);
                        // Evaluate executable scripts on first document insertion
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || "") && !jQuery._data(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, ""));
                                }
                            }
                        }
                    }
                    // Fix #11809: Avoid leaking memory
                    fragment = first = null;
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    /**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? // Use of this method is a temporary fix (more like optmization) until something better comes along,
        // since it was removed from specification and supported only in FF
        style.display : jQuery.css(elem[0], "display");
        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();
        return display;
    }
    /**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            // If the simple way fails, read from inside an iframe
            if (display === "none" || !display) {
                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                // Support: IE
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            // Store the correct default display
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    (function() {
        var shrinkWrapBlocksVal;
        support.shrinkWrapBlocks = function() {
            if (shrinkWrapBlocksVal != null) {
                return shrinkWrapBlocksVal;
            }
            // Will be changed later if needed.
            shrinkWrapBlocksVal = false;
            // Minified: var b,c,d
            var div, body, container;
            body = document.getElementsByTagName("body")[0];
            if (!body || !body.style) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }
            // Setup
            div = document.createElement("div");
            container = document.createElement("div");
            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
            body.appendChild(container).appendChild(div);
            // Support: IE6
            // Check if elements with layout shrink-wrap their children
            if (typeof div.style.zoom !== strundefined) {
                // Reset CSS: box-sizing; display; margin; border
                div.style.cssText = // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;" + "padding:1px;width:1px;zoom:1";
                div.appendChild(document.createElement("div")).style.width = "5px";
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
            }
            body.removeChild(container);
            return shrinkWrapBlocksVal;
        };
    })();
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
    if (window.getComputedStyle) {
        getStyles = function(elem) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        };
        curCSS = function(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
            if (computed) {
                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                // A tribute to the "awesome hack by Dean Edwards"
                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    // Remember the original values
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    // Put in the new values to get a computed value out
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    // Revert the changed values
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ? ret : ret + "";
        };
    } else if (document.documentElement.currentStyle) {
        getStyles = function(elem) {
            return elem.currentStyle;
        };
        curCSS = function(elem, name, computed) {
            var left, rs, rsLeft, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed[name] : undefined;
            // Avoid setting ret to empty string here
            // so we don't default to auto
            if (ret == null && style && style[name]) {
                ret = style[name];
            }
            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            // but not position css attributes, as those are proportional to the parent element instead
            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                // Remember the original values
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;
                // Put in the new values to get a computed value out
                if (rsLeft) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";
                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    rs.left = rsLeft;
                }
            }
            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ? ret : ret + "" || "auto";
        };
    }
    function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                var condition = conditionFn();
                if (condition == null) {
                    // The test was not ready at this point; screw the hook this time
                    // but check again when needed next time.
                    return;
                }
                if (condition) {
                    // Hook not needed (or it's not possible to use it due to missing dependency),
                    // remove it.
                    // Since there are no other hooks for marginRight, remove the whole object.
                    delete this.get;
                    return;
                }
                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function() {
        // Minified: var b,c,d,e,f,g, h,i
        var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal;
        // Setup
        div = document.createElement("div");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName("a")[0];
        style = a && a.style;
        // Finish early in limited (non-browser) environments
        if (!style) {
            return;
        }
        style.cssText = "float:left;opacity:.5";
        // Support: IE<9
        // Make sure that element opacity exists (as opposed to filter)
        support.opacity = style.opacity === "0.5";
        // Verify style float existence
        // (IE uses styleFloat instead of cssFloat)
        support.cssFloat = !!style.cssFloat;
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" || style.WebkitBoxSizing === "";
        jQuery.extend(support, {
            reliableHiddenOffsets: function() {
                if (reliableHiddenOffsetsVal == null) {
                    computeStyleTests();
                }
                return reliableHiddenOffsetsVal;
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelPosition: function() {
                if (pixelPositionVal == null) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },
            // Support: Android 2.3
            reliableMarginRight: function() {
                if (reliableMarginRightVal == null) {
                    computeStyleTests();
                }
                return reliableMarginRightVal;
            }
        });
        function computeStyleTests() {
            // Minified: var b,c,d,j
            var div, body, container, contents;
            body = document.getElementsByTagName("body")[0];
            if (!body || !body.style) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }
            // Setup
            div = document.createElement("div");
            container = document.createElement("div");
            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
            body.appendChild(container).appendChild(div);
            div.style.cssText = // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
            // Support: IE<9
            // Assume reasonable values in the absence of getComputedStyle
            pixelPositionVal = boxSizingReliableVal = false;
            reliableMarginRightVal = true;
            // Check for getComputedStyle so that this code is not run in IE<9.
            if (window.getComputedStyle) {
                pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== "1%";
                boxSizingReliableVal = (window.getComputedStyle(div, null) || {
                    width: "4px"
                }).width === "4px";
                // Support: Android 2.3
                // Div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                contents = div.appendChild(document.createElement("div"));
                // Reset CSS: box-sizing; display; margin; border; padding
                contents.style.cssText = div.style.cssText = // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                contents.style.marginRight = contents.style.width = "0";
                div.style.width = "1px";
                reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight);
            }
            // Support: IE8
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            contents = div.getElementsByTagName("td");
            contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
            reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
            if (reliableHiddenOffsetsVal) {
                contents[0].style.display = "";
                contents[1].style.display = "none";
                reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
            }
            body.removeChild(container);
        }
    })();
    // A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {
        // shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }
        // check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display && display !== "none" || !hidden) {
                    jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
        4 : // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            // both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                // at this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                // at this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }
            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }
        // use the active box-sizing model to add/subtract irrelevant styles
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": support.cssFloat ? "cssFloat" : "styleFloat"
        },
        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            // Make sure that we're working with the right name
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;
                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }
                // Make sure that null and NaN values aren't set. See: #7116
                if (value == null || value !== value) {
                    return;
                }
                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }
                // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    // Support: IE
                    // Swallow errors from 'invalid' CSS values (#5509)
                    try {
                        style[name] = value;
                    } catch (e) {}
                }
            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                // Otherwise just get the value from the style object
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var num, val, hooks, origName = jQuery.camelCase(name);
            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            //convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
            }
        };
    });
    if (!support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function(elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
            },
            set: function(elem, value) {
                var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "", filter = currentStyle && currentStyle.filter || style.filter || "";
                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;
                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                // if value === "", then remove inline opacity #12685
                if ((value >= 1 || value === "") && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {
                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute("filter");
                    // if there is no filter style applied in a css rule or unset inline opacity, we are done
                    if (value === "" || currentStyle && !currentStyle.filter) {
                        return;
                    }
                }
                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
            }
        };
    }
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, // assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css(tween.elem, tween.prop, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    // Support: IE <=9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    // Back Compat <1.8 extension point
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
            start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                // Trust units reported by jQuery.css
                unit = unit || start[3];
                // Make sure we update the tween properties later on
                parts = parts || [];
                // Iteratively approximate from a nonzero starting point
                start = +target || 1;
                do {
                    // If previous iteration zeroed out, double until we get *something*
                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                    scale = scale || ".5";
                    // Adjust and apply
                    start = start / scale;
                    jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
            }
            // Update tween properties
            if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
            }
            return tween;
        } ]
    };
    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, attrs = {
            height: type
        }, i = 0;
        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                // we're done with this property
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, "fxshow");
        // handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        // height/width overflow pass
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE does not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, "display");
            // Test default display if display is currently "none"
            checkDisplay = display === "none" ? jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === "inline") {
                    style.display = "inline-block";
                } else {
                    style.zoom = 1;
                }
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            if (!support.shrinkWrapBlocks()) {
                anim.always(function() {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }
        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data(elem, "fxshow", {});
            }
            // store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                jQuery._removeData(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
            temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, // if we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                // resolve when we played the last frame
                // otherwise, reject
                if (gotoEnd) {
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        // attach callbacks from options
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        // normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        // Queueing
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            // show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                // Empty animations, or finishing resolves immediately
                if (empty || jQuery._data(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = jQuery._data(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = jQuery._data(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                // enable finishing flag on private data
                data.finish = true;
                // empty the queue first
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                // look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                // look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                // turn off finishing flag
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, timers = jQuery.timers, i = 0;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    };
    (function() {
        // Minified: var a,b,c,d,e
        var input, div, select, a, opt;
        // Setup
        div = document.createElement("div");
        div.setAttribute("className", "t");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName("a")[0];
        // First batch of tests.
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];
        a.style.cssText = "top:1px";
        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
        support.getSetAttribute = div.className !== "t";
        // Get the style information from getAttribute
        // (IE uses .cssText instead)
        support.style = /top/.test(a.getAttribute("style"));
        // Make sure that URLs aren't manipulated
        // (IE normalizes it by default)
        support.hrefNormalized = a.getAttribute("href") === "/a";
        // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
        support.checkOn = !!input.value;
        // Make sure that a selected-by-default option has a working selected property.
        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
        support.optSelected = opt.selected;
        // Tests for enctype support on a form (#6743)
        support.enctype = !!document.createElement("form").enctype;
        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        // Support: IE8 only
        // Check if we can trust getAttribute("value")
        input = document.createElement("input");
        input.setAttribute("value", "");
        support.input = input.getAttribute("value") === "";
        // Check if an input maintains its value after becoming a radio
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";
    })();
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    // handle most common string cases
                    // handle cases where value is null/undef or number
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    // Loop through all the selected options
                    for (;i < max; i++) {
                        option = options[i];
                        // oldIE doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) && (// Don't return options that are disabled or in a disabled optgroup
                        support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            // Get the specific value for the option
                            value = jQuery(option).val();
                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }
                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                            // Support: IE6
                            // When new option element is added to select box we need to
                            // force reflow of newly added node in order to workaround delay
                            // of initialization properties
                            try {
                                option.selected = optionSet = true;
                            } catch (_) {
                                // Will be executed only in IE6
                                option.scrollHeight;
                            }
                        } else {
                            option.selected = false;
                        }
                    }
                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return options;
                }
            }
        }
    });
    // Radios and checkboxes getter/setter
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                // Support: Webkit
                // "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                        // Set corresponding property to false
                        if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                            elem[propName] = false;
                        } else {
                            elem[jQuery.camelCase("default-" + name)] = elem[propName] = false;
                        }
                    } else {
                        jQuery.attr(elem, name, "");
                    }
                    elem.removeAttribute(getSetAttribute ? name : propName);
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    // Hook for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                // IE<8 needs the *property* name
                elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
            } else {
                elem[jQuery.camelCase("default-" + name)] = elem[name] = true;
            }
            return name;
        }
    };
    // Retrieve booleans specially
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        } : function(elem, name, isXML) {
            if (!isXML) {
                return elem[jQuery.camelCase("default-" + name)] ? name.toLowerCase() : null;
            }
        };
    });
    // fix oldIE attroperties
    if (!getSetInput || !getSetAttribute) {
        jQuery.attrHooks.value = {
            set: function(elem, value, name) {
                if (jQuery.nodeName(elem, "input")) {
                    // Does not return so that setAttribute is also used
                    elem.defaultValue = value;
                } else {
                    // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                    return nodeHook && nodeHook.set(elem, value, name);
                }
            }
        };
    }
    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!getSetAttribute) {
        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = {
            set: function(elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
                }
                ret.value = value += "";
                // Break association with cloned elements by also using setAttribute (#9646)
                if (name === "value" || value === elem.getAttribute(name)) {
                    return value;
                }
            }
        };
        // Some attributes are constructed with empty-string values when not defined
        attrHandle.id = attrHandle.name = attrHandle.coords = function(elem, name, isXML) {
            var ret;
            if (!isXML) {
                return (ret = elem.getAttributeNode(name)) && ret.value !== "" ? ret.value : null;
            }
        };
        // Fixing value retrieval on a button requires this module
        jQuery.valHooks.button = {
            get: function(elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) {
                    return ret.value;
                }
            },
            set: nodeHook.set
        };
        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            set: function(elem, value, name) {
                nodeHook.set(elem, value === "" ? false : value, name);
            }
        };
        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each([ "width", "height" ], function(i, name) {
            jQuery.attrHooks[name] = {
                set: function(elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            };
        });
    }
    if (!support.style) {
        jQuery.attrHooks.style = {
            get: function(elem) {
                // Return undefined in the case of empty string
                // Note: IE uppercases css property names, but if we were to .toLowerCase()
                // .cssText, that would destroy case senstitivity in URL's, like in "background"
                return elem.style.cssText || undefined;
            },
            set: function(elem, value) {
                return elem.style.cssText = value + "";
            }
        };
    }
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            name = jQuery.propFix[name] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {}
            });
        }
    });
    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        }
    });
    // Some attributes require a special call on IE
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!support.hrefNormalized) {
        // href/src property should get the full normalized URL (#10299/#12915)
        jQuery.each([ "href", "src" ], function(i, name) {
            jQuery.propHooks[name] = {
                get: function(elem) {
                    return elem.getAttribute(name, 4);
                }
            };
        });
    }
    // Support: Safari, IE9+
    // mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    // IE6/7 call enctype encoding
    if (!support.enctype) {
        jQuery.propFix.enctype = "encoding";
    }
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === "string" && value;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === "string" && value;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || [];
                for (;i < len; i++) {
                    elem = this[i];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        // only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim(cur) : "";
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function() {
                if (type === "string") {
                    // toggle individual class names
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        // check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }
                    // If the element has a class name or if we're passed "false",
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ", i = 0, l = this.length;
            for (;i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    // Return jQuery for attributes-only inclusion
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery.parseJSON = function(data) {
        // Attempt to parse using the native JSON parser first
        if (window.JSON && window.JSON.parse) {
            // Support: Android 2.3
            // Workaround failure to string-cast null input
            return window.JSON.parse(data + "");
        }
        var requireNonComma, depth = null, str = jQuery.trim(data + "");
        // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
        // after removing valid tokens
        return str && !jQuery.trim(str.replace(rvalidtokens, function(token, comma, open, close) {
            // Force termination if we see a misplaced comma
            if (requireNonComma && comma) {
                depth = 0;
            }
            // Perform no more replacements after returning to outermost depth
            if (depth === 0) {
                return token;
            }
            // Commas must not follow "[", "{", or ","
            requireNonComma = open || comma;
            // Determine new depth
            // array/object open ("[" or "{"): depth += true - false (increment)
            // array/object close ("]" or "}"): depth += false - true (decrement)
            // other cases ("," or primitive): depth += true - true (numeric cast)
            depth += !close - !open;
            // Remove this token
            return "";
        })) ? Function("return " + str)() : jQuery.error("Invalid JSON: " + data);
    };
    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            if (window.DOMParser) {
                // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString(data, "text/xml");
            } else {
                // IE
                xml = new ActiveXObject("Microsoft.XMLDOM");
                xml.async = "false";
                xml.loadXML(data);
            }
        } catch (e) {
            xml = undefined;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var // Document location
    ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*");
    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }
    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                while (dataType = dataTypes[i++]) {
                    // Prepend if requested
                    if (dataType.charAt(0) === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {
        var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }
        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();
        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        // Convert to each sequential dataType
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                // There's only work to do if current dataType is non-auto
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];
                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {
                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,
                // Parse text as xml
                "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            // Building a settings object
            // Extending ajaxSettings
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            // Force options to be an object
            options = options || {};
            var // Cross-domain detection vars
            parts, // Loop variable
            i, // URL without anti-cache param
            cacheURL, // Response headers as string
            responseHeadersString, // timeout handle
            timeoutTimer, // To know if global events are to be dispatched
            fireGlobals, transport, // Response headers
            responseHeaders, // Create the final options object
            s = jQuery.ajaxSetup({}, options), // Callbacks context
            callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), // Status-dependent callbacks
            statusCode = s.statusCode || {}, // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {}, // The jqXHR state
            state = 0, // Default abort message
            strAbort = "canceled", // Fake xhr
            jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            // Execute the appropriate callbacks
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;
            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
            }
            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }
            // We can fire global events as of now if asked to
            fireGlobals = s.global;
            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            // Uppercase the type
            s.type = s.type.toUpperCase();
            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);
            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;
            // More options handling for requests with no content
            if (!s.hasContent) {
                // If data is available, append data to url
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }
                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value
                    cacheURL.replace(rts, "$1_=" + nonce++) : // Otherwise add one to the end
                    cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();
            }
            // aborting is no longer a cancellation
            strAbort = "abort";
            // Install callbacks on deferreds
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                // Called once
                if (state === 2) {
                    return;
                }
                // State is "done" now
                state = 2;
                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;
                // Cache response headers
                responseHeadersString = headers || "";
                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;
                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;
                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                // If successful, handle type chaining
                if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                // Complete
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    // Handle the global AJAX counter
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, "display")) === "none";
    };
    jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            // Serialize the form elements
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                // Use .is(":disabled") so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? // Support: IE6+
    function() {
        // XHR cannot access local files, always use ActiveX for that case
        // Support: IE7-8
        // oldIE XHR does not support non-RFC2616 methods (#13240)
        // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
        // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
        // Although this check for six methods instead of eight
        // since IE also does not support "trace" and "connect"
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
    } : // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
    // Support: IE<10
    // Open requests must be manually aborted on unload (#5280)
    if (window.ActiveXObject) {
        jQuery(window).on("unload", function() {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](undefined, true);
            }
        });
    }
    // Determine support properties
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;
    // Create transport if the browser can provide an xhr
    if (xhrSupported) {
        jQuery.ajaxTransport(function(options) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!options.crossDomain || support.cors) {
                var callback;
                return {
                    send: function(headers, complete) {
                        var i, xhr = options.xhr(), id = ++xhrId;
                        // Open the socket
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        // Apply custom fields if provided
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        // Override mime type if needed
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!options.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }
                        // Set headers
                        for (i in headers) {
                            // Support: IE<9
                            // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                            // request header to a null-value.
                            //
                            // To keep consistent with other XHR implementations, cast the value
                            // to string and ignore `undefined`.
                            if (headers[i] !== undefined) {
                                xhr.setRequestHeader(i, headers[i] + "");
                            }
                        }
                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send(options.hasContent && options.data || null);
                        // Listener
                        callback = function(_, isAbort) {
                            var status, statusText, responses;
                            // Was never called and is aborted or complete
                            if (callback && (isAbort || xhr.readyState === 4)) {
                                // Clean up
                                delete xhrCallbacks[id];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;
                                // Abort manually if needed
                                if (isAbort) {
                                    if (xhr.readyState !== 4) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;
                                    // Support: IE<10
                                    // Accessing binary-data responseText throws an exception
                                    // (#11426)
                                    if (typeof xhr.responseText === "string") {
                                        responses.text = xhr.responseText;
                                    }
                                    // Firefox throws an exception when accessing
                                    // statusText for faulty cross-domain requests
                                    try {
                                        statusText = xhr.statusText;
                                    } catch (e) {
                                        // We normalize with Webkit giving an empty statusText
                                        statusText = "";
                                    }
                                    // Filter status for non standard behaviors
                                    // If the request is local and we have data: assume a success
                                    // (success with no data won't get notified, that's the best we
                                    // can do given current implementations)
                                    if (!status && options.isLocal && !options.crossDomain) {
                                        status = responses.text ? 200 : 404;
                                    } else if (status === 1223) {
                                        status = 204;
                                    }
                                }
                            }
                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, xhr.getAllResponseHeaders());
                            }
                        };
                        if (!options.async) {
                            // if we're in sync mode we fire the callback
                            callback();
                        } else if (xhr.readyState === 4) {
                            // (IE6 & IE7) if it's in cache and has been
                            // retrieved directly we need to fire the callback
                            setTimeout(callback);
                        } else {
                            // Add to the list of active xhr callbacks
                            xhr.onreadystatechange = xhrCallbacks[id] = callback;
                        }
                    },
                    abort: function() {
                        if (callback) {
                            callback(undefined, true);
                        }
                    }
                };
            }
        });
    }
    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}
    }
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });
    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {
        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, head = document.head || jQuery("head")[0] || document.documentElement;
            return {
                send: function(_, callback) {
                    script = document.createElement("script");
                    script.async = true;
                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }
                    script.src = s.url;
                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function(_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;
                            // Remove the script
                            if (script.parentNode) {
                                script.parentNode.removeChild(script);
                            }
                            // Dereference the script
                            script = null;
                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    head.insertBefore(script, head.firstChild);
                },
                abort: function() {
                    if (script) {
                        script.onload(undefined, true);
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            // force json dataType
            s.dataTypes[0] = "json";
            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[callbackName] = overwritten;
                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }
                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            // Delegate to script
            return "script";
        }
    });
    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        // Single tag
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = jQuery.buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    // Keep a copy of the old load method
    var _load = jQuery.fn.load;
    /**
 * Load a url into a page
 */
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, response, type, self = this, off = url.indexOf(" ");
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off, url.length));
            url = url.slice(0, off);
        }
        // If it's a function
        if (jQuery.isFunction(params)) {
            // We assume that it's the callback
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function(responseText) {
                // Save response for use in complete callback
                response = arguments;
                self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
                responseText);
            }).complete(callback && function(jqXHR, status) {
                self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    /**
 * Gets a window from an element
 */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [ curCSSTop, curCSSLeft ]) > -1;
            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, box = {
                top: 0,
                left: 0
            }, elem = this[0], doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, parentOffset = {
                top: 0,
                left: 0
            }, elem = this[0];
            // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") {
                // we assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();
            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();
                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            // Subtract parent offsets and element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }
                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                        // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    // Get width or height on the element, requesting but not forcing parseFloat
                    // Set width or height on the element
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    // The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery, // Map over the $ in case of overwrite
    _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    // Expose jQuery and $ identifiers, even in
    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

!function(a) {
    a.Parse = a.Parse || {}, a.Parse.VERSION = "js1.4.2";
}(this), function() {
    var a = this, b = a._, c = {}, d = Array.prototype, e = Object.prototype, f = Function.prototype, g = d.push, h = d.slice, i = d.concat, j = e.toString, k = e.hasOwnProperty, l = d.forEach, m = d.map, n = d.reduce, o = d.reduceRight, p = d.filter, q = d.every, r = d.some, s = d.indexOf, t = d.lastIndexOf, u = Array.isArray, v = Object.keys, w = f.bind, x = function(a) {
        return a instanceof x ? a : this instanceof x ? void (this._wrapped = a) : new x(a);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = x), 
    exports._ = x) : a._ = x, x.VERSION = "1.4.4";
    var y = x.each = x.forEach = function(a, b, d) {
        if (null != a) if (l && a.forEach === l) a.forEach(b, d); else if (a.length === +a.length) {
            for (var e = 0, f = a.length; f > e; e++) if (b.call(d, a[e], e, a) === c) return;
        } else for (var g in a) if (x.has(a, g) && b.call(d, a[g], g, a) === c) return;
    };
    x.map = x.collect = function(a, b, c) {
        var d = [];
        return null == a ? d : m && a.map === m ? a.map(b, c) : (y(a, function(a, e, f) {
            d[d.length] = b.call(c, a, e, f);
        }), d);
    };
    var z = "Reduce of empty array with no initial value";
    x.reduce = x.foldl = x.inject = function(a, b, c, d) {
        var e = arguments.length > 2;
        if (null == a && (a = []), n && a.reduce === n) return d && (b = x.bind(b, d)), 
        e ? a.reduce(b, c) : a.reduce(b);
        if (y(a, function(a, f, g) {
            e ? c = b.call(d, c, a, f, g) : (c = a, e = !0);
        }), !e) throw new TypeError(z);
        return c;
    }, x.reduceRight = x.foldr = function(a, b, c, d) {
        var e = arguments.length > 2;
        if (null == a && (a = []), o && a.reduceRight === o) return d && (b = x.bind(b, d)), 
        e ? a.reduceRight(b, c) : a.reduceRight(b);
        var f = a.length;
        if (f !== +f) {
            var g = x.keys(a);
            f = g.length;
        }
        if (y(a, function(h, i, j) {
            i = g ? g[--f] : --f, e ? c = b.call(d, c, a[i], i, j) : (c = a[i], e = !0);
        }), !e) throw new TypeError(z);
        return c;
    }, x.find = x.detect = function(a, b, c) {
        var d;
        return A(a, function(a, e, f) {
            return b.call(c, a, e, f) ? (d = a, !0) : void 0;
        }), d;
    }, x.filter = x.select = function(a, b, c) {
        var d = [];
        return null == a ? d : p && a.filter === p ? a.filter(b, c) : (y(a, function(a, e, f) {
            b.call(c, a, e, f) && (d[d.length] = a);
        }), d);
    }, x.reject = function(a, b, c) {
        return x.filter(a, function(a, d, e) {
            return !b.call(c, a, d, e);
        }, c);
    }, x.every = x.all = function(a, b, d) {
        b || (b = x.identity);
        var e = !0;
        return null == a ? e : q && a.every === q ? a.every(b, d) : (y(a, function(a, f, g) {
            return (e = e && b.call(d, a, f, g)) ? void 0 : c;
        }), !!e);
    };
    var A = x.some = x.any = function(a, b, d) {
        b || (b = x.identity);
        var e = !1;
        return null == a ? e : r && a.some === r ? a.some(b, d) : (y(a, function(a, f, g) {
            return e || (e = b.call(d, a, f, g)) ? c : void 0;
        }), !!e);
    };
    x.contains = x.include = function(a, b) {
        return null == a ? !1 : s && a.indexOf === s ? -1 != a.indexOf(b) : A(a, function(a) {
            return a === b;
        });
    }, x.invoke = function(a, b) {
        var c = h.call(arguments, 2), d = x.isFunction(b);
        return x.map(a, function(a) {
            return (d ? b : a[b]).apply(a, c);
        });
    }, x.pluck = function(a, b) {
        return x.map(a, function(a) {
            return a[b];
        });
    }, x.where = function(a, b, c) {
        return x.isEmpty(b) ? c ? null : [] : x[c ? "find" : "filter"](a, function(a) {
            for (var c in b) if (b[c] !== a[c]) return !1;
            return !0;
        });
    }, x.findWhere = function(a, b) {
        return x.where(a, b, !0);
    }, x.max = function(a, b, c) {
        if (!b && x.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.max.apply(Math, a);
        if (!b && x.isEmpty(a)) return -(1 / 0);
        var d = {
            computed: -(1 / 0),
            value: -(1 / 0)
        };
        return y(a, function(a, e, f) {
            var g = b ? b.call(c, a, e, f) : a;
            g >= d.computed && (d = {
                value: a,
                computed: g
            });
        }), d.value;
    }, x.min = function(a, b, c) {
        if (!b && x.isArray(a) && a[0] === +a[0] && a.length < 65535) return Math.min.apply(Math, a);
        if (!b && x.isEmpty(a)) return 1 / 0;
        var d = {
            computed: 1 / 0,
            value: 1 / 0
        };
        return y(a, function(a, e, f) {
            var g = b ? b.call(c, a, e, f) : a;
            g < d.computed && (d = {
                value: a,
                computed: g
            });
        }), d.value;
    }, x.shuffle = function(a) {
        var b, c = 0, d = [];
        return y(a, function(a) {
            b = x.random(c++), d[c - 1] = d[b], d[b] = a;
        }), d;
    };
    var B = function(a) {
        return x.isFunction(a) ? a : function(b) {
            return b[a];
        };
    };
    x.sortBy = function(a, b, c) {
        var d = B(b);
        return x.pluck(x.map(a, function(a, b, e) {
            return {
                value: a,
                index: b,
                criteria: d.call(c, a, b, e)
            };
        }).sort(function(a, b) {
            var c = a.criteria, d = b.criteria;
            if (c !== d) {
                if (c > d || void 0 === c) return 1;
                if (d > c || void 0 === d) return -1;
            }
            return a.index < b.index ? -1 : 1;
        }), "value");
    };
    var C = function(a, b, c, d) {
        var e = {}, f = B(b || x.identity);
        return y(a, function(b, g) {
            var h = f.call(c, b, g, a);
            d(e, h, b);
        }), e;
    };
    x.groupBy = function(a, b, c) {
        return C(a, b, c, function(a, b, c) {
            (x.has(a, b) ? a[b] : a[b] = []).push(c);
        });
    }, x.countBy = function(a, b, c) {
        return C(a, b, c, function(a, b) {
            x.has(a, b) || (a[b] = 0), a[b]++;
        });
    }, x.sortedIndex = function(a, b, c, d) {
        c = null == c ? x.identity : B(c);
        for (var e = c.call(d, b), f = 0, g = a.length; g > f; ) {
            var h = f + g >>> 1;
            c.call(d, a[h]) < e ? f = h + 1 : g = h;
        }
        return f;
    }, x.toArray = function(a) {
        return a ? x.isArray(a) ? h.call(a) : a.length === +a.length ? x.map(a, x.identity) : x.values(a) : [];
    }, x.size = function(a) {
        return null == a ? 0 : a.length === +a.length ? a.length : x.keys(a).length;
    }, x.first = x.head = x.take = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[0] : h.call(a, 0, b);
    }, x.initial = function(a, b, c) {
        return h.call(a, 0, a.length - (null == b || c ? 1 : b));
    }, x.last = function(a, b, c) {
        return null == a ? void 0 : null == b || c ? a[a.length - 1] : h.call(a, Math.max(a.length - b, 0));
    }, x.rest = x.tail = x.drop = function(a, b, c) {
        return h.call(a, null == b || c ? 1 : b);
    }, x.compact = function(a) {
        return x.filter(a, x.identity);
    };
    var D = function(a, b, c) {
        return y(a, function(a) {
            x.isArray(a) ? b ? g.apply(c, a) : D(a, b, c) : c.push(a);
        }), c;
    };
    x.flatten = function(a, b) {
        return D(a, b, []);
    }, x.without = function(a) {
        return x.difference(a, h.call(arguments, 1));
    }, x.uniq = x.unique = function(a, b, c, d) {
        x.isFunction(b) && (d = c, c = b, b = !1);
        var e = c ? x.map(a, c, d) : a, f = [], g = [];
        return y(e, function(c, d) {
            (b ? d && g[g.length - 1] === c : x.contains(g, c)) || (g.push(c), f.push(a[d]));
        }), f;
    }, x.union = function() {
        return x.uniq(i.apply(d, arguments));
    }, x.intersection = function(a) {
        var b = h.call(arguments, 1);
        return x.filter(x.uniq(a), function(a) {
            return x.every(b, function(b) {
                return x.indexOf(b, a) >= 0;
            });
        });
    }, x.difference = function(a) {
        var b = i.apply(d, h.call(arguments, 1));
        return x.filter(a, function(a) {
            return !x.contains(b, a);
        });
    }, x.zip = function() {
        for (var a = h.call(arguments), b = x.max(x.pluck(a, "length")), c = new Array(b), d = 0; b > d; d++) c[d] = x.pluck(a, "" + d);
        return c;
    }, x.object = function(a, b) {
        if (null == a) return {};
        for (var c = {}, d = 0, e = a.length; e > d; d++) b ? c[a[d]] = b[d] : c[a[d][0]] = a[d][1];
        return c;
    }, x.indexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = 0, e = a.length;
        if (c) {
            if ("number" != typeof c) return d = x.sortedIndex(a, b), a[d] === b ? d : -1;
            d = 0 > c ? Math.max(0, e + c) : c;
        }
        if (s && a.indexOf === s) return a.indexOf(b, c);
        for (;e > d; d++) if (a[d] === b) return d;
        return -1;
    }, x.lastIndexOf = function(a, b, c) {
        if (null == a) return -1;
        var d = null != c;
        if (t && a.lastIndexOf === t) return d ? a.lastIndexOf(b, c) : a.lastIndexOf(b);
        for (var e = d ? c : a.length; e--; ) if (a[e] === b) return e;
        return -1;
    }, x.range = function(a, b, c) {
        arguments.length <= 1 && (b = a || 0, a = 0), c = arguments[2] || 1;
        for (var d = Math.max(Math.ceil((b - a) / c), 0), e = 0, f = new Array(d); d > e; ) f[e++] = a, 
        a += c;
        return f;
    }, x.bind = function(a, b) {
        if (a.bind === w && w) return w.apply(a, h.call(arguments, 1));
        var c = h.call(arguments, 2);
        return function() {
            return a.apply(b, c.concat(h.call(arguments)));
        };
    }, x.partial = function(a) {
        var b = h.call(arguments, 1);
        return function() {
            return a.apply(this, b.concat(h.call(arguments)));
        };
    }, x.bindAll = function(a) {
        var b = h.call(arguments, 1);
        return 0 === b.length && (b = x.functions(a)), y(b, function(b) {
            a[b] = x.bind(a[b], a);
        }), a;
    }, x.memoize = function(a, b) {
        var c = {};
        return b || (b = x.identity), function() {
            var d = b.apply(this, arguments);
            return x.has(c, d) ? c[d] : c[d] = a.apply(this, arguments);
        };
    }, x.delay = function(a, b) {
        var c = h.call(arguments, 2);
        return setTimeout(function() {
            return a.apply(null, c);
        }, b);
    }, x.defer = function(a) {
        return x.delay.apply(x, [ a, 1 ].concat(h.call(arguments, 1)));
    }, x.throttle = function(a, b) {
        var c, d, e, f, g = 0, h = function() {
            g = new Date(), e = null, f = a.apply(c, d);
        };
        return function() {
            var i = new Date(), j = b - (i - g);
            return c = this, d = arguments, 0 >= j ? (clearTimeout(e), e = null, g = i, f = a.apply(c, d)) : e || (e = setTimeout(h, j)), 
            f;
        };
    }, x.debounce = function(a, b, c) {
        var d, e;
        return function() {
            var f = this, g = arguments, h = function() {
                d = null, c || (e = a.apply(f, g));
            }, i = c && !d;
            return clearTimeout(d), d = setTimeout(h, b), i && (e = a.apply(f, g)), e;
        };
    }, x.once = function(a) {
        var b, c = !1;
        return function() {
            return c ? b : (c = !0, b = a.apply(this, arguments), a = null, b);
        };
    }, x.wrap = function(a, b) {
        return function() {
            var c = [ a ];
            return g.apply(c, arguments), b.apply(this, c);
        };
    }, x.compose = function() {
        var a = arguments;
        return function() {
            for (var b = arguments, c = a.length - 1; c >= 0; c--) b = [ a[c].apply(this, b) ];
            return b[0];
        };
    }, x.after = function(a, b) {
        return 0 >= a ? b() : function() {
            return --a < 1 ? b.apply(this, arguments) : void 0;
        };
    }, x.keys = v || function(a) {
        if (a !== Object(a)) throw new TypeError("Invalid object");
        var b = [];
        for (var c in a) x.has(a, c) && (b[b.length] = c);
        return b;
    }, x.values = function(a) {
        var b = [];
        for (var c in a) x.has(a, c) && b.push(a[c]);
        return b;
    }, x.pairs = function(a) {
        var b = [];
        for (var c in a) x.has(a, c) && b.push([ c, a[c] ]);
        return b;
    }, x.invert = function(a) {
        var b = {};
        for (var c in a) x.has(a, c) && (b[a[c]] = c);
        return b;
    }, x.functions = x.methods = function(a) {
        var b = [];
        for (var c in a) x.isFunction(a[c]) && b.push(c);
        return b.sort();
    }, x.extend = function(a) {
        return y(h.call(arguments, 1), function(b) {
            if (b) for (var c in b) a[c] = b[c];
        }), a;
    }, x.pick = function(a) {
        var b = {}, c = i.apply(d, h.call(arguments, 1));
        return y(c, function(c) {
            c in a && (b[c] = a[c]);
        }), b;
    }, x.omit = function(a) {
        var b = {}, c = i.apply(d, h.call(arguments, 1));
        for (var e in a) x.contains(c, e) || (b[e] = a[e]);
        return b;
    }, x.defaults = function(a) {
        return y(h.call(arguments, 1), function(b) {
            if (b) for (var c in b) null == a[c] && (a[c] = b[c]);
        }), a;
    }, x.clone = function(a) {
        return x.isObject(a) ? x.isArray(a) ? a.slice() : x.extend({}, a) : a;
    }, x.tap = function(a, b) {
        return b(a), a;
    };
    var E = function(a, b, c, d) {
        if (a === b) return 0 !== a || 1 / a == 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof x && (a = a._wrapped), b instanceof x && (b = b._wrapped);
        var e = j.call(a);
        if (e != j.call(b)) return !1;
        switch (e) {
          case "[object String]":
            return a == String(b);

          case "[object Number]":
            return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a == +b;

          case "[object RegExp]":
            return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if ("object" != typeof a || "object" != typeof b) return !1;
        for (var f = c.length; f--; ) if (c[f] == a) return d[f] == b;
        c.push(a), d.push(b);
        var g = 0, h = !0;
        if ("[object Array]" == e) {
            if (g = a.length, h = g == b.length) for (;g-- && (h = E(a[g], b[g], c, d)); ) ;
        } else {
            var i = a.constructor, k = b.constructor;
            if (i !== k && !(x.isFunction(i) && i instanceof i && x.isFunction(k) && k instanceof k)) return !1;
            for (var l in a) if (x.has(a, l) && (g++, !(h = x.has(b, l) && E(a[l], b[l], c, d)))) break;
            if (h) {
                for (l in b) if (x.has(b, l) && !g--) break;
                h = !g;
            }
        }
        return c.pop(), d.pop(), h;
    };
    x.isEqual = function(a, b) {
        return E(a, b, [], []);
    }, x.isEmpty = function(a) {
        if (null == a) return !0;
        if (x.isArray(a) || x.isString(a)) return 0 === a.length;
        for (var b in a) if (x.has(a, b)) return !1;
        return !0;
    }, x.isElement = function(a) {
        return !(!a || 1 !== a.nodeType);
    }, x.isArray = u || function(a) {
        return "[object Array]" == j.call(a);
    }, x.isObject = function(a) {
        return a === Object(a);
    }, y([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(a) {
        x["is" + a] = function(b) {
            return j.call(b) == "[object " + a + "]";
        };
    }), x.isArguments(arguments) || (x.isArguments = function(a) {
        return !(!a || !x.has(a, "callee"));
    }), "function" != typeof /./ && (x.isFunction = function(a) {
        return "function" == typeof a;
    }), x.isFinite = function(a) {
        return isFinite(a) && !isNaN(parseFloat(a));
    }, x.isNaN = function(a) {
        return x.isNumber(a) && a != +a;
    }, x.isBoolean = function(a) {
        return a === !0 || a === !1 || "[object Boolean]" == j.call(a);
    }, x.isNull = function(a) {
        return null === a;
    }, x.isUndefined = function(a) {
        return void 0 === a;
    }, x.has = function(a, b) {
        return k.call(a, b);
    }, x.noConflict = function() {
        return a._ = b, this;
    }, x.identity = function(a) {
        return a;
    }, x.times = function(a, b, c) {
        for (var d = Array(a), e = 0; a > e; e++) d[e] = b.call(c, e);
        return d;
    }, x.random = function(a, b) {
        return null == b && (b = a, a = 0), a + Math.floor(Math.random() * (b - a + 1));
    };
    var F = {
        escape: {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "/": "&#x2F;"
        }
    };
    F.unescape = x.invert(F.escape);
    var G = {
        escape: new RegExp("[" + x.keys(F.escape).join("") + "]", "g"),
        unescape: new RegExp("(" + x.keys(F.unescape).join("|") + ")", "g")
    };
    x.each([ "escape", "unescape" ], function(a) {
        x[a] = function(b) {
            return null == b ? "" : ("" + b).replace(G[a], function(b) {
                return F[a][b];
            });
        };
    }), x.result = function(a, b) {
        if (null == a) return null;
        var c = a[b];
        return x.isFunction(c) ? c.call(a) : c;
    }, x.mixin = function(a) {
        y(x.functions(a), function(b) {
            var c = x[b] = a[b];
            x.prototype[b] = function() {
                var a = [ this._wrapped ];
                return g.apply(a, arguments), L.call(this, c.apply(x, a));
            };
        });
    };
    var H = 0;
    x.uniqueId = function(a) {
        var b = ++H + "";
        return a ? a + b : b;
    }, x.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var I = /(.)^/, J = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\t": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, K = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    x.template = function(a, b, c) {
        var d;
        c = x.defaults({}, c, x.templateSettings);
        var e = new RegExp([ (c.escape || I).source, (c.interpolate || I).source, (c.evaluate || I).source ].join("|") + "|$", "g"), f = 0, g = "__p+='";
        a.replace(e, function(b, c, d, e, h) {
            return g += a.slice(f, h).replace(K, function(a) {
                return "\\" + J[a];
            }), c && (g += "'+\n((__t=(" + c + "))==null?'':_.escape(__t))+\n'"), d && (g += "'+\n((__t=(" + d + "))==null?'':__t)+\n'"), 
            e && (g += "';\n" + e + "\n__p+='"), f = h + b.length, b;
        }), g += "';\n", c.variable || (g = "with(obj||{}){\n" + g + "}\n"), g = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + g + "return __p;\n";
        try {
            d = new Function(c.variable || "obj", "_", g);
        } catch (h) {
            throw h.source = g, h;
        }
        if (b) return d(b, x);
        var i = function(a) {
            return d.call(this, a, x);
        };
        return i.source = "function(" + (c.variable || "obj") + "){\n" + g + "}", i;
    }, x.chain = function(a) {
        return x(a).chain();
    };
    var L = function(a) {
        return this._chain ? x(a).chain() : a;
    };
    x.mixin(x), y([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(a) {
        var b = d[a];
        x.prototype[a] = function() {
            var c = this._wrapped;
            return b.apply(c, arguments), "shift" != a && "splice" != a || 0 !== c.length || delete c[0], 
            L.call(this, c);
        };
    }), y([ "concat", "join", "slice" ], function(a) {
        var b = d[a];
        x.prototype[a] = function() {
            return L.call(this, b.apply(this._wrapped, arguments));
        };
    }), x.extend(x.prototype, {
        chain: function() {
            return this._chain = !0, this;
        },
        value: function() {
            return this._wrapped;
        }
    });
}.call(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = "function" == typeof require ? require : null;
    "undefined" != typeof XMLHttpRequest ? b.XMLHttpRequest = XMLHttpRequest : "function" == typeof require && "undefined" == typeof require.ensure && (b.XMLHttpRequest = c("xmlhttprequest").XMLHttpRequest), 
    "undefined" != typeof exports && exports._ ? (b._ = exports._.noConflict(), exports.Parse = b) : b._ = _.noConflict(), 
    "undefined" != typeof $ && (b.$ = $);
    var d = function() {}, e = function(a, c, e) {
        var f;
        return f = c && c.hasOwnProperty("constructor") ? c.constructor : function() {
            a.apply(this, arguments);
        }, b._.extend(f, a), d.prototype = a.prototype, f.prototype = new d(), c && b._.extend(f.prototype, c), 
        e && b._.extend(f, e), f.prototype.constructor = f, f.__super__ = a.prototype, f;
    };
    b.serverURL = "https://api.parse.com", "undefined" != typeof process && process.versions && process.versions.node && (b._isNode = !0), 
    b.initialize = function(a, c, d) {
        if (d) throw "Parse.initialize() was passed a Master Key, which is only allowed from within Node.js.";
        b._initialize(a, c);
    }, b._initialize = function(a, c, d) {
        b.applicationId = a, b.javaScriptKey = c, b.masterKey = d, b._useMasterKey = !1;
    }, b._isNode && (b.initialize = b._initialize, b.Cloud = b.Cloud || {}, b.Cloud.useMasterKey = function() {
        b._useMasterKey = !0;
    }), b._getParsePath = function(a) {
        if (!b.applicationId) throw "You need to call Parse.initialize before using Parse.";
        if (a || (a = ""), !b._.isString(a)) throw "Tried to get a Storage path that wasn't a String.";
        return "/" === a[0] && (a = a.substring(1)), "Parse/" + b.applicationId + "/" + a;
    }, b._installationId = null, b._getInstallationId = function() {
        if (b._installationId) return b.Promise.as(b._installationId);
        var a = b._getParsePath("installationId");
        return b.Storage.getItemAsync(a).then(function(c) {
            if (b._installationId = c, !b._installationId || "" === b._installationId) {
                var d = function() {
                    return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                };
                return b._installationId = d() + d() + "-" + d() + "-" + d() + "-" + d() + "-" + d() + d() + d(), 
                b.Storage.setItemAsync(a, b._installationId);
            }
            return b.Promise.as(b._installationId);
        });
    }, b._parseDate = function(a) {
        var b = new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$"), c = b.exec(a);
        if (!c) return null;
        var d = c[1] || 0, e = (c[2] || 1) - 1, f = c[3] || 0, g = c[4] || 0, h = c[5] || 0, i = c[6] || 0, j = c[8] || 0;
        return new Date(Date.UTC(d, e, f, g, h, i, j));
    }, b._ajaxIE8 = function(a, c, d) {
        var e = new b.Promise(), f = new XDomainRequest();
        return f.onload = function() {
            var a;
            try {
                a = JSON.parse(f.responseText);
            } catch (b) {
                e.reject(b);
            }
            a && e.resolve(a);
        }, f.onerror = f.ontimeout = function() {
            var a = {
                responseText: JSON.stringify({
                    code: b.Error.X_DOMAIN_REQUEST,
                    error: "IE's XDomainRequest does not supply error info."
                })
            };
            e.reject(a);
        }, f.onprogress = function() {}, f.open(a, c), f.send(d), e;
    }, b._useXDomainRequest = function() {
        return "undefined" != typeof XDomainRequest ? "withCredentials" in new XMLHttpRequest() ? !1 : !0 : !1;
    }, b._ajax = function(a, c, d, e, f) {
        var g = {
            success: e,
            error: f
        };
        if (b._useXDomainRequest()) return b._ajaxIE8(a, c, d)._thenRunCallbacks(g);
        var h = new b.Promise(), i = 0, j = function() {
            var e = !1, f = new b.XMLHttpRequest();
            f.onreadystatechange = function() {
                if (4 === f.readyState) {
                    if (e) return;
                    if (e = !0, f.status >= 200 && f.status < 300) {
                        var a;
                        try {
                            a = JSON.parse(f.responseText);
                        } catch (b) {
                            h.reject(b);
                        }
                        a && h.resolve(a, f.status, f);
                    } else if (f.status >= 500) if (++i < 5) {
                        var c = Math.round(125 * Math.random() * Math.pow(2, i));
                        setTimeout(j, c);
                    } else h.reject(f); else h.reject(f);
                }
            }, f.open(a, c, !0), f.setRequestHeader("Content-Type", "text/plain"), b._isNode && f.setRequestHeader("User-Agent", "Parse/" + b.VERSION + " (NodeJS " + process.versions.node + ")"), 
            f.send(d);
        };
        return j(), h._thenRunCallbacks(g);
    }, b._extend = function(a, b) {
        var c = e(this, a, b);
        return c.extend = this.extend, c;
    }, b._request = function(a) {
        var c = a.route, d = a.className, e = a.objectId, f = a.method, g = a.useMasterKey, h = a.sessionToken, i = a.data;
        if (!b.applicationId) throw "You must specify your applicationId using Parse.initialize.";
        if (!b.javaScriptKey && !b.masterKey) throw "You must specify a key using Parse.initialize.";
        if ("batch" !== c && "classes" !== c && "events" !== c && "files" !== c && "functions" !== c && "login" !== c && "logout" !== c && "push" !== c && "requestPasswordReset" !== c && "rest_verify_analytics" !== c && "users" !== c && "jobs" !== c && "config" !== c && "sessions" !== c && "upgradeToRevocableSession" !== c) throw "Bad route: '" + c + "'.";
        var j = b.serverURL;
        return "/" !== j.charAt(j.length - 1) && (j += "/"), j += "1/" + c, d && (j += "/" + d), 
        e && (j += "/" + e), i = b._.clone(i || {}), "POST" !== f && (i._method = f, f = "POST"), 
        b._.isUndefined(g) && (g = b._useMasterKey), i._ApplicationId = b.applicationId, 
        g ? i._MasterKey = b.masterKey : i._JavaScriptKey = b.javaScriptKey, i._ClientVersion = b.VERSION, 
        b._getInstallationId().then(function(a) {
            return i._InstallationId = a, h ? b.Promise.as({
                _sessionToken: h
            }) : b.User._currentAsync();
        }).then(function(a) {
            a && a._sessionToken && (i._SessionToken = a._sessionToken), b.User._isRevocableSessionEnabled && (i._RevocableSession = "1");
            var c = JSON.stringify(i);
            return b._ajax(f, j, c);
        }).then(null, function(a) {
            var c;
            if (a && a.responseText) try {
                var d = JSON.parse(a.responseText);
                c = new b.Error(d.code, d.error);
            } catch (e) {
                c = new b.Error(b.Error.INVALID_JSON, "Received an error with invalid JSON from Parse: " + a.responseText);
            } else c = new b.Error(b.Error.CONNECTION_FAILED, "XMLHttpRequest failed: " + JSON.stringify(a));
            return b.Promise.error(c);
        });
    }, b._getValue = function(a, c) {
        return a && a[c] ? b._.isFunction(a[c]) ? a[c]() : a[c] : null;
    }, b._encode = function(a, c, d) {
        var e = b._;
        if (a instanceof b.Object) {
            if (d) throw "Parse.Objects not allowed here";
            if (!c || e.include(c, a) || !a._hasData) return a._toPointer();
            if (!a.dirty()) return c = c.concat(a), b._encode(a._toFullJSON(c), c, d);
            throw "Tried to save an object with a pointer to a new, unsaved object.";
        }
        if (a instanceof b.ACL) return a.toJSON();
        if (e.isDate(a)) return {
            __type: "Date",
            iso: a.toJSON()
        };
        if (a instanceof b.GeoPoint) return a.toJSON();
        if (e.isArray(a)) return e.map(a, function(a) {
            return b._encode(a, c, d);
        });
        if (e.isRegExp(a)) return a.source;
        if (a instanceof b.Relation) return a.toJSON();
        if (a instanceof b.Op) return a.toJSON();
        if (a instanceof b.File) {
            if (!a.url()) throw "Tried to save an object containing an unsaved file.";
            return {
                __type: "File",
                name: a.name(),
                url: a.url()
            };
        }
        if (e.isObject(a)) {
            var f = {};
            return b._objectEach(a, function(a, e) {
                f[e] = b._encode(a, c, d);
            }), f;
        }
        return a;
    }, b._decode = function(a, c) {
        var d = b._;
        if (!d.isObject(c)) return c;
        if (d.isArray(c)) return b._arrayEach(c, function(a, d) {
            c[d] = b._decode(d, a);
        }), c;
        if (c instanceof b.Object) return c;
        if (c instanceof b.File) return c;
        if (c instanceof b.Op) return c;
        if (c.__op) return b.Op._decode(c);
        if ("Pointer" === c.__type && c.className) {
            var e = b.Object._create(c.className);
            return e._finishFetch({
                objectId: c.objectId
            }, !1), e;
        }
        if ("Object" === c.__type && c.className) {
            var f = c.className;
            delete c.__type, delete c.className;
            var g = b.Object._create(f);
            return g._finishFetch(c, !0), g;
        }
        if ("Date" === c.__type) return b._parseDate(c.iso);
        if ("GeoPoint" === c.__type) return new b.GeoPoint({
            latitude: c.latitude,
            longitude: c.longitude
        });
        if ("ACL" === a) return c instanceof b.ACL ? c : new b.ACL(c);
        if ("Relation" === c.__type) {
            var h = new b.Relation(null, a);
            return h.targetClassName = c.className, h;
        }
        if ("File" === c.__type) {
            var i = new b.File(c.name);
            return i._url = c.url, i;
        }
        return b._objectEach(c, function(a, d) {
            c[d] = b._decode(d, a);
        }), c;
    }, b._arrayEach = b._.each, b._traverse = function(a, c, d) {
        if (a instanceof b.Object) {
            if (d = d || [], b._.indexOf(d, a) >= 0) return;
            return d.push(a), b._traverse(a.attributes, c, d), c(a);
        }
        return a instanceof b.Relation || a instanceof b.File ? c(a) : b._.isArray(a) ? (b._.each(a, function(e, f) {
            var g = b._traverse(e, c, d);
            g && (a[f] = g);
        }), c(a)) : b._.isObject(a) ? (b._each(a, function(e, f) {
            var g = b._traverse(e, c, d);
            g && (a[f] = g);
        }), c(a)) : c(a);
    }, b._objectEach = b._each = function(a, c) {
        var d = b._;
        d.isObject(a) ? d.each(d.keys(a), function(b) {
            c(a[b], b);
        }) : d.each(a, c);
    }, b._isNullOrUndefined = function(a) {
        return b._.isNull(a) || b._.isUndefined(a);
    };
}(this), function(root) {
    root.Parse = root.Parse || {};
    var Parse = root.Parse, Storage = {
        async: !1
    }, hasLocalStorage = "undefined" != typeof localStorage;
    if (hasLocalStorage) try {
        localStorage.setItem("supported", !0), localStorage.removeItem("supported");
    } catch (e) {
        hasLocalStorage = !1;
    }
    if (hasLocalStorage) Storage.getItem = function(a) {
        return localStorage.getItem(a);
    }, Storage.setItem = function(a, b) {
        return localStorage.setItem(a, b);
    }, Storage.removeItem = function(a) {
        return localStorage.removeItem(a);
    }, Storage.clear = function() {
        return localStorage.clear();
    }; else if ("function" == typeof require) {
        var AsyncStorage;
        try {
            AsyncStorage = eval("require('AsyncStorage')"), Storage.async = !0, Storage.getItemAsync = function(a) {
                var b = new Parse.Promise();
                return AsyncStorage.getItem(a, function(a, c) {
                    a ? b.reject(a) : b.resolve(c);
                }), b;
            }, Storage.setItemAsync = function(a, b) {
                var c = new Parse.Promise();
                return AsyncStorage.setItem(a, b, function(a) {
                    a ? c.reject(a) : c.resolve(b);
                }), c;
            }, Storage.removeItemAsync = function(a) {
                var b = new Parse.Promise();
                return AsyncStorage.removeItem(a, function(a) {
                    a ? b.reject(a) : b.resolve();
                }), b;
            }, Storage.clear = function() {
                AsyncStorage.clear();
            };
        } catch (e) {}
    }
    if (!Storage.async && !Storage.getItem) {
        var memMap = Storage.inMemoryMap = {};
        Storage.getItem = function(a) {
            return memMap.hasOwnProperty(a) ? memMap[a] : null;
        }, Storage.setItem = function(a, b) {
            memMap[a] = String(b);
        }, Storage.removeItem = function(a) {
            delete memMap[a];
        }, Storage.clear = function() {
            for (var a in memMap) memMap.hasOwnProperty(a) && delete memMap[a];
        };
    }
    Storage.async || (Storage.getItemAsync = function(a) {
        return Parse.Promise.as(Storage.getItem(a));
    }, Storage.setItemAsync = function(a, b) {
        return Storage.setItem(a, b), Parse.Promise.as(b);
    }, Storage.removeItemAsync = function(a) {
        return Parse.Promise.as(Storage.removeItem(a));
    }), Parse.Storage = Storage;
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Analytics = b.Analytics || {}, c.extend(b.Analytics, {
        track: function(a, d, e) {
            if (a = a || "", a = a.replace(/^\s*/, ""), a = a.replace(/\s*$/, ""), 0 === a.length) throw "A name for the custom event must be provided";
            return c.each(d, function(a, b) {
                if (!c.isString(b) || !c.isString(a)) throw 'track() dimensions expects keys and values of type "string".';
            }), e = e || {}, b._request({
                route: "events",
                className: a,
                method: "POST",
                data: {
                    dimensions: d
                }
            })._thenRunCallbacks(e);
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Config = function() {
        this.attributes = {}, this._escapedAttributes = {};
    }, b.Config.current = function() {
        if (b.Config._currentConfig) return b.Config._currentConfig;
        var a = new b.Config();
        if (b.Storage.async) return a;
        var c = b.Storage.getItem(b._getParsePath(b.Config._CURRENT_CONFIG_KEY));
        return c && (a._finishFetch(JSON.parse(c)), b.Config._currentConfig = a), a;
    }, b.Config.get = function(a) {
        a = a || {};
        var c = b._request({
            route: "config",
            method: "GET"
        });
        return c.then(function(a) {
            if (!a || !a.params) {
                var c = new b.Error(b.Error.INVALID_JSON, "Config JSON response invalid.");
                return b.Promise.error(c);
            }
            var d = new b.Config();
            return d._finishFetch(a), b.Config._currentConfig = d, d;
        })._thenRunCallbacks(a);
    }, b.Config.prototype = {
        escape: function(a) {
            var d = this._escapedAttributes[a];
            if (d) return d;
            var e, f = this.attributes[a];
            return e = b._isNullOrUndefined(f) ? "" : c.escape(f.toString()), this._escapedAttributes[a] = e, 
            e;
        },
        get: function(a) {
            return this.attributes[a];
        },
        _finishFetch: function(a) {
            this.attributes = b._decode(null, c.clone(a.params)), b.Storage.async || b.Storage.setItem(b._getParsePath(b.Config._CURRENT_CONFIG_KEY), JSON.stringify(a));
        }
    }, b.Config._currentConfig = null, b.Config._CURRENT_CONFIG_KEY = "currentConfig";
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Error = function(a, b) {
        this.code = a, this.message = b;
    }, c.extend(b.Error, {
        OTHER_CAUSE: -1,
        INTERNAL_SERVER_ERROR: 1,
        CONNECTION_FAILED: 100,
        OBJECT_NOT_FOUND: 101,
        INVALID_QUERY: 102,
        INVALID_CLASS_NAME: 103,
        MISSING_OBJECT_ID: 104,
        INVALID_KEY_NAME: 105,
        INVALID_POINTER: 106,
        INVALID_JSON: 107,
        COMMAND_UNAVAILABLE: 108,
        NOT_INITIALIZED: 109,
        INCORRECT_TYPE: 111,
        INVALID_CHANNEL_NAME: 112,
        PUSH_MISCONFIGURED: 115,
        OBJECT_TOO_LARGE: 116,
        OPERATION_FORBIDDEN: 119,
        CACHE_MISS: 120,
        INVALID_NESTED_KEY: 121,
        INVALID_FILE_NAME: 122,
        INVALID_ACL: 123,
        TIMEOUT: 124,
        INVALID_EMAIL_ADDRESS: 125,
        MISSING_CONTENT_TYPE: 126,
        MISSING_CONTENT_LENGTH: 127,
        INVALID_CONTENT_LENGTH: 128,
        FILE_TOO_LARGE: 129,
        FILE_SAVE_ERROR: 130,
        DUPLICATE_VALUE: 137,
        INVALID_ROLE_NAME: 139,
        EXCEEDED_QUOTA: 140,
        SCRIPT_FAILED: 141,
        VALIDATION_ERROR: 142,
        INVALID_IMAGE_DATA: 150,
        UNSAVED_FILE_ERROR: 151,
        INVALID_PUSH_TIME_ERROR: 152,
        FILE_DELETE_ERROR: 153,
        REQUEST_LIMIT_EXCEEDED: 155,
        INVALID_EVENT_NAME: 160,
        USERNAME_MISSING: 200,
        PASSWORD_MISSING: 201,
        USERNAME_TAKEN: 202,
        EMAIL_TAKEN: 203,
        EMAIL_MISSING: 204,
        EMAIL_NOT_FOUND: 205,
        SESSION_MISSING: 206,
        MUST_CREATE_USER_THROUGH_SIGNUP: 207,
        ACCOUNT_ALREADY_LINKED: 208,
        INVALID_SESSION_TOKEN: 209,
        LINKED_ID_MISSING: 250,
        INVALID_LINKED_SESSION: 251,
        UNSUPPORTED_SERVICE: 252,
        AGGREGATE_ERROR: 600,
        FILE_READ_ERROR: 601,
        X_DOMAIN_REQUEST: 602
    });
}(this), function() {
    var a = this, b = a.Parse || (a.Parse = {}), c = /\s+/, d = Array.prototype.slice;
    b.Events = {
        on: function(a, b, d) {
            var e, f, g, h, i;
            if (!b) return this;
            for (a = a.split(c), e = this._callbacks || (this._callbacks = {}), f = a.shift(); f; ) i = e[f], 
            g = i ? i.tail : {}, g.next = h = {}, g.context = d, g.callback = b, e[f] = {
                tail: h,
                next: i ? i.next : g
            }, f = a.shift();
            return this;
        },
        off: function(a, b, d) {
            var e, f, g, h, i, j;
            if (f = this._callbacks) {
                if (!(a || b || d)) return delete this._callbacks, this;
                for (a = a ? a.split(c) : Object.keys(f), e = a.shift(); e; ) if (g = f[e], delete f[e], 
                g && (b || d)) {
                    for (h = g.tail, g = g.next; g !== h; ) i = g.callback, j = g.context, (b && i !== b || d && j !== d) && this.on(e, i, j), 
                    g = g.next;
                    e = a.shift();
                } else e = a.shift();
                return this;
            }
        },
        trigger: function(a) {
            var b, e, f, g, h, i, j;
            if (!(f = this._callbacks)) return this;
            for (i = f.all, a = a.split(c), j = d.call(arguments, 1), b = a.shift(); b; ) {
                if (e = f[b]) for (g = e.tail; (e = e.next) !== g; ) e.callback.apply(e.context || this, j);
                if (e = i) for (g = e.tail, h = [ b ].concat(j); (e = e.next) !== g; ) e.callback.apply(e.context || this, h);
                b = a.shift();
            }
            return this;
        }
    }, b.Events.bind = b.Events.on, b.Events.unbind = b.Events.off;
}.call(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.GeoPoint = function(a, d) {
        c.isArray(a) ? (b.GeoPoint._validate(a[0], a[1]), this.latitude = a[0], this.longitude = a[1]) : c.isObject(a) ? (b.GeoPoint._validate(a.latitude, a.longitude), 
        this.latitude = a.latitude, this.longitude = a.longitude) : c.isNumber(a) && c.isNumber(d) ? (b.GeoPoint._validate(a, d), 
        this.latitude = a, this.longitude = d) : (this.latitude = 0, this.longitude = 0);
        var e = this;
        this.__defineGetter__ && this.__defineSetter__ && (this._latitude = this.latitude, 
        this._longitude = this.longitude, this.__defineGetter__("latitude", function() {
            return e._latitude;
        }), this.__defineGetter__("longitude", function() {
            return e._longitude;
        }), this.__defineSetter__("latitude", function(a) {
            b.GeoPoint._validate(a, e.longitude), e._latitude = a;
        }), this.__defineSetter__("longitude", function(a) {
            b.GeoPoint._validate(e.latitude, a), e._longitude = a;
        }));
    }, b.GeoPoint._validate = function(a, b) {
        if (-90 > a) throw "Parse.GeoPoint latitude " + a + " < -90.0.";
        if (a > 90) throw "Parse.GeoPoint latitude " + a + " > 90.0.";
        if (-180 > b) throw "Parse.GeoPoint longitude " + b + " < -180.0.";
        if (b > 180) throw "Parse.GeoPoint longitude " + b + " > 180.0.";
    }, b.GeoPoint.current = function(a) {
        var c = new b.Promise();
        return navigator.geolocation.getCurrentPosition(function(a) {
            c.resolve(new b.GeoPoint({
                latitude: a.coords.latitude,
                longitude: a.coords.longitude
            }));
        }, function(a) {
            c.reject(a);
        }), c._thenRunCallbacks(a);
    }, b.GeoPoint.prototype = {
        toJSON: function() {
            return b.GeoPoint._validate(this.latitude, this.longitude), {
                __type: "GeoPoint",
                latitude: this.latitude,
                longitude: this.longitude
            };
        },
        radiansTo: function(a) {
            var b = Math.PI / 180, c = this.latitude * b, d = this.longitude * b, e = a.latitude * b, f = a.longitude * b, g = c - e, h = d - f, i = Math.sin(g / 2), j = Math.sin(h / 2), k = i * i + Math.cos(c) * Math.cos(e) * j * j;
            return k = Math.min(1, k), 2 * Math.asin(Math.sqrt(k));
        },
        kilometersTo: function(a) {
            return 6371 * this.radiansTo(a);
        },
        milesTo: function(a) {
            return 3958.8 * this.radiansTo(a);
        }
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._, d = "*";
    b.ACL = function(a) {
        var d = this;
        if (d.permissionsById = {}, c.isObject(a)) if (a instanceof b.User) d.setReadAccess(a, !0), 
        d.setWriteAccess(a, !0); else {
            if (c.isFunction(a)) throw "Parse.ACL() called with a function.  Did you forget ()?";
            b._objectEach(a, function(a, e) {
                if (!c.isString(e)) throw "Tried to create an ACL with an invalid userId.";
                d.permissionsById[e] = {}, b._objectEach(a, function(a, b) {
                    if ("read" !== b && "write" !== b) throw "Tried to create an ACL with an invalid permission type.";
                    if (!c.isBoolean(a)) throw "Tried to create an ACL with an invalid permission value.";
                    d.permissionsById[e][b] = a;
                });
            });
        }
    }, b.ACL.prototype.toJSON = function() {
        return c.clone(this.permissionsById);
    }, b.ACL.prototype._setAccess = function(a, d, e) {
        if (d instanceof b.User ? d = d.id : d instanceof b.Role && (d = "role:" + d.getName()), 
        !c.isString(d)) throw "userId must be a string.";
        if (!c.isBoolean(e)) throw "allowed must be either true or false.";
        var f = this.permissionsById[d];
        if (!f) {
            if (!e) return;
            f = {}, this.permissionsById[d] = f;
        }
        e ? this.permissionsById[d][a] = !0 : (delete f[a], c.isEmpty(f) && delete f[d]);
    }, b.ACL.prototype._getAccess = function(a, c) {
        c instanceof b.User ? c = c.id : c instanceof b.Role && (c = "role:" + c.getName());
        var d = this.permissionsById[c];
        return d && d[a] ? !0 : !1;
    }, b.ACL.prototype.setReadAccess = function(a, b) {
        this._setAccess("read", a, b);
    }, b.ACL.prototype.getReadAccess = function(a) {
        return this._getAccess("read", a);
    }, b.ACL.prototype.setWriteAccess = function(a, b) {
        this._setAccess("write", a, b);
    }, b.ACL.prototype.getWriteAccess = function(a) {
        return this._getAccess("write", a);
    }, b.ACL.prototype.setPublicReadAccess = function(a) {
        this.setReadAccess(d, a);
    }, b.ACL.prototype.getPublicReadAccess = function() {
        return this.getReadAccess(d);
    }, b.ACL.prototype.setPublicWriteAccess = function(a) {
        this.setWriteAccess(d, a);
    }, b.ACL.prototype.getPublicWriteAccess = function() {
        return this.getWriteAccess(d);
    }, b.ACL.prototype.getRoleReadAccess = function(a) {
        if (a instanceof b.Role && (a = a.getName()), c.isString(a)) return this.getReadAccess("role:" + a);
        throw "role must be a Parse.Role or a String";
    }, b.ACL.prototype.getRoleWriteAccess = function(a) {
        if (a instanceof b.Role && (a = a.getName()), c.isString(a)) return this.getWriteAccess("role:" + a);
        throw "role must be a Parse.Role or a String";
    }, b.ACL.prototype.setRoleReadAccess = function(a, d) {
        if (a instanceof b.Role && (a = a.getName()), c.isString(a)) return void this.setReadAccess("role:" + a, d);
        throw "role must be a Parse.Role or a String";
    }, b.ACL.prototype.setRoleWriteAccess = function(a, d) {
        if (a instanceof b.Role && (a = a.getName()), c.isString(a)) return void this.setWriteAccess("role:" + a, d);
        throw "role must be a Parse.Role or a String";
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Op = function() {
        this._initialize.apply(this, arguments);
    }, b.Op.prototype = {
        _initialize: function() {}
    }, c.extend(b.Op, {
        _extend: b._extend,
        _opDecoderMap: {},
        _registerDecoder: function(a, c) {
            b.Op._opDecoderMap[a] = c;
        },
        _decode: function(a) {
            var c = b.Op._opDecoderMap[a.__op];
            return c ? c(a) : void 0;
        }
    }), b.Op._registerDecoder("Batch", function(a) {
        var c = null;
        return b._arrayEach(a.ops, function(a) {
            a = b.Op._decode(a), c = a._mergeWithPrevious(c);
        }), c;
    }), b.Op.Set = b.Op._extend({
        _initialize: function(a) {
            this._value = a;
        },
        value: function() {
            return this._value;
        },
        toJSON: function() {
            return b._encode(this.value());
        },
        _mergeWithPrevious: function(a) {
            return this;
        },
        _estimate: function(a) {
            return this.value();
        }
    }), b.Op._UNSET = {}, b.Op.Unset = b.Op._extend({
        toJSON: function() {
            return {
                __op: "Delete"
            };
        },
        _mergeWithPrevious: function(a) {
            return this;
        },
        _estimate: function(a) {
            return b.Op._UNSET;
        }
    }), b.Op._registerDecoder("Delete", function(a) {
        return new b.Op.Unset();
    }), b.Op.Increment = b.Op._extend({
        _initialize: function(a) {
            this._amount = a;
        },
        amount: function() {
            return this._amount;
        },
        toJSON: function() {
            return {
                __op: "Increment",
                amount: this._amount
            };
        },
        _mergeWithPrevious: function(a) {
            if (a) {
                if (a instanceof b.Op.Unset) return new b.Op.Set(this.amount());
                if (a instanceof b.Op.Set) return new b.Op.Set(a.value() + this.amount());
                if (a instanceof b.Op.Increment) return new b.Op.Increment(this.amount() + a.amount());
                throw "Op is invalid after previous op.";
            }
            return this;
        },
        _estimate: function(a) {
            return a ? a + this.amount() : this.amount();
        }
    }), b.Op._registerDecoder("Increment", function(a) {
        return new b.Op.Increment(a.amount);
    }), b.Op.Add = b.Op._extend({
        _initialize: function(a) {
            this._objects = a;
        },
        objects: function() {
            return this._objects;
        },
        toJSON: function() {
            return {
                __op: "Add",
                objects: b._encode(this.objects())
            };
        },
        _mergeWithPrevious: function(a) {
            if (a) {
                if (a instanceof b.Op.Unset) return new b.Op.Set(this.objects());
                if (a instanceof b.Op.Set) return new b.Op.Set(this._estimate(a.value()));
                if (a instanceof b.Op.Add) return new b.Op.Add(a.objects().concat(this.objects()));
                throw "Op is invalid after previous op.";
            }
            return this;
        },
        _estimate: function(a) {
            return a ? a.concat(this.objects()) : c.clone(this.objects());
        }
    }), b.Op._registerDecoder("Add", function(a) {
        return new b.Op.Add(b._decode(void 0, a.objects));
    }), b.Op.AddUnique = b.Op._extend({
        _initialize: function(a) {
            this._objects = c.uniq(a);
        },
        objects: function() {
            return this._objects;
        },
        toJSON: function() {
            return {
                __op: "AddUnique",
                objects: b._encode(this.objects())
            };
        },
        _mergeWithPrevious: function(a) {
            if (a) {
                if (a instanceof b.Op.Unset) return new b.Op.Set(this.objects());
                if (a instanceof b.Op.Set) return new b.Op.Set(this._estimate(a.value()));
                if (a instanceof b.Op.AddUnique) return new b.Op.AddUnique(this._estimate(a.objects()));
                throw "Op is invalid after previous op.";
            }
            return this;
        },
        _estimate: function(a) {
            if (a) {
                var d = c.clone(a);
                return b._arrayEach(this.objects(), function(a) {
                    if (a instanceof b.Object && a.id) {
                        var e = c.find(d, function(c) {
                            return c instanceof b.Object && c.id === a.id;
                        });
                        if (e) {
                            var f = c.indexOf(d, e);
                            d[f] = a;
                        } else d.push(a);
                    } else c.contains(d, a) || d.push(a);
                }), d;
            }
            return c.clone(this.objects());
        }
    }), b.Op._registerDecoder("AddUnique", function(a) {
        return new b.Op.AddUnique(b._decode(void 0, a.objects));
    }), b.Op.Remove = b.Op._extend({
        _initialize: function(a) {
            this._objects = c.uniq(a);
        },
        objects: function() {
            return this._objects;
        },
        toJSON: function() {
            return {
                __op: "Remove",
                objects: b._encode(this.objects())
            };
        },
        _mergeWithPrevious: function(a) {
            if (a) {
                if (a instanceof b.Op.Unset) return a;
                if (a instanceof b.Op.Set) return new b.Op.Set(this._estimate(a.value()));
                if (a instanceof b.Op.Remove) return new b.Op.Remove(c.union(a.objects(), this.objects()));
                throw "Op is invalid after previous op.";
            }
            return this;
        },
        _estimate: function(a) {
            if (a) {
                var d = c.difference(a, this.objects());
                return b._arrayEach(this.objects(), function(a) {
                    a instanceof b.Object && a.id && (d = c.reject(d, function(c) {
                        return c instanceof b.Object && c.id === a.id;
                    }));
                }), d;
            }
            return [];
        }
    }), b.Op._registerDecoder("Remove", function(a) {
        return new b.Op.Remove(b._decode(void 0, a.objects));
    }), b.Op.Relation = b.Op._extend({
        _initialize: function(a, d) {
            this._targetClassName = null;
            var e = this, f = function(a) {
                if (a instanceof b.Object) {
                    if (!a.id) throw "You can't add an unsaved Parse.Object to a relation.";
                    if (e._targetClassName || (e._targetClassName = a.className), e._targetClassName !== a.className) throw "Tried to create a Parse.Relation with 2 different types: " + e._targetClassName + " and " + a.className + ".";
                    return a.id;
                }
                return a;
            };
            this.relationsToAdd = c.uniq(c.map(a, f)), this.relationsToRemove = c.uniq(c.map(d, f));
        },
        added: function() {
            var a = this;
            return c.map(this.relationsToAdd, function(c) {
                var d = b.Object._create(a._targetClassName);
                return d.id = c, d;
            });
        },
        removed: function() {
            var a = this;
            return c.map(this.relationsToRemove, function(c) {
                var d = b.Object._create(a._targetClassName);
                return d.id = c, d;
            });
        },
        toJSON: function() {
            var a = null, b = null, d = this, e = function(a) {
                return {
                    __type: "Pointer",
                    className: d._targetClassName,
                    objectId: a
                };
            }, f = null;
            return this.relationsToAdd.length > 0 && (f = c.map(this.relationsToAdd, e), a = {
                __op: "AddRelation",
                objects: f
            }), this.relationsToRemove.length > 0 && (f = c.map(this.relationsToRemove, e), 
            b = {
                __op: "RemoveRelation",
                objects: f
            }), a && b ? {
                __op: "Batch",
                ops: [ a, b ]
            } : a || b || {};
        },
        _mergeWithPrevious: function(a) {
            if (a) {
                if (a instanceof b.Op.Unset) throw "You can't modify a relation after deleting it.";
                if (a instanceof b.Op.Relation) {
                    if (a._targetClassName && a._targetClassName !== this._targetClassName) throw "Related object must be of class " + a._targetClassName + ", but " + this._targetClassName + " was passed in.";
                    var d = c.union(c.difference(a.relationsToAdd, this.relationsToRemove), this.relationsToAdd), e = c.union(c.difference(a.relationsToRemove, this.relationsToAdd), this.relationsToRemove), f = new b.Op.Relation(d, e);
                    return f._targetClassName = this._targetClassName, f;
                }
                throw "Op is invalid after previous op.";
            }
            return this;
        },
        _estimate: function(a, c, d) {
            if (a) {
                if (a instanceof b.Relation) {
                    if (this._targetClassName) if (a.targetClassName) {
                        if (a.targetClassName !== this._targetClassName) throw "Related object must be a " + a.targetClassName + ", but a " + this._targetClassName + " was passed in.";
                    } else a.targetClassName = this._targetClassName;
                    return a;
                }
                throw "Op is invalid after previous op.";
            }
            var e = new b.Relation(c, d);
            e.targetClassName = this._targetClassName;
        }
    }), b.Op._registerDecoder("AddRelation", function(a) {
        return new b.Op.Relation(b._decode(void 0, a.objects), []);
    }), b.Op._registerDecoder("RemoveRelation", function(a) {
        return new b.Op.Relation([], b._decode(void 0, a.objects));
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Relation = function(a, b) {
        this.parent = a, this.key = b, this.targetClassName = null;
    }, b.Relation.prototype = {
        _ensureParentAndKey: function(a, b) {
            if (this.parent = this.parent || a, this.key = this.key || b, this.parent !== a) throw "Internal Error. Relation retrieved from two different Objects.";
            if (this.key !== b) throw "Internal Error. Relation retrieved from two different keys.";
        },
        add: function(a) {
            c.isArray(a) || (a = [ a ]);
            var d = new b.Op.Relation(a, []);
            this.parent.set(this.key, d), this.targetClassName = d._targetClassName;
        },
        remove: function(a) {
            c.isArray(a) || (a = [ a ]);
            var d = new b.Op.Relation([], a);
            this.parent.set(this.key, d), this.targetClassName = d._targetClassName;
        },
        toJSON: function() {
            return {
                __type: "Relation",
                className: this.targetClassName
            };
        },
        query: function() {
            var a, c;
            return this.targetClassName ? (a = b.Object._getSubclass(this.targetClassName), 
            c = new b.Query(a)) : (a = b.Object._getSubclass(this.parent.className), c = new b.Query(a), 
            c._extraOptions.redirectClassNameForKey = this.key), c._addCondition("$relatedTo", "object", this.parent._toPointer()), 
            c._addCondition("$relatedTo", "key", this.key), c;
        }
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Promise = function() {
        this._resolved = !1, this._rejected = !1, this._resolvedCallbacks = [], this._rejectedCallbacks = [];
    }, c.extend(b.Promise, {
        _isPromisesAPlusCompliant: !1,
        is: function(a) {
            return a && a.then && c.isFunction(a.then);
        },
        as: function() {
            var a = new b.Promise();
            return a.resolve.apply(a, arguments), a;
        },
        error: function() {
            var a = new b.Promise();
            return a.reject.apply(a, arguments), a;
        },
        when: function(a) {
            var c;
            c = a && b._isNullOrUndefined(a.length) ? arguments : a;
            var d = c.length, e = !1, f = [], g = [];
            if (f.length = c.length, g.length = c.length, 0 === d) return b.Promise.as.apply(this, f);
            var h = new b.Promise(), i = function() {
                d -= 1, 0 === d && (e ? h.reject(g) : h.resolve.apply(h, f));
            };
            return b._arrayEach(c, function(a, c) {
                b.Promise.is(a) ? a.then(function(a) {
                    f[c] = a, i();
                }, function(a) {
                    g[c] = a, e = !0, i();
                }) : (f[c] = a, i());
            }), h;
        },
        _continueWhile: function(a, c) {
            return a() ? c().then(function() {
                return b.Promise._continueWhile(a, c);
            }) : b.Promise.as();
        }
    }), c.extend(b.Promise.prototype, {
        resolve: function(a) {
            if (this._resolved || this._rejected) throw "A promise was resolved even though it had already been " + (this._resolved ? "resolved" : "rejected") + ".";
            this._resolved = !0, this._result = arguments;
            var c = arguments;
            b._arrayEach(this._resolvedCallbacks, function(a) {
                a.apply(this, c);
            }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
        },
        reject: function(a) {
            if (this._resolved || this._rejected) throw "A promise was rejected even though it had already been " + (this._resolved ? "resolved" : "rejected") + ".";
            this._rejected = !0, this._error = a, b._arrayEach(this._rejectedCallbacks, function(b) {
                b(a);
            }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
        },
        then: function(a, c) {
            var d = new b.Promise(), e = function() {
                var c = arguments;
                if (a) if (b.Promise._isPromisesAPlusCompliant) try {
                    c = [ a.apply(this, c) ];
                } catch (e) {
                    c = [ b.Promise.error(e) ];
                } else c = [ a.apply(this, c) ];
                1 === c.length && b.Promise.is(c[0]) ? c[0].then(function() {
                    d.resolve.apply(d, arguments);
                }, function(a) {
                    d.reject(a);
                }) : d.resolve.apply(d, c);
            }, f = function(a) {
                var e = [];
                if (c) {
                    if (b.Promise._isPromisesAPlusCompliant) try {
                        e = [ c(a) ];
                    } catch (f) {
                        e = [ b.Promise.error(f) ];
                    } else e = [ c(a) ];
                    1 === e.length && b.Promise.is(e[0]) ? e[0].then(function() {
                        d.resolve.apply(d, arguments);
                    }, function(a) {
                        d.reject(a);
                    }) : b.Promise._isPromisesAPlusCompliant ? d.resolve.apply(d, e) : d.reject(e[0]);
                } else d.reject(a);
            }, g = function(a) {
                a.call();
            };
            b.Promise._isPromisesAPlusCompliant && ("undefined" != typeof window && window.setTimeout ? g = function(a) {
                window.setTimeout(a, 0);
            } : "undefined" != typeof process && process.nextTick && (g = function(a) {
                process.nextTick(a);
            }));
            var h = this;
            return this._resolved ? g(function() {
                e.apply(h, h._result);
            }) : this._rejected ? g(function() {
                f(h._error);
            }) : (this._resolvedCallbacks.push(e), this._rejectedCallbacks.push(f)), d;
        },
        always: function(a) {
            return this.then(a, a);
        },
        done: function(a) {
            return this.then(a);
        },
        fail: function(a) {
            return this.then(null, a);
        },
        _thenRunCallbacks: function(a, d) {
            var e;
            if (c.isFunction(a)) {
                var f = a;
                e = {
                    success: function(a) {
                        f(a, null);
                    },
                    error: function(a) {
                        f(null, a);
                    }
                };
            } else e = c.clone(a);
            return e = e || {}, this.then(function(a) {
                return e.success ? e.success.apply(this, arguments) : d && d.trigger("sync", d, a, e), 
                b.Promise.as.apply(b.Promise, arguments);
            }, function(a) {
                return e.error ? c.isUndefined(d) ? e.error(a) : e.error(d, a) : d && d.trigger("error", d, a, e), 
                b.Promise.error(a);
            });
        },
        _continueWith: function(a) {
            return this.then(function() {
                return a(arguments, null);
            }, function(b) {
                return a(null, b);
            });
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._, d = function(a) {
        if (26 > a) return String.fromCharCode(65 + a);
        if (52 > a) return String.fromCharCode(97 + (a - 26));
        if (62 > a) return String.fromCharCode(48 + (a - 52));
        if (62 === a) return "+";
        if (63 === a) return "/";
        throw "Tried to encode large digit " + a + " in base64.";
    }, e = function(a) {
        var b = [];
        return b.length = Math.ceil(a.length / 3), c.times(b.length, function(c) {
            var e = a[3 * c], f = a[3 * c + 1] || 0, g = a[3 * c + 2] || 0, h = 3 * c + 1 < a.length, i = 3 * c + 2 < a.length;
            b[c] = [ d(e >> 2 & 63), d(e << 4 & 48 | f >> 4 & 15), h ? d(f << 2 & 60 | g >> 6 & 3) : "=", i ? d(63 & g) : "=" ].join("");
        }), b.join("");
    }, f = {
        ai: "application/postscript",
        aif: "audio/x-aiff",
        aifc: "audio/x-aiff",
        aiff: "audio/x-aiff",
        asc: "text/plain",
        atom: "application/atom+xml",
        au: "audio/basic",
        avi: "video/x-msvideo",
        bcpio: "application/x-bcpio",
        bin: "application/octet-stream",
        bmp: "image/bmp",
        cdf: "application/x-netcdf",
        cgm: "image/cgm",
        "class": "application/octet-stream",
        cpio: "application/x-cpio",
        cpt: "application/mac-compactpro",
        csh: "application/x-csh",
        css: "text/css",
        dcr: "application/x-director",
        dif: "video/x-dv",
        dir: "application/x-director",
        djv: "image/vnd.djvu",
        djvu: "image/vnd.djvu",
        dll: "application/octet-stream",
        dmg: "application/octet-stream",
        dms: "application/octet-stream",
        doc: "application/msword",
        docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        docm: "application/vnd.ms-word.document.macroEnabled.12",
        dotm: "application/vnd.ms-word.template.macroEnabled.12",
        dtd: "application/xml-dtd",
        dv: "video/x-dv",
        dvi: "application/x-dvi",
        dxr: "application/x-director",
        eps: "application/postscript",
        etx: "text/x-setext",
        exe: "application/octet-stream",
        ez: "application/andrew-inset",
        gif: "image/gif",
        gram: "application/srgs",
        grxml: "application/srgs+xml",
        gtar: "application/x-gtar",
        hdf: "application/x-hdf",
        hqx: "application/mac-binhex40",
        htm: "text/html",
        html: "text/html",
        ice: "x-conference/x-cooltalk",
        ico: "image/x-icon",
        ics: "text/calendar",
        ief: "image/ief",
        ifb: "text/calendar",
        iges: "model/iges",
        igs: "model/iges",
        jnlp: "application/x-java-jnlp-file",
        jp2: "image/jp2",
        jpe: "image/jpeg",
        jpeg: "image/jpeg",
        jpg: "image/jpeg",
        js: "application/x-javascript",
        kar: "audio/midi",
        latex: "application/x-latex",
        lha: "application/octet-stream",
        lzh: "application/octet-stream",
        m3u: "audio/x-mpegurl",
        m4a: "audio/mp4a-latm",
        m4b: "audio/mp4a-latm",
        m4p: "audio/mp4a-latm",
        m4u: "video/vnd.mpegurl",
        m4v: "video/x-m4v",
        mac: "image/x-macpaint",
        man: "application/x-troff-man",
        mathml: "application/mathml+xml",
        me: "application/x-troff-me",
        mesh: "model/mesh",
        mid: "audio/midi",
        midi: "audio/midi",
        mif: "application/vnd.mif",
        mov: "video/quicktime",
        movie: "video/x-sgi-movie",
        mp2: "audio/mpeg",
        mp3: "audio/mpeg",
        mp4: "video/mp4",
        mpe: "video/mpeg",
        mpeg: "video/mpeg",
        mpg: "video/mpeg",
        mpga: "audio/mpeg",
        ms: "application/x-troff-ms",
        msh: "model/mesh",
        mxu: "video/vnd.mpegurl",
        nc: "application/x-netcdf",
        oda: "application/oda",
        ogg: "application/ogg",
        pbm: "image/x-portable-bitmap",
        pct: "image/pict",
        pdb: "chemical/x-pdb",
        pdf: "application/pdf",
        pgm: "image/x-portable-graymap",
        pgn: "application/x-chess-pgn",
        pic: "image/pict",
        pict: "image/pict",
        png: "image/png",
        pnm: "image/x-portable-anymap",
        pnt: "image/x-macpaint",
        pntg: "image/x-macpaint",
        ppm: "image/x-portable-pixmap",
        ppt: "application/vnd.ms-powerpoint",
        pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        potx: "application/vnd.openxmlformats-officedocument.presentationml.template",
        ppsx: "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        ppam: "application/vnd.ms-powerpoint.addin.macroEnabled.12",
        pptm: "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
        potm: "application/vnd.ms-powerpoint.template.macroEnabled.12",
        ppsm: "application/vnd.ms-powerpoint.slideshow.macroEnabled.12",
        ps: "application/postscript",
        qt: "video/quicktime",
        qti: "image/x-quicktime",
        qtif: "image/x-quicktime",
        ra: "audio/x-pn-realaudio",
        ram: "audio/x-pn-realaudio",
        ras: "image/x-cmu-raster",
        rdf: "application/rdf+xml",
        rgb: "image/x-rgb",
        rm: "application/vnd.rn-realmedia",
        roff: "application/x-troff",
        rtf: "text/rtf",
        rtx: "text/richtext",
        sgm: "text/sgml",
        sgml: "text/sgml",
        sh: "application/x-sh",
        shar: "application/x-shar",
        silo: "model/mesh",
        sit: "application/x-stuffit",
        skd: "application/x-koan",
        skm: "application/x-koan",
        skp: "application/x-koan",
        skt: "application/x-koan",
        smi: "application/smil",
        smil: "application/smil",
        snd: "audio/basic",
        so: "application/octet-stream",
        spl: "application/x-futuresplash",
        src: "application/x-wais-source",
        sv4cpio: "application/x-sv4cpio",
        sv4crc: "application/x-sv4crc",
        svg: "image/svg+xml",
        swf: "application/x-shockwave-flash",
        t: "application/x-troff",
        tar: "application/x-tar",
        tcl: "application/x-tcl",
        tex: "application/x-tex",
        texi: "application/x-texinfo",
        texinfo: "application/x-texinfo",
        tif: "image/tiff",
        tiff: "image/tiff",
        tr: "application/x-troff",
        tsv: "text/tab-separated-values",
        txt: "text/plain",
        ustar: "application/x-ustar",
        vcd: "application/x-cdlink",
        vrml: "model/vrml",
        vxml: "application/voicexml+xml",
        wav: "audio/x-wav",
        wbmp: "image/vnd.wap.wbmp",
        wbmxl: "application/vnd.wap.wbxml",
        wml: "text/vnd.wap.wml",
        wmlc: "application/vnd.wap.wmlc",
        wmls: "text/vnd.wap.wmlscript",
        wmlsc: "application/vnd.wap.wmlscriptc",
        wrl: "model/vrml",
        xbm: "image/x-xbitmap",
        xht: "application/xhtml+xml",
        xhtml: "application/xhtml+xml",
        xls: "application/vnd.ms-excel",
        xml: "application/xml",
        xpm: "image/x-xpixmap",
        xsl: "application/xml",
        xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        xlsm: "application/vnd.ms-excel.sheet.macroEnabled.12",
        xltm: "application/vnd.ms-excel.template.macroEnabled.12",
        xlam: "application/vnd.ms-excel.addin.macroEnabled.12",
        xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
        xslt: "application/xslt+xml",
        xul: "application/vnd.mozilla.xul+xml",
        xwd: "image/x-xwindowdump",
        xyz: "chemical/x-xyz",
        zip: "application/zip"
    }, g = function(a, c) {
        var d = new b.Promise();
        if ("undefined" == typeof FileReader) return b.Promise.error(new b.Error(b.Error.FILE_READ_ERROR, "Attempted to use a FileReader on an unsupported browser."));
        var e = new FileReader();
        return e.onloadend = function() {
            if (2 !== e.readyState) return void d.reject(new b.Error(b.Error.FILE_READ_ERROR, "Error reading file."));
            var a = e.result, f = /^data:([^;]*);base64,(.*)$/.exec(a);
            return f ? void d.resolve(f[2], c || f[1]) : void d.reject(new b.Error(b.Error.FILE_READ_ERROR, "Unable to interpret data URL: " + a));
        }, e.readAsDataURL(a), d;
    };
    b.File = function(a, d, h) {
        this._name = a;
        var i = /\.([^.]*)$/.exec(a);
        i && (i = i[1].toLowerCase());
        var j = h || f[i] || "text/plain";
        if (c.isArray(d)) this._source = b.Promise.as(e(d), j); else if (d && d.base64) {
            var k = /^data:([a-zA-Z]*\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\-\/\s]*,)?base64,(\S+)/, l = k.exec(d.base64);
            this._source = l && l.length > 0 ? b.Promise.as(4 === l.length ? l[3] : l[2], l[1]) : b.Promise.as(d.base64, j);
        } else if ("undefined" != typeof File && d instanceof File) this._source = g(d, h); else if (c.isString(d)) throw "Creating a Parse.File from a String is not yet supported.";
    }, b.File.prototype = {
        name: function() {
            return this._name;
        },
        url: function() {
            return this._url;
        },
        save: function(a) {
            a = a || {};
            var c = this;
            return c._previousSave || (c._previousSave = c._source.then(function(d, e) {
                var f = {
                    base64: d,
                    _ContentType: e
                };
                return b._request({
                    route: "files",
                    className: c._name,
                    method: "POST",
                    data: f,
                    useMasterKey: a.useMasterKey
                });
            }).then(function(a) {
                return c._name = a.name, c._url = a.url, c;
            })), c._previousSave._thenRunCallbacks(a);
        }
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Object = function(a, d) {
        if (c.isString(a)) return b.Object._create.apply(this, arguments);
        a = a || {}, d && d.parse && (a = this.parse(a));
        var e = b._getValue(this, "defaults");
        if (e && (a = c.extend({}, e, a)), d && d.collection && (this.collection = d.collection), 
        this._serverData = {}, this._opSetQueue = [ {} ], this.attributes = {}, this._hashedJSON = {}, 
        this._escapedAttributes = {}, this.cid = c.uniqueId("c"), this.changed = {}, this._silent = {}, 
        this._pending = {}, !this.set(a, {
            silent: !0
        })) throw new Error("Can't create an invalid Parse.Object");
        this.changed = {}, this._silent = {}, this._pending = {}, this._hasData = !0, this._previousAttributes = c.clone(this.attributes), 
        this.initialize.apply(this, arguments);
    }, b.Object.saveAll = function(a, c) {
        return c = c || {}, b.Object._deepSaveAsync(a, {
            useMasterKey: c.useMasterKey
        })._thenRunCallbacks(c);
    }, b.Object.destroyAll = function(a, d) {
        d = d || {};
        var e = function(a) {
            a.trigger("destroy", a, a.collection, d);
        }, f = [], g = function(a) {
            var g = b.Promise.as();
            return a.length > 0 && (g = g.then(function() {
                return b._request({
                    route: "batch",
                    method: "POST",
                    useMasterKey: d.useMasterKey,
                    data: {
                        requests: c.map(a, function(a) {
                            return {
                                method: "DELETE",
                                path: "/1/classes/" + a.className + "/" + a.id
                            };
                        })
                    }
                });
            }).then(function(c, g, h) {
                b._arrayEach(a, function(a, g) {
                    if (c[g].success && d.wait) e(a); else if (c[g].error) {
                        var h = new b.Error(c[g].error.code, c[g].error.error);
                        h.object = a, f.push(h);
                    }
                });
            })), g;
        }, h = b.Promise.as(), i = [];
        return b._arrayEach(a, function(b, c) {
            if (b.id && d.wait || e(b), b.id && i.push(b), 20 === i.length || c + 1 === a.length) {
                var f = i;
                i = [], h = h.then(function() {
                    return g(f);
                });
            }
        }), h.then(function() {
            if (0 === f.length) return !0;
            var a = new b.Error(b.Error.AGGREGATE_ERROR, "Error deleting an object in destroyAll");
            return a.errors = f, b.Promise.error(a);
        })._thenRunCallbacks(d);
    }, b.Object.fetchAll = function(a, c) {
        return b.Object._fetchAll(a, !0)._thenRunCallbacks(c);
    }, b.Object.fetchAllIfNeeded = function(a, c) {
        return b.Object._fetchAll(a, !1)._thenRunCallbacks(c);
    }, c.extend(b.Object.prototype, b.Events, {
        _existed: !1,
        initialize: function() {},
        toJSON: function() {
            var a = this._toFullJSON();
            return b._arrayEach([ "__type", "className" ], function(b) {
                delete a[b];
            }), a;
        },
        _toFullJSON: function(a) {
            var d = c.clone(this.attributes);
            return b._objectEach(d, function(c, e) {
                d[e] = b._encode(c, a);
            }), b._objectEach(this._operations, function(a, b) {
                d[b] = a;
            }), c.has(this, "id") && (d.objectId = this.id), c.has(this, "createdAt") && (d.createdAt = c.isDate(this.createdAt) ? this.createdAt.toJSON() : this.createdAt), 
            c.has(this, "updatedAt") && (d.updatedAt = c.isDate(this.updatedAt) ? this.updatedAt.toJSON() : this.updatedAt), 
            d.__type = "Object", d.className = this.className, d;
        },
        _refreshCache: function() {
            var a = this;
            a._refreshingCache || (a._refreshingCache = !0, b._objectEach(this.attributes, function(d, e) {
                if (d instanceof b.Object) d._refreshCache(); else if (c.isObject(d)) {
                    var f = !1;
                    c.isArray(d) && c.each(d, function(a) {
                        a instanceof b.Object && (f = !0, a._refreshCache());
                    }), !f && a._resetCacheForKey(e) && a.set(e, new b.Op.Set(d), {
                        silent: !0
                    });
                }
            }), delete a._refreshingCache);
        },
        dirty: function(a) {
            this._refreshCache();
            var b = c.last(this._opSetQueue);
            return a ? b[a] ? !0 : !1 : this.id ? c.keys(b).length > 0 ? !0 : !1 : !0;
        },
        dirtyKeys: function() {
            return c.keys(c.last(this._opSetQueue));
        },
        _toPointer: function() {
            if (!this.id) throw new Error("Can't serialize an unsaved Parse.Object");
            return {
                __type: "Pointer",
                className: this.className,
                objectId: this.id
            };
        },
        get: function(a) {
            return this.attributes[a];
        },
        relation: function(a) {
            var c = this.get(a);
            if (c) {
                if (!(c instanceof b.Relation)) throw "Called relation() on non-relation field " + a;
                return c._ensureParentAndKey(this, a), c;
            }
            return new b.Relation(this, a);
        },
        escape: function(a) {
            var d = this._escapedAttributes[a];
            if (d) return d;
            var e, f = this.attributes[a];
            return e = b._isNullOrUndefined(f) ? "" : c.escape(f.toString()), this._escapedAttributes[a] = e, 
            e;
        },
        has: function(a) {
            return !b._isNullOrUndefined(this.attributes[a]);
        },
        _mergeMagicFields: function(a) {
            var d = this, e = [ "id", "objectId", "createdAt", "updatedAt" ];
            b._arrayEach(e, function(e) {
                a[e] && ("objectId" === e ? d.id = a[e] : d[e] = "createdAt" !== e && "updatedAt" !== e || c.isDate(a[e]) ? a[e] : b._parseDate(a[e]), 
                delete a[e]);
            });
        },
        _copyServerData: function(a) {
            var c = {};
            b._objectEach(a, function(a, d) {
                c[d] = b._decode(d, a);
            }), this._serverData = c, this._rebuildAllEstimatedData(), this._refreshCache(), 
            this._opSetQueue = [ {} ], this._rebuildAllEstimatedData();
        },
        _mergeFromObject: function(a) {
            a && (this.id = a.id, this.createdAt = a.createdAt, this.updatedAt = a.updatedAt, 
            this._copyServerData(a._serverData), this._hasData = !0);
        },
        _startSave: function() {
            this._opSetQueue.push({});
        },
        _cancelSave: function() {
            var a = c.first(this._opSetQueue);
            this._opSetQueue = c.rest(this._opSetQueue);
            var d = c.first(this._opSetQueue);
            b._objectEach(a, function(b, c) {
                var e = a[c], f = d[c];
                e && f ? d[c] = f._mergeWithPrevious(e) : e && (d[c] = e);
            }), this._saving = this._saving - 1;
        },
        _finishSave: function(a) {
            var d = {};
            b._traverse(this.attributes, function(a) {
                a instanceof b.Object && a.id && a._hasData && (d[a.id] = a);
            });
            var e = c.first(this._opSetQueue);
            this._opSetQueue = c.rest(this._opSetQueue), this._applyOpSet(e, this._serverData), 
            this._mergeMagicFields(a);
            var f = this;
            b._objectEach(a, function(a, c) {
                f._serverData[c] = b._decode(c, a);
                var e = b._traverse(f._serverData[c], function(a) {
                    return a instanceof b.Object && d[a.id] ? d[a.id] : void 0;
                });
                e && (f._serverData[c] = e);
            }), this._rebuildAllEstimatedData(), this._saving = this._saving - 1;
        },
        _finishFetch: function(a, b) {
            this._opSetQueue = [ {} ], this._mergeMagicFields(a), this._copyServerData(a), this._hasData = b;
        },
        _applyOpSet: function(a, c) {
            var d = this;
            b._objectEach(a, function(a, e) {
                c[e] = a._estimate(c[e], d, e), c[e] === b.Op._UNSET && delete c[e];
            });
        },
        _resetCacheForKey: function(a) {
            var d = this.attributes[a];
            if (!(!c.isObject(d) || d instanceof b.Object || d instanceof b.File)) {
                d = d.toJSON ? d.toJSON() : d;
                var e = JSON.stringify(d);
                if (this._hashedJSON[a] !== e) {
                    var f = !!this._hashedJSON[a];
                    return this._hashedJSON[a] = e, f;
                }
            }
            return !1;
        },
        _rebuildEstimatedDataForKey: function(a) {
            var c = this;
            delete this.attributes[a], this._serverData[a] && (this.attributes[a] = this._serverData[a]), 
            b._arrayEach(this._opSetQueue, function(d) {
                var e = d[a];
                e && (c.attributes[a] = e._estimate(c.attributes[a], c, a), c.attributes[a] === b.Op._UNSET ? delete c.attributes[a] : c._resetCacheForKey(a));
            });
        },
        _rebuildAllEstimatedData: function() {
            var a = this, d = c.clone(this.attributes);
            this.attributes = c.clone(this._serverData), b._arrayEach(this._opSetQueue, function(c) {
                a._applyOpSet(c, a.attributes), b._objectEach(c, function(b, c) {
                    a._resetCacheForKey(c);
                });
            }), b._objectEach(d, function(b, c) {
                a.attributes[c] !== b && a.trigger("change:" + c, a, a.attributes[c], {});
            }), b._objectEach(this.attributes, function(b, e) {
                c.has(d, e) || a.trigger("change:" + e, a, b, {});
            });
        },
        set: function(a, d, e) {
            var f;
            if (c.isObject(a) || b._isNullOrUndefined(a) ? (f = a, b._objectEach(f, function(a, c) {
                f[c] = b._decode(c, a);
            }), e = d) : (f = {}, f[a] = b._decode(a, d)), e = e || {}, !f) return this;
            f instanceof b.Object && (f = f.attributes);
            var g = this;
            b._objectEach(f, function(a, b) {
                if (g.constructor.readOnlyAttributes && g.constructor.readOnlyAttributes[b]) throw new Error("Cannot modify readonly key: " + b);
            }), e.unset && b._objectEach(f, function(a, c) {
                f[c] = new b.Op.Unset();
            });
            var h = c.clone(f);
            if (b._objectEach(h, function(a, c) {
                a instanceof b.Op && (h[c] = a._estimate(g.attributes[c], g, c), h[c] === b.Op._UNSET && delete h[c]);
            }), !this._validate(f, e)) return !1;
            this._mergeMagicFields(f), e.changes = {};
            {
                var i = this._escapedAttributes;
                this._previousAttributes || {};
            }
            return b._arrayEach(c.keys(f), function(a) {
                var d = f[a];
                d instanceof b.Relation && (d.parent = g), d instanceof b.Op || (d = new b.Op.Set(d));
                var h = !0;
                d instanceof b.Op.Set && c.isEqual(g.attributes[a], d.value) && (h = !1), h && (delete i[a], 
                e.silent ? g._silent[a] = !0 : e.changes[a] = !0);
                var j = c.last(g._opSetQueue);
                j[a] = d._mergeWithPrevious(j[a]), g._rebuildEstimatedDataForKey(a), h ? (g.changed[a] = g.attributes[a], 
                e.silent || (g._pending[a] = !0)) : (delete g.changed[a], delete g._pending[a]);
            }), e.silent || this.change(e), this;
        },
        unset: function(a, b) {
            return b = b || {}, b.unset = !0, this.set(a, null, b);
        },
        increment: function(a, d) {
            return (c.isUndefined(d) || c.isNull(d)) && (d = 1), this.set(a, new b.Op.Increment(d));
        },
        add: function(a, c) {
            return this.set(a, new b.Op.Add([ c ]));
        },
        addUnique: function(a, c) {
            return this.set(a, new b.Op.AddUnique([ c ]));
        },
        remove: function(a, c) {
            return this.set(a, new b.Op.Remove([ c ]));
        },
        op: function(a) {
            return c.last(this._opSetQueue)[a];
        },
        clear: function(a) {
            a = a || {}, a.unset = !0;
            var b = c.extend(this.attributes, this._operations);
            return this.set(b, a);
        },
        _getSaveJSON: function() {
            var a = c.clone(c.first(this._opSetQueue));
            return b._objectEach(a, function(b, c) {
                a[c] = b.toJSON();
            }), a;
        },
        _canBeSerialized: function() {
            return b.Object._canBeSerializedAsValue(this.attributes);
        },
        fetch: function(a) {
            var c = this;
            a = a || {};
            var d = b._request({
                method: "GET",
                route: "classes",
                className: this.className,
                objectId: this.id,
                useMasterKey: a.useMasterKey
            });
            return d.then(function(a, b, d) {
                return c._finishFetch(c.parse(a, b, d), !0), c;
            })._thenRunCallbacks(a, this);
        },
        save: function(a, d, e) {
            var f, g, h;
            if (c.isObject(a) || b._isNullOrUndefined(a) ? (f = a, h = d) : (f = {}, f[a] = d, 
            h = e), !h && f) {
                var i = c.reject(f, function(a, b) {
                    return c.include([ "success", "error", "wait" ], b);
                });
                if (0 === i.length) {
                    var j = !0;
                    if (c.has(f, "success") && !c.isFunction(f.success) && (j = !1), c.has(f, "error") && !c.isFunction(f.error) && (j = !1), 
                    j) return this.save(null, f);
                }
            }
            h = c.clone(h) || {}, h.wait && (g = c.clone(this.attributes));
            var k = c.clone(h) || {};
            k.wait && (k.silent = !0);
            var l;
            if (k.error = function(a, b) {
                l = b;
            }, f && !this.set(f, k)) return b.Promise.error(l)._thenRunCallbacks(h, this);
            var m = this;
            m._refreshCache();
            var n = [], o = [];
            return b.Object._findUnsavedChildren(m.attributes, n, o), n.length + o.length > 0 ? b.Object._deepSaveAsync(this.attributes, {
                useMasterKey: h.useMasterKey
            }).then(function() {
                return m.save(null, h);
            }, function(a) {
                return b.Promise.error(a)._thenRunCallbacks(h, m);
            }) : (this._startSave(), this._saving = (this._saving || 0) + 1, this._allPreviousSaves = this._allPreviousSaves || b.Promise.as(), 
            this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {
                var a = m.id ? "PUT" : "POST", d = m._getSaveJSON(), e = "classes", i = m.className;
                "_User" !== m.className || m.id || (e = "users", i = null);
                var j = b._request({
                    route: e,
                    className: i,
                    objectId: m.id,
                    method: a,
                    useMasterKey: h.useMasterKey,
                    data: d
                });
                return j = j.then(function(a, b, d) {
                    var e = m.parse(a, b, d);
                    return h.wait && (e = c.extend(f || {}, e)), m._finishSave(e), h.wait && m.set(g, k), 
                    m;
                }, function(a) {
                    return m._cancelSave(), b.Promise.error(a);
                })._thenRunCallbacks(h, m);
            }), this._allPreviousSaves);
        },
        destroy: function(a) {
            a = a || {};
            var c = this, d = function() {
                c.trigger("destroy", c, c.collection, a);
            };
            if (!this.id) return d();
            a.wait || d();
            var e = b._request({
                route: "classes",
                className: this.className,
                objectId: this.id,
                method: "DELETE",
                useMasterKey: a.useMasterKey
            });
            return e.then(function() {
                return a.wait && d(), c;
            })._thenRunCallbacks(a, this);
        },
        parse: function(a, d, e) {
            var f = c.clone(a);
            return c([ "createdAt", "updatedAt" ]).each(function(a) {
                f[a] && (f[a] = b._parseDate(f[a]));
            }), f.updatedAt || (f.updatedAt = f.createdAt), d && (this._existed = 201 !== d), 
            f;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return !this.id;
        },
        change: function(a) {
            a = a || {};
            var d = this._changing;
            this._changing = !0;
            var e = this;
            b._objectEach(this._silent, function(a) {
                e._pending[a] = !0;
            });
            var f = c.extend({}, a.changes, this._silent);
            if (this._silent = {}, b._objectEach(f, function(b, c) {
                e.trigger("change:" + c, e, e.get(c), a);
            }), d) return this;
            for (var g = function(a, b) {
                e._pending[b] || e._silent[b] || delete e.changed[b];
            }; !c.isEmpty(this._pending); ) this._pending = {}, this.trigger("change", this, a), 
            b._objectEach(this.changed, g), e._previousAttributes = c.clone(this.attributes);
            return this._changing = !1, this;
        },
        existed: function() {
            return this._existed;
        },
        hasChanged: function(a) {
            return arguments.length ? this.changed && c.has(this.changed, a) : !c.isEmpty(this.changed);
        },
        changedAttributes: function(a) {
            if (!a) return this.hasChanged() ? c.clone(this.changed) : !1;
            var d = {}, e = this._previousAttributes;
            return b._objectEach(a, function(a, b) {
                c.isEqual(e[b], a) || (d[b] = a);
            }), d;
        },
        previous: function(a) {
            return arguments.length && this._previousAttributes ? this._previousAttributes[a] : null;
        },
        previousAttributes: function() {
            return c.clone(this._previousAttributes);
        },
        isValid: function() {
            return !this.validate(this.attributes);
        },
        validate: function(a, d) {
            if (c.has(a, "ACL") && !(a.ACL instanceof b.ACL)) return new b.Error(b.Error.OTHER_CAUSE, "ACL must be a Parse.ACL.");
            var e = !0;
            return b._objectEach(a, function(a, b) {
                /^[A-Za-z][0-9A-Za-z_]*$/.test(b) || (e = !1);
            }), e ? !1 : new b.Error(b.Error.INVALID_KEY_NAME);
        },
        _validate: function(a, b) {
            if (b.silent || !this.validate) return !0;
            a = c.extend({}, this.attributes, a);
            var d = this.validate(a, b);
            return d ? (b && b.error ? b.error(this, d, b) : this.trigger("error", this, d, b), 
            !1) : !0;
        },
        getACL: function() {
            return this.get("ACL");
        },
        setACL: function(a, b) {
            return this.set("ACL", a, b);
        }
    }), b.Object._getSubclass = function(a) {
        if (!c.isString(a)) throw "Parse.Object._getSubclass requires a string argument.";
        var d = b.Object._classMap[a];
        return d || (d = b.Object.extend(a), b.Object._classMap[a] = d), d;
    }, b.Object._create = function(a, c, d) {
        var e = b.Object._getSubclass(a);
        return new e(c, d);
    }, b.Object._toObjectIdArray = function(a, c) {
        if (0 === a.length) return b.Promise.as(a);
        for (var d, e = a[0].className, f = [], g = 0; g < a.length; g++) {
            var h = a[g];
            if (e !== h.className) return d = new b.Error(b.Error.INVALID_CLASS_NAME, "All objects should be of the same class"), 
            b.Promise.error(d);
            if (!h.id) return d = new b.Error(b.Error.MISSING_OBJECT_ID, "All objects must have an ID"), 
            b.Promise.error(d);
            c && h._hasData || f.push(h.id);
        }
        return b.Promise.as(f);
    }, b.Object._updateWithFetchedResults = function(a, c, d) {
        var e = {};
        b._arrayEach(c, function(a, b) {
            e[a.id] = a;
        });
        for (var f = 0; f < a.length; f++) {
            var g = a[f], h = e[g.id];
            if (!h && d) {
                var i = new b.Error(b.Error.OBJECT_NOT_FOUND, "All objects must exist on the server");
                return b.Promise.error(i);
            }
            g._mergeFromObject(h);
        }
        return b.Promise.as(a);
    }, b.Object._fetchAll = function(a, c) {
        if (0 === a.length) return b.Promise.as(a);
        var d = !c;
        return b.Object._toObjectIdArray(a, d).then(function(c) {
            var d = a[0].className, e = new b.Query(d);
            return e.containedIn("objectId", c), e.limit = c.length, e.find();
        }).then(function(d) {
            return b.Object._updateWithFetchedResults(a, d, c);
        });
    }, b.Object._classMap = {}, b.Object._extend = b._extend, b.Object.extend = function(a, d, e) {
        if (!c.isString(a)) {
            if (a && c.has(a, "className")) return b.Object.extend(a.className, a, d);
            throw new Error("Parse.Object.extend's first argument should be the className.");
        }
        "User" === a && b.User._performUserRewrite && (a = "_User"), d = d || {}, d.className = a;
        var f = null;
        if (c.has(b.Object._classMap, a)) {
            var g = b.Object._classMap[a];
            f = g._extend(d, e);
        } else f = this._extend(d, e);
        return f.extend = function(d) {
            if (c.isString(d) || d && c.has(d, "className")) return b.Object.extend.apply(f, arguments);
            var e = [ a ].concat(b._.toArray(arguments));
            return b.Object.extend.apply(f, e);
        }, f.createWithoutData = function(a) {
            var b = new f();
            return b.id = a, b;
        }, b.Object._classMap[a] = f, f;
    }, b.Object._findUnsavedChildren = function(a, c, d) {
        b._traverse(a, function(a) {
            return a instanceof b.Object ? (a._refreshCache(), void (a.dirty() && c.push(a))) : a instanceof b.File ? void (a.url() || d.push(a)) : void 0;
        });
    }, b.Object._canBeSerializedAsValue = function(a) {
        if (a instanceof b.Object) return !!a.id;
        if (a instanceof b.File) return !0;
        var d = !0;
        return c.isArray(a) ? b._arrayEach(a, function(a) {
            b.Object._canBeSerializedAsValue(a) || (d = !1);
        }) : c.isObject(a) && b._objectEach(a, function(a) {
            b.Object._canBeSerializedAsValue(a) || (d = !1);
        }), d;
    }, b.Object._deepSaveAsync = function(a, d) {
        var e = [], f = [];
        b.Object._findUnsavedChildren(a, e, f);
        var g = b.Promise.as();
        c.each(f, function(a) {
            g = g.then(function() {
                return a.save(d);
            });
        });
        var h = c.uniq(e), i = c.uniq(h);
        return g.then(function() {
            return b.Promise._continueWhile(function() {
                return i.length > 0;
            }, function() {
                var a = [], e = [];
                if (b._arrayEach(i, function(b) {
                    return a.length > 20 ? void e.push(b) : void (b._canBeSerialized() ? a.push(b) : e.push(b));
                }), i = e, 0 === a.length) return b.Promise.error(new b.Error(b.Error.OTHER_CAUSE, "Tried to save a batch with a cycle."));
                var f = b.Promise.when(c.map(a, function(a) {
                    return a._allPreviousSaves || b.Promise.as();
                })), g = new b.Promise();
                return b._arrayEach(a, function(a) {
                    a._allPreviousSaves = g;
                }), f._continueWith(function() {
                    return b._request({
                        route: "batch",
                        method: "POST",
                        useMasterKey: d.useMasterKey,
                        data: {
                            requests: c.map(a, function(a) {
                                var b = a._getSaveJSON(), c = "POST", d = "/1/classes/" + a.className;
                                return a.id && (d = d + "/" + a.id, c = "PUT"), a._startSave(), {
                                    method: c,
                                    path: d,
                                    body: b
                                };
                            })
                        }
                    }).then(function(c, d, e) {
                        var f;
                        return b._arrayEach(a, function(a, b) {
                            c[b].success ? a._finishSave(a.parse(c[b].success, d, e)) : (f = f || c[b].error, 
                            a._cancelSave());
                        }), f ? b.Promise.error(new b.Error(f.code, f.error)) : void 0;
                    }).then(function(a) {
                        return g.resolve(a), a;
                    }, function(a) {
                        return g.reject(a), b.Promise.error(a);
                    });
                });
            });
        }).then(function() {
            return a;
        });
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Role = b.Object.extend("_Role", {
        constructor: function(a, d) {
            c.isString(a) && d instanceof b.ACL ? (b.Object.prototype.constructor.call(this, null, null), 
            this.setName(a), this.setACL(d)) : b.Object.prototype.constructor.call(this, a, d);
        },
        getName: function() {
            return this.get("name");
        },
        setName: function(a, b) {
            return this.set("name", a, b);
        },
        getUsers: function() {
            return this.relation("users");
        },
        getRoles: function() {
            return this.relation("roles");
        },
        validate: function(a, d) {
            if ("name" in a && a.name !== this.getName()) {
                var e = a.name;
                if (this.id && this.id !== a.objectId) return new b.Error(b.Error.OTHER_CAUSE, "A role's name can only be set before it has been saved.");
                if (!c.isString(e)) return new b.Error(b.Error.OTHER_CAUSE, "A role's name must be a String.");
                if (!/^[0-9a-zA-Z\-_ ]+$/.test(e)) return new b.Error(b.Error.OTHER_CAUSE, "A role's name can only contain alphanumeric characters, _, -, and spaces.");
            }
            return b.Object.prototype.validate ? b.Object.prototype.validate.call(this, a, d) : !1;
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Collection = function(a, b) {
        b = b || {}, b.comparator && (this.comparator = b.comparator), b.model && (this.model = b.model), 
        b.query && (this.query = b.query), this._reset(), this.initialize.apply(this, arguments), 
        a && this.reset(a, {
            silent: !0,
            parse: b.parse
        });
    }, c.extend(b.Collection.prototype, b.Events, {
        model: b.Object,
        initialize: function() {},
        toJSON: function() {
            return this.map(function(a) {
                return a.toJSON();
            });
        },
        add: function(a, d) {
            var e, f, g, h, i, j, k = {}, l = {};
            for (d = d || {}, a = c.isArray(a) ? a.slice() : [ a ], e = 0, g = a.length; g > e; e++) {
                if (a[e] = this._prepareModel(a[e], d), h = a[e], !h) throw new Error("Can't add an invalid model to a collection");
                if (i = h.cid, k[i] || this._byCid[i]) throw new Error("Duplicate cid: can't add the same model to a collection twice");
                if (j = h.id, !b._isNullOrUndefined(j) && (l[j] || this._byId[j])) throw new Error("Duplicate id: can't add the same model to a collection twice");
                l[j] = h, k[i] = h;
            }
            for (e = 0; g > e; e++) (h = a[e]).on("all", this._onModelEvent, this), this._byCid[h.cid] = h, 
            h.id && (this._byId[h.id] = h);
            if (this.length += g, f = b._isNullOrUndefined(d.at) ? this.models.length : d.at, 
            this.models.splice.apply(this.models, [ f, 0 ].concat(a)), this.comparator && this.sort({
                silent: !0
            }), d.silent) return this;
            for (e = 0, g = this.models.length; g > e; e++) h = this.models[e], k[h.cid] && (d.index = e, 
            h.trigger("add", h, this, d));
            return this;
        },
        remove: function(a, b) {
            var d, e, f, g;
            for (b = b || {}, a = c.isArray(a) ? a.slice() : [ a ], d = 0, e = a.length; e > d; d++) g = this.getByCid(a[d]) || this.get(a[d]), 
            g && (delete this._byId[g.id], delete this._byCid[g.cid], f = this.indexOf(g), this.models.splice(f, 1), 
            this.length--, b.silent || (b.index = f, g.trigger("remove", g, this, b)), this._removeReference(g));
            return this;
        },
        get: function(a) {
            return a && this._byId[a.id || a];
        },
        getByCid: function(a) {
            return a && this._byCid[a.cid || a];
        },
        at: function(a) {
            return this.models[a];
        },
        sort: function(a) {
            if (a = a || {}, !this.comparator) throw new Error("Cannot sort a set without a comparator");
            var b = c.bind(this.comparator, this);
            return 1 === this.comparator.length ? this.models = this.sortBy(b) : this.models.sort(b), 
            a.silent || this.trigger("reset", this, a), this;
        },
        pluck: function(a) {
            return c.map(this.models, function(b) {
                return b.get(a);
            });
        },
        reset: function(a, c) {
            var d = this;
            return a = a || [], c = c || {}, b._arrayEach(this.models, function(a) {
                d._removeReference(a);
            }), this._reset(), this.add(a, {
                silent: !0,
                parse: c.parse
            }), c.silent || this.trigger("reset", this, c), this;
        },
        fetch: function(a) {
            a = c.clone(a) || {}, void 0 === a.parse && (a.parse = !0);
            var d = this, e = this.query || new b.Query(this.model);
            return e.find({
                useMasterKey: a.useMasterKey
            }).then(function(b) {
                return a.add ? d.add(b, a) : d.reset(b, a), d;
            })._thenRunCallbacks(a, this);
        },
        create: function(a, b) {
            var d = this;
            if (b = b ? c.clone(b) : {}, a = this._prepareModel(a, b), !a) return !1;
            b.wait || d.add(a, b);
            var e = b.success;
            return b.success = function(c, f, g) {
                b.wait && d.add(c, b), e ? e(c, f) : c.trigger("sync", a, f, b);
            }, a.save(null, b), a;
        },
        parse: function(a, b) {
            return a;
        },
        chain: function() {
            return c(this.models).chain();
        },
        _reset: function(a) {
            this.length = 0, this.models = [], this._byId = {}, this._byCid = {};
        },
        _prepareModel: function(a, c) {
            if (a instanceof b.Object) a.collection || (a.collection = this); else {
                var d = a;
                c.collection = this, a = new this.model(d, c), a._validate(a.attributes, c) || (a = !1);
            }
            return a;
        },
        _removeReference: function(a) {
            this === a.collection && delete a.collection, a.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(a, b, c, d) {
            ("add" !== a && "remove" !== a || c === this) && ("destroy" === a && this.remove(b, d), 
            b && "change:objectId" === a && (delete this._byId[b.previous("objectId")], this._byId[b.id] = b), 
            this.trigger.apply(this, arguments));
        }
    });
    var d = [ "forEach", "each", "map", "reduce", "reduceRight", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "sortBy", "sortedIndex", "toArray", "size", "first", "initial", "rest", "last", "without", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "groupBy" ];
    b._arrayEach(d, function(a) {
        b.Collection.prototype[a] = function() {
            return c[a].apply(c, [ this.models ].concat(c.toArray(arguments)));
        };
    }), b.Collection.extend = b._extend;
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.View = function(a) {
        this.cid = c.uniqueId("view"), this._configure(a || {}), this._ensureElement(), 
        this.initialize.apply(this, arguments), this.delegateEvents();
    };
    var d = /^(\S+)\s*(.*)$/, e = [ "model", "collection", "el", "id", "attributes", "className", "tagName" ];
    c.extend(b.View.prototype, b.Events, {
        tagName: "div",
        $: function(a) {
            return this.$el.find(a);
        },
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            return this.$el.remove(), this;
        },
        make: function(a, c, d) {
            var e = document.createElement(a);
            return c && b.$(e).attr(c), d && b.$(e).html(d), e;
        },
        setElement: function(a, c) {
            return this.$el = b.$(a), this.el = this.$el[0], c !== !1 && this.delegateEvents(), 
            this;
        },
        delegateEvents: function(a) {
            if (a = a || b._getValue(this, "events")) {
                this.undelegateEvents();
                var e = this;
                b._objectEach(a, function(b, f) {
                    if (c.isFunction(b) || (b = e[a[f]]), !b) throw new Error('Event "' + a[f] + '" does not exist');
                    var g = f.match(d), h = g[1], i = g[2];
                    b = c.bind(b, e), h += ".delegateEvents" + e.cid, "" === i ? e.$el.bind(h, b) : e.$el.delegate(i, h, b);
                });
            }
        },
        undelegateEvents: function() {
            this.$el.unbind(".delegateEvents" + this.cid);
        },
        _configure: function(a) {
            this.options && (a = c.extend({}, this.options, a));
            var b = this;
            c.each(e, function(c) {
                a[c] && (b[c] = a[c]);
            }), this.options = a;
        },
        _ensureElement: function() {
            if (this.el) this.setElement(this.el, !1); else {
                var a = b._getValue(this, "attributes") || {};
                this.id && (a.id = this.id), this.className && (a["class"] = this.className), this.setElement(this.make(this.tagName, a), !1);
            }
        }
    }), b.View.extend = b._extend;
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.User = b.Object.extend("_User", {
        _isCurrentUser: !1,
        _mergeFromObject: function(a) {
            a.getSessionToken() && (this._sessionToken = a.getSessionToken()), b.User.__super__._mergeFromObject.call(this, a);
        },
        _mergeMagicFields: function(a) {
            a.sessionToken && (this._sessionToken = a.sessionToken, delete a.sessionToken), 
            b.User.__super__._mergeMagicFields.call(this, a);
        },
        _cleanupAuthData: function() {
            if (this.isCurrent()) {
                var a = this.get("authData");
                a && b._objectEach(this.get("authData"), function(b, c) {
                    a[c] || delete a[c];
                });
            }
        },
        _synchronizeAllAuthData: function() {
            var a = this.get("authData");
            if (a) {
                var c = this;
                b._objectEach(this.get("authData"), function(a, b) {
                    c._synchronizeAuthData(b);
                });
            }
        },
        _synchronizeAuthData: function(a) {
            if (this.isCurrent()) {
                var d;
                c.isString(a) ? (d = a, a = b.User._authProviders[d]) : d = a.getAuthType();
                var e = this.get("authData");
                if (e && a) {
                    var f = a.restoreAuthentication(e[d]);
                    f || this._unlinkFrom(a);
                }
            }
        },
        _handleSaveResult: function(a) {
            a && (this._isCurrentUser = !0), this._cleanupAuthData(), this._synchronizeAllAuthData(), 
            delete this._serverData.password, this._rebuildEstimatedDataForKey("password"), 
            this._refreshCache(), (a || this.isCurrent()) && b.User._saveCurrentUser(this);
        },
        _linkWith: function(a, d) {
            var e;
            if (c.isString(a) ? (e = a, a = b.User._authProviders[a]) : e = a.getAuthType(), 
            c.has(d, "authData")) {
                var f = this.get("authData") || {};
                f[e] = d.authData, this.set("authData", f);
                var g = c.clone(d) || {};
                return g.success = function(a) {
                    a._handleSaveResult(!0), d.success && d.success.apply(this, arguments);
                }, this.save({
                    authData: f
                }, g);
            }
            var h = this, i = new b.Promise();
            return a.authenticate({
                success: function(a, b) {
                    h._linkWith(a, {
                        authData: b,
                        success: d.success,
                        error: d.error
                    }).then(function() {
                        i.resolve(h);
                    });
                },
                error: function(a, b) {
                    d.error && d.error(h, b), i.reject(b);
                }
            }), i;
        },
        _unlinkFrom: function(a, d) {
            var e;
            c.isString(a) ? (e = a, a = b.User._authProviders[a]) : e = a.getAuthType();
            var f = c.clone(d), g = this;
            return f.authData = null, f.success = function(b) {
                g._synchronizeAuthData(a), d.success && d.success.apply(this, arguments);
            }, this._linkWith(a, f);
        },
        _isLinked: function(a) {
            var b;
            b = c.isString(a) ? a : a.getAuthType();
            var d = this.get("authData") || {};
            return !!d[b];
        },
        _logOutWithAll: function() {
            var a = this.get("authData");
            if (a) {
                var c = this;
                b._objectEach(this.get("authData"), function(a, b) {
                    c._logOutWith(b);
                });
            }
        },
        _logOutWith: function(a) {
            this.isCurrent() && (c.isString(a) && (a = b.User._authProviders[a]), a && a.deauthenticate && a.deauthenticate());
        },
        signUp: function(a, d) {
            var e;
            d = d || {};
            var f = a && a.username || this.get("username");
            if (!f || "" === f) return e = new b.Error(b.Error.OTHER_CAUSE, "Cannot sign up user with an empty name."), 
            d && d.error && d.error(this, e), b.Promise.error(e);
            var g = a && a.password || this.get("password");
            if (!g || "" === g) return e = new b.Error(b.Error.OTHER_CAUSE, "Cannot sign up user with an empty password."), 
            d && d.error && d.error(this, e), b.Promise.error(e);
            var h = c.clone(d);
            return h.success = function(a) {
                a._handleSaveResult(!0), d.success && d.success.apply(this, arguments);
            }, this.save(a, h);
        },
        logIn: function(a) {
            var c = this;
            a = a || {};
            var d = b._request({
                route: "login",
                method: "GET",
                useMasterKey: a.useMasterKey,
                data: this.toJSON()
            });
            return d.then(function(a, b, d) {
                var e = c.parse(a, b, d);
                return c._finishFetch(e), c._handleSaveResult(!0), c;
            })._thenRunCallbacks(a, this);
        },
        save: function(a, d, e) {
            var f, g;
            c.isObject(a) || c.isNull(a) || c.isUndefined(a) ? (f = a, g = d) : (f = {}, f[a] = d, 
            g = e), g = g || {};
            var h = c.clone(g);
            return h.success = function(a) {
                a._handleSaveResult(!1), g.success && g.success.apply(this, arguments);
            }, b.Object.prototype.save.call(this, f, h);
        },
        fetch: function(a) {
            var d = a ? c.clone(a) : {};
            return d.success = function(b) {
                b._handleSaveResult(!1), a && a.success && a.success.apply(this, arguments);
            }, b.Object.prototype.fetch.call(this, d);
        },
        isCurrent: function() {
            return this._isCurrentUser;
        },
        getUsername: function() {
            return this.get("username");
        },
        setUsername: function(a, b) {
            return this.set("username", a, b);
        },
        setPassword: function(a, b) {
            return this.set("password", a, b);
        },
        getEmail: function() {
            return this.get("email");
        },
        setEmail: function(a, b) {
            return this.set("email", a, b);
        },
        authenticated: function() {
            return !!this._sessionToken && b.User.current() && b.User.current().id === this.id;
        },
        getSessionToken: function() {
            return this._sessionToken;
        },
        _upgradeToRevocableSession: function(a) {
            if (a = a || {}, !b.User.current()) return b.Promise.as()._thenRunCallbacks(a);
            var c = b.User.current().getSessionToken();
            return b.Session._isRevocable(c) ? b.Promise.as()._thenRunCallbacks(a) : b._request({
                route: "upgradeToRevocableSession",
                method: "POST",
                useMasterKey: a.useMasterKey,
                sessionToken: c
            }).then(function(a) {
                var c = new b.Session();
                c._finishFetch(a);
                var d = b.User.current();
                d._sessionToken = c.getSessionToken(), b.User._saveCurrentUser(d);
            })._thenRunCallbacks(a);
        }
    }, {
        _currentUser: null,
        _currentUserMatchesDisk: !1,
        _CURRENT_USER_KEY: "currentUser",
        _authProviders: {},
        _performUserRewrite: !0,
        _isRevocableSessionEnabled: !1,
        signUp: function(a, c, d, e) {
            d = d || {}, d.username = a, d.password = c;
            var f = b.Object._create("_User");
            return f.signUp(d, e);
        },
        logIn: function(a, c, d) {
            var e = b.Object._create("_User");
            return e._finishFetch({
                username: a,
                password: c
            }), e.logIn(d);
        },
        become: function(a, c) {
            c = c || {};
            var d = b.Object._create("_User");
            return b._request({
                route: "users",
                className: "me",
                method: "GET",
                useMasterKey: c.useMasterKey,
                sessionToken: a
            }).then(function(a, b, c) {
                var e = d.parse(a, b, c);
                return d._finishFetch(e), d._handleSaveResult(!0), d;
            })._thenRunCallbacks(c, d);
        },
        logOut: function() {
            return b.User._currentAsync().then(function(a) {
                var c = b.Storage.removeItemAsync(b._getParsePath(b.User._CURRENT_USER_KEY));
                if (null !== a) {
                    var d = a.getSessionToken();
                    b.Session._isRevocable(d) && c.then(function() {
                        return b._request({
                            route: "logout",
                            method: "POST",
                            sessionToken: d
                        });
                    }), a._logOutWithAll(), a._isCurrentUser = !1;
                }
                return b.User._currentUserMatchesDisk = !0, b.User._currentUser = null, c;
            });
        },
        requestPasswordReset: function(a, c) {
            c = c || {};
            var d = b._request({
                route: "requestPasswordReset",
                method: "POST",
                useMasterKey: c.useMasterKey,
                data: {
                    email: a
                }
            });
            return d._thenRunCallbacks(c);
        },
        current: function() {
            if (b.Storage.async) return b.User._currentAsync(), b.User._currentUser;
            if (b.User._currentUser) return b.User._currentUser;
            if (b.User._currentUserMatchesDisk) return b.User._currentUser;
            b.User._currentUserMatchesDisk = !0;
            var a = b.Storage.getItem(b._getParsePath(b.User._CURRENT_USER_KEY));
            if (!a) return null;
            b.User._currentUser = b.Object._create("_User"), b.User._currentUser._isCurrentUser = !0;
            var c = JSON.parse(a);
            return b.User._currentUser.id = c._id, delete c._id, b.User._currentUser._sessionToken = c._sessionToken, 
            delete c._sessionToken, b.User._currentUser._finishFetch(c), b.User._currentUser._synchronizeAllAuthData(), 
            b.User._currentUser._refreshCache(), b.User._currentUser._opSetQueue = [ {} ], b.User._currentUser;
        },
        _currentAsync: function() {
            return b.User._currentUser ? b.Promise.as(b.User._currentUser) : b.User._currentUserMatchesDisk ? b.Promise.as(b.User._currentUser) : b.Storage.getItemAsync(b._getParsePath(b.User._CURRENT_USER_KEY)).then(function(a) {
                if (!a) return null;
                b.User._currentUser = b.Object._create("_User"), b.User._currentUser._isCurrentUser = !0;
                var c = JSON.parse(a);
                return b.User._currentUser.id = c._id, delete c._id, b.User._currentUser._sessionToken = c._sessionToken, 
                delete c._sessionToken, b.User._currentUser._finishFetch(c), b.User._currentUser._synchronizeAllAuthData(), 
                b.User._currentUser._refreshCache(), b.User._currentUser._opSetQueue = [ {} ], b.User._currentUser;
            });
        },
        allowCustomUserClass: function(a) {
            this._performUserRewrite = !a;
        },
        enableRevocableSession: function(a) {
            return a = a || {}, b.User._isRevocableSessionEnabled = !0, !b._isNode && b.User.current() ? b.User.current()._upgradeToRevocableSession(a) : b.Promise.as()._thenRunCallbacks(a);
        },
        _saveCurrentUser: function(a) {
            null !== b.User._currentUser && b.User._currentUser !== a && b.User.logOut(), a._isCurrentUser = !0, 
            b.User._currentUser = a, b.User._currentUserMatchesDisk = !0;
            var c = a.toJSON();
            c._id = a.id, c._sessionToken = a._sessionToken, b.Storage.async ? b.Storage.setItemAsync(b._getParsePath(b.User._CURRENT_USER_KEY), JSON.stringify(c)) : b.Storage.setItem(b._getParsePath(b.User._CURRENT_USER_KEY), JSON.stringify(c));
        },
        _registerAuthenticationProvider: function(a) {
            b.User._authProviders[a.getAuthType()] = a, b.User.current() && b.User.current()._synchronizeAuthData(a.getAuthType());
        },
        _logInWith: function(a, c) {
            var d = b.Object._create("_User");
            return d._linkWith(a, c);
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse;
    b.Session = b.Object.extend("_Session", {
        getSessionToken: function() {
            return this._sessionToken;
        },
        _mergeMagicFields: function(a) {
            a.sessionToken && (this._sessionToken = a.sessionToken, delete a.sessionToken), 
            b.Session.__super__._mergeMagicFields.call(this, a);
        }
    }, {
        readOnlyAttributes: {
            createdWith: !0,
            expiresAt: !0,
            installationId: !0,
            restricted: !0,
            sessionToken: !0,
            user: !0
        },
        current: function(a) {
            a = a || {};
            var c = b.Object._create("_Session"), d = b.User.current().getSessionToken();
            return b._request({
                route: "sessions",
                className: "me",
                method: "GET",
                useMasterKey: a.useMasterKey,
                sessionToken: d
            }).then(function(a, b, d) {
                var e = c.parse(a, b, d);
                return c._finishFetch(e), c;
            })._thenRunCallbacks(a, c);
        },
        _isRevocable: function(a) {
            return a.indexOf("r:") > -1;
        },
        isCurrentSessionRevocable: function() {
            return null !== b.User.current() ? b.Session._isRevocable(b.User.current().getSessionToken()) : void 0;
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Query = function(a) {
        c.isString(a) && (a = b.Object._getSubclass(a)), this.objectClass = a, this.className = a.prototype.className, 
        this._where = {}, this._include = [], this._limit = -1, this._skip = 0, this._extraOptions = {};
    }, b.Query.or = function() {
        var a = c.toArray(arguments), d = null;
        b._arrayEach(a, function(a) {
            if (c.isNull(d) && (d = a.className), d !== a.className) throw "All queries must be for the same class";
        });
        var e = new b.Query(d);
        return e._orQuery(a), e;
    }, b.Query.prototype = {
        get: function(a, d) {
            var e = this;
            e.equalTo("objectId", a);
            var f = {};
            return d && c.has(d, "useMasterKey") && (f = {
                useMasterKey: d.useMasterKey
            }), e.first(f).then(function(a) {
                if (a) return a;
                var c = new b.Error(b.Error.OBJECT_NOT_FOUND, "Object not found.");
                return b.Promise.error(c);
            })._thenRunCallbacks(d, null);
        },
        toJSON: function() {
            var a = {
                where: this._where
            };
            return this._include.length > 0 && (a.include = this._include.join(",")), this._select && (a.keys = this._select.join(",")), 
            this._limit >= 0 && (a.limit = this._limit), this._skip > 0 && (a.skip = this._skip), 
            void 0 !== this._order && (a.order = this._order.join(",")), b._objectEach(this._extraOptions, function(b, c) {
                a[c] = b;
            }), a;
        },
        find: function(a) {
            var d = this;
            a = a || {};
            var e = b._request({
                route: "classes",
                className: this.className,
                method: "GET",
                useMasterKey: a.useMasterKey,
                data: this.toJSON()
            });
            return e.then(function(a) {
                return c.map(a.results, function(c) {
                    var e;
                    return e = a.className ? new b.Object(a.className) : new d.objectClass(), e._finishFetch(c, !0), 
                    e;
                });
            })._thenRunCallbacks(a);
        },
        count: function(a) {
            var c = this;
            a = a || {};
            var d = this.toJSON();
            d.limit = 0, d.count = 1;
            var e = b._request({
                route: "classes",
                className: c.className,
                method: "GET",
                useMasterKey: a.useMasterKey,
                data: d
            });
            return e.then(function(a) {
                return a.count;
            })._thenRunCallbacks(a);
        },
        first: function(a) {
            var d = this;
            a = a || {};
            var e = this.toJSON();
            e.limit = 1;
            var f = b._request({
                route: "classes",
                className: this.className,
                method: "GET",
                useMasterKey: a.useMasterKey,
                data: e
            });
            return f.then(function(a) {
                return c.map(a.results, function(c) {
                    var e;
                    return e = a.className ? new b.Object(a.className) : new d.objectClass(), e._finishFetch(c, !0), 
                    e;
                })[0];
            })._thenRunCallbacks(a);
        },
        collection: function(a, d) {
            return d = d || {}, new b.Collection(a, c.extend(d, {
                model: this.objectClass,
                query: this
            }));
        },
        skip: function(a) {
            return this._skip = a, this;
        },
        limit: function(a) {
            return this._limit = a, this;
        },
        equalTo: function(a, d) {
            return c.isUndefined(d) ? this.doesNotExist(a) : (this._where[a] = b._encode(d), 
            this);
        },
        _addCondition: function(a, c, d) {
            return this._where[a] || (this._where[a] = {}), this._where[a][c] = b._encode(d), 
            this;
        },
        notEqualTo: function(a, b) {
            return this._addCondition(a, "$ne", b), this;
        },
        lessThan: function(a, b) {
            return this._addCondition(a, "$lt", b), this;
        },
        greaterThan: function(a, b) {
            return this._addCondition(a, "$gt", b), this;
        },
        lessThanOrEqualTo: function(a, b) {
            return this._addCondition(a, "$lte", b), this;
        },
        greaterThanOrEqualTo: function(a, b) {
            return this._addCondition(a, "$gte", b), this;
        },
        containedIn: function(a, b) {
            return this._addCondition(a, "$in", b), this;
        },
        notContainedIn: function(a, b) {
            return this._addCondition(a, "$nin", b), this;
        },
        containsAll: function(a, b) {
            return this._addCondition(a, "$all", b), this;
        },
        exists: function(a) {
            return this._addCondition(a, "$exists", !0), this;
        },
        doesNotExist: function(a) {
            return this._addCondition(a, "$exists", !1), this;
        },
        matches: function(a, b, c) {
            return this._addCondition(a, "$regex", b), c || (c = ""), b.ignoreCase && (c += "i"), 
            b.multiline && (c += "m"), c && c.length && this._addCondition(a, "$options", c), 
            this;
        },
        matchesQuery: function(a, b) {
            var c = b.toJSON();
            return c.className = b.className, this._addCondition(a, "$inQuery", c), this;
        },
        doesNotMatchQuery: function(a, b) {
            var c = b.toJSON();
            return c.className = b.className, this._addCondition(a, "$notInQuery", c), this;
        },
        matchesKeyInQuery: function(a, b, c) {
            var d = c.toJSON();
            return d.className = c.className, this._addCondition(a, "$select", {
                key: b,
                query: d
            }), this;
        },
        doesNotMatchKeyInQuery: function(a, b, c) {
            var d = c.toJSON();
            return d.className = c.className, this._addCondition(a, "$dontSelect", {
                key: b,
                query: d
            }), this;
        },
        _orQuery: function(a) {
            var b = c.map(a, function(a) {
                return a.toJSON().where;
            });
            return this._where.$or = b, this;
        },
        _quote: function(a) {
            return "\\Q" + a.replace("\\E", "\\E\\\\E\\Q") + "\\E";
        },
        contains: function(a, b) {
            return this._addCondition(a, "$regex", this._quote(b)), this;
        },
        startsWith: function(a, b) {
            return this._addCondition(a, "$regex", "^" + this._quote(b)), this;
        },
        endsWith: function(a, b) {
            return this._addCondition(a, "$regex", this._quote(b) + "$"), this;
        },
        ascending: function() {
            return this._order = [], this.addAscending.apply(this, arguments);
        },
        addAscending: function(a) {
            var c = this;
            return this._order || (this._order = []), b._arrayEach(arguments, function(a) {
                Array.isArray(a) && (a = a.join()), c._order = c._order.concat(a.replace(/\s/g, "").split(","));
            }), this;
        },
        descending: function(a) {
            return this._order = [], this.addDescending.apply(this, arguments);
        },
        addDescending: function(a) {
            var d = this;
            return this._order || (this._order = []), b._arrayEach(arguments, function(a) {
                Array.isArray(a) && (a = a.join()), d._order = d._order.concat(c.map(a.replace(/\s/g, "").split(","), function(a) {
                    return "-" + a;
                }));
            }), this;
        },
        near: function(a, c) {
            return c instanceof b.GeoPoint || (c = new b.GeoPoint(c)), this._addCondition(a, "$nearSphere", c), 
            this;
        },
        withinRadians: function(a, b, c) {
            return this.near(a, b), this._addCondition(a, "$maxDistance", c), this;
        },
        withinMiles: function(a, b, c) {
            return this.withinRadians(a, b, c / 3958.8);
        },
        withinKilometers: function(a, b, c) {
            return this.withinRadians(a, b, c / 6371);
        },
        withinGeoBox: function(a, c, d) {
            return c instanceof b.GeoPoint || (c = new b.GeoPoint(c)), d instanceof b.GeoPoint || (d = new b.GeoPoint(d)), 
            this._addCondition(a, "$within", {
                $box: [ c, d ]
            }), this;
        },
        include: function() {
            var a = this;
            return b._arrayEach(arguments, function(b) {
                c.isArray(b) ? a._include = a._include.concat(b) : a._include.push(b);
            }), this;
        },
        select: function() {
            var a = this;
            return this._select = this._select || [], b._arrayEach(arguments, function(b) {
                c.isArray(b) ? a._select = a._select.concat(b) : a._select.push(b);
            }), this;
        },
        each: function(a, d) {
            if (d = d || {}, this._order || this._skip || this._limit >= 0) {
                var e = "Cannot iterate on a query with sort, skip, or limit.";
                return b.Promise.error(e)._thenRunCallbacks(d);
            }
            var f = (new b.Promise(), new b.Query(this.objectClass));
            f._limit = d.batchSize || 100, f._where = c.clone(this._where), f._include = c.clone(this._include), 
            this._select && (f._select = c.clone(this._select)), f.ascending("objectId");
            var g = {};
            c.has(d, "useMasterKey") && (g.useMasterKey = d.useMasterKey);
            var h = !1;
            return b.Promise._continueWhile(function() {
                return !h;
            }, function() {
                return f.find(g).then(function(c) {
                    var d = b.Promise.as();
                    return b._.each(c, function(b) {
                        d = d.then(function() {
                            return a(b);
                        });
                    }), d.then(function() {
                        c.length >= f._limit ? f.greaterThan("objectId", c[c.length - 1].id) : h = !0;
                    });
                });
            })._thenRunCallbacks(d);
        }
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b, c, d = a.Parse, e = d._, f = !1, g = {
        authenticate: function(a) {
            var c = this;
            FB.login(function(b) {
                b.authResponse ? a.success && a.success(c, {
                    id: b.authResponse.userID,
                    access_token: b.authResponse.accessToken,
                    expiration_date: new Date(1e3 * b.authResponse.expiresIn + new Date().getTime()).toJSON()
                }) : a.error && a.error(c, b);
            }, {
                scope: b
            });
        },
        restoreAuthentication: function(a) {
            if (a) {
                var b = {
                    userID: a.id,
                    accessToken: a.access_token,
                    expiresIn: (d._parseDate(a.expiration_date).getTime() - new Date().getTime()) / 1e3
                }, f = e.clone(c);
                f.authResponse = b, f.status = !1;
                var g = FB.getAuthResponse();
                g && g.userID !== b.userID && FB.logout(), FB.init(f);
            }
            return !0;
        },
        getAuthType: function() {
            return "facebook";
        },
        deauthenticate: function() {
            this.restoreAuthentication(null);
        }
    };
    d.FacebookUtils = {
        init: function(a) {
            if ("undefined" == typeof FB) throw "The Facebook JavaScript SDK must be loaded before calling init.";
            if (c = e.clone(a) || {}, c.status && "undefined" != typeof console) {
                var b = console.warn || console.log || function() {};
                b.call(console, "The 'status' flag passed into FB.init, when set to true, can interfere with Parse Facebook integration, so it has been suppressed. Please call FB.getLoginStatus() explicitly if you require this behavior.");
            }
            c.status = !1, FB.init(c), d.User._registerAuthenticationProvider(g), f = !0;
        },
        isLinked: function(a) {
            return a._isLinked("facebook");
        },
        logIn: function(a, c) {
            if (!a || e.isString(a)) {
                if (!f) throw "You must initialize FacebookUtils before calling logIn.";
                return b = a, d.User._logInWith("facebook", c);
            }
            var g = e.clone(c) || {};
            return g.authData = a, d.User._logInWith("facebook", g);
        },
        link: function(a, c, d) {
            if (!c || e.isString(c)) {
                if (!f) throw "You must initialize FacebookUtils before calling link.";
                return b = c, a._linkWith("facebook", d);
            }
            var g = e.clone(d) || {};
            return g.authData = c, a._linkWith("facebook", g);
        },
        unlink: function(a, b) {
            if (!f) throw "You must initialize FacebookUtils before calling unlink.";
            return a._unlinkFrom("facebook", b);
        }
    };
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.History = function() {
        this.handlers = [], c.bindAll(this, "checkUrl");
    };
    var d = /^[#\/]/, e = /msie [\w.]+/;
    b.History.started = !1, c.extend(b.History.prototype, b.Events, {
        interval: 50,
        getHash: function(a) {
            var b = a ? a.location : window.location, c = b.href.match(/#(.*)$/);
            return c ? c[1] : "";
        },
        getFragment: function(a, c) {
            if (b._isNullOrUndefined(a)) if (this._hasPushState || c) {
                a = window.location.pathname;
                var e = window.location.search;
                e && (a += e);
            } else a = this.getHash();
            return a.indexOf(this.options.root) || (a = a.substr(this.options.root.length)), 
            a.replace(d, "");
        },
        start: function(a) {
            if (b.History.started) throw new Error("Parse.history has already been started");
            b.History.started = !0, this.options = c.extend({}, {
                root: "/"
            }, this.options, a), this._wantsHashChange = this.options.hashChange !== !1, this._wantsPushState = !!this.options.pushState, 
            this._hasPushState = !!(this.options.pushState && window.history && window.history.pushState);
            var f = this.getFragment(), g = document.documentMode, h = e.exec(navigator.userAgent.toLowerCase()) && (!g || 7 >= g);
            h && (this.iframe = b.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow, 
            this.navigate(f)), this._hasPushState ? b.$(window).bind("popstate", this.checkUrl) : this._wantsHashChange && "onhashchange" in window && !h ? b.$(window).bind("hashchange", this.checkUrl) : this._wantsHashChange && (this._checkUrlInterval = window.setInterval(this.checkUrl, this.interval)), 
            this.fragment = f;
            var i = window.location, j = i.pathname === this.options.root;
            return this._wantsHashChange && this._wantsPushState && !this._hasPushState && !j ? (this.fragment = this.getFragment(null, !0), 
            window.location.replace(this.options.root + "#" + this.fragment), !0) : (this._wantsPushState && this._hasPushState && j && i.hash && (this.fragment = this.getHash().replace(d, ""), 
            window.history.replaceState({}, document.title, i.protocol + "//" + i.host + this.options.root + this.fragment)), 
            this.options.silent ? void 0 : this.loadUrl());
        },
        stop: function() {
            b.$(window).unbind("popstate", this.checkUrl).unbind("hashchange", this.checkUrl), 
            window.clearInterval(this._checkUrlInterval), b.History.started = !1;
        },
        route: function(a, b) {
            this.handlers.unshift({
                route: a,
                callback: b
            });
        },
        checkUrl: function(a) {
            var b = this.getFragment();
            return b === this.fragment && this.iframe && (b = this.getFragment(this.getHash(this.iframe))), 
            b === this.fragment ? !1 : (this.iframe && this.navigate(b), void (this.loadUrl() || this.loadUrl(this.getHash())));
        },
        loadUrl: function(a) {
            var b = this.fragment = this.getFragment(a), d = c.any(this.handlers, function(a) {
                return a.route.test(b) ? (a.callback(b), !0) : void 0;
            });
            return d;
        },
        navigate: function(a, c) {
            if (!b.History.started) return !1;
            c && c !== !0 || (c = {
                trigger: c
            });
            var e = (a || "").replace(d, "");
            if (this.fragment !== e) {
                if (this._hasPushState) {
                    0 !== e.indexOf(this.options.root) && (e = this.options.root + e), this.fragment = e;
                    var f = c.replace ? "replaceState" : "pushState";
                    window.history[f]({}, document.title, e);
                } else this._wantsHashChange ? (this.fragment = e, this._updateHash(window.location, e, c.replace), 
                this.iframe && e !== this.getFragment(this.getHash(this.iframe)) && (c.replace || this.iframe.document.open().close(), 
                this._updateHash(this.iframe.location, e, c.replace))) : window.location.assign(this.options.root + a);
                c.trigger && this.loadUrl(a);
            }
        },
        _updateHash: function(a, b, c) {
            if (c) {
                var d = a.toString().replace(/(javascript:|#).*$/, "");
                a.replace(d + "#" + b);
            } else a.hash = b;
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Router = function(a) {
        a = a || {}, a.routes && (this.routes = a.routes), this._bindRoutes(), this.initialize.apply(this, arguments);
    };
    var d = /:\w+/g, e = /\*\w+/g, f = /[\-\[\]{}()+?.,\\\^\$\|#\s]/g;
    c.extend(b.Router.prototype, b.Events, {
        initialize: function() {},
        route: function(a, d, e) {
            return b.history = b.history || new b.History(), c.isRegExp(a) || (a = this._routeToRegExp(a)), 
            e || (e = this[d]), b.history.route(a, c.bind(function(c) {
                var f = this._extractParameters(a, c);
                e && e.apply(this, f), this.trigger.apply(this, [ "route:" + d ].concat(f)), b.history.trigger("route", this, d, f);
            }, this)), this;
        },
        navigate: function(a, c) {
            b.history.navigate(a, c);
        },
        _bindRoutes: function() {
            if (this.routes) {
                var a = [];
                for (var b in this.routes) this.routes.hasOwnProperty(b) && a.unshift([ b, this.routes[b] ]);
                for (var c = 0, d = a.length; d > c; c++) this.route(a[c][0], a[c][1], this[a[c][1]]);
            }
        },
        _routeToRegExp: function(a) {
            return a = a.replace(f, "\\$&").replace(d, "([^/]+)").replace(e, "(.*?)"), new RegExp("^" + a + "$");
        },
        _extractParameters: function(a, b) {
            return a.exec(b).slice(1);
        }
    }), b.Router.extend = b._extend;
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse, c = b._;
    b.Cloud = b.Cloud || {}, c.extend(b.Cloud, {
        run: function(a, c, d) {
            d = d || {};
            var e = b._request({
                route: "functions",
                className: a,
                method: "POST",
                useMasterKey: d.useMasterKey,
                data: b._encode(c, null, !0)
            });
            return e.then(function(a) {
                return b._decode(null, a).result;
            })._thenRunCallbacks(d);
        }
    });
}(this), function(a) {
    a.Parse = a.Parse || {};
    var b = a.Parse;
    b.Installation = b.Object.extend("_Installation"), b.Push = b.Push || {}, b.Push.send = function(a, c) {
        if (c = c || {}, a.where && (a.where = a.where.toJSON().where), a.push_time && (a.push_time = a.push_time.toJSON()), 
        a.expiration_time && (a.expiration_time = a.expiration_time.toJSON()), a.expiration_time && a.expiration_interval) throw "Both expiration_time and expiration_interval can't be set";
        var d = b._request({
            route: "push",
            method: "POST",
            data: a,
            useMasterKey: c.useMasterKey
        });
        return d._thenRunCallbacks(c);
    };
}(this);

/*1467474669,,JIT Construction: v2425895,en_GB*/
/**
 * Copyright Facebook Inc.
 *
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
try {
    window.FB || function(window, fb_fif_window) {
        var apply = Function.prototype.apply;
        function bindContext(fn, thisArg) {
            return function _sdkBound() {
                return apply.call(fn, thisArg, arguments);
            };
        }
        var global = {
            __type: "JS_SDK_SANDBOX",
            window: window,
            document: window.document
        };
        var sandboxWhitelist = [ "setTimeout", "setInterval", "clearTimeout", "clearInterval" ];
        for (var i = 0; i < sandboxWhitelist.length; i++) {
            global[sandboxWhitelist[i]] = bindContext(window[sandboxWhitelist[i]], window);
        }
        (function() {
            var self = window;
            var __DEV__ = 0;
            function emptyFunction() {}
            var __transform_includes = {};
            var __annotator, __bodyWrapper;
            var __w, __t;
            var undefined;
            with (this) {
                (function() {
                    var a = {}, b = function(i, j) {
                        if (!i && !j) return null;
                        var k = {};
                        if (typeof i !== "undefined") k.type = i;
                        if (typeof j !== "undefined") k.signature = j;
                        return k;
                    }, c = function(i, j) {
                        return b(i && /^[A-Z]/.test(i) ? i : undefined, j && (j.params && j.params.length || j.returns) ? "function(" + (j.params ? j.params.map(function(k) {
                            return /\?/.test(k) ? "?" + k.replace("?", "") : k;
                        }).join(",") : "") + ")" + (j.returns ? ":" + j.returns : "") : undefined);
                    }, d = function(i, j, k) {
                        return i;
                    }, e = function(i, j, k) {
                        if ("sourcemeta" in __transform_includes) i.__SMmeta = j;
                        if ("typechecks" in __transform_includes) {
                            var l = c(j ? j.name : undefined, k);
                            if (l) __w(i, l);
                        }
                        return i;
                    }, f = function(i, j, k) {
                        return k.apply(i, j);
                    }, g = function(i, j, k, l) {
                        if (l && l.params) __t.apply(i, l.params);
                        var m = k.apply(i, j);
                        if (l && l.returns) __t([ m, l.returns ]);
                        return m;
                    }, h = function(i, j, k, l, m) {
                        if (m) {
                            if (!m.callId) m.callId = m.module + ":" + (m.line || 0) + ":" + (m.column || 0);
                            var n = m.callId;
                            a[n] = (a[n] || 0) + 1;
                        }
                        return k.apply(i, j);
                    };
                    if (typeof __transform_includes === "undefined") {
                        __annotator = d;
                        __bodyWrapper = f;
                    } else {
                        __annotator = e;
                        if ("codeusage" in __transform_includes) {
                            __annotator = d;
                            __bodyWrapper = h;
                            __bodyWrapper.getCodeUsage = function() {
                                return a;
                            };
                            __bodyWrapper.clearCodeUsage = function() {
                                a = {};
                            };
                        } else if ("typechecks" in __transform_includes) {
                            __bodyWrapper = g;
                        } else __bodyWrapper = f;
                    }
                })();
                __t = function(a) {
                    return a[0];
                };
                __w = function(a) {
                    return a;
                };
                var require, __d;
                (function(a) {
                    var b = {}, c = {}, d = [ "global", "require", "requireDynamic", "requireLazy", "module", "exports" ];
                    require = function(e, f) {
                        if (c.hasOwnProperty(e)) return c[e];
                        if (!b.hasOwnProperty(e)) {
                            if (f) return null;
                            throw new Error("Module " + e + " has not been defined");
                        }
                        var g = b[e], h = g.deps, i = g.factory.length, j, k = [];
                        for (var l = 0; l < i; l++) {
                            switch (h[l]) {
                              case "module":
                                j = g;
                                break;

                              case "exports":
                                j = g.exports;
                                break;

                              case "global":
                                j = a;
                                break;

                              case "require":
                                j = require;
                                break;

                              case "requireDynamic":
                                j = null;
                                break;

                              case "requireLazy":
                                j = null;
                                break;

                              default:
                                j = require.call(null, h[l]);
                            }
                            k.push(j);
                        }
                        g.factory.apply(a, k);
                        c[e] = g.exports;
                        return g.exports;
                    };
                    require.__markCompiled = function() {};
                    __d = function(e, f, g, h) {
                        if (typeof g == "function") {
                            b[e] = {
                                factory: g,
                                deps: d.concat(f),
                                exports: {}
                            };
                            if (h === 3) require.call(null, e);
                        } else c[e] = g;
                    };
                })(this);
                __d("ES5Array", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.isArray = function(i) {
                        return Object.prototype.toString.call(i) == "[object Array]";
                    };
                    f.exports = h;
                }, null);
                __d("ES5ArrayPrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.map = function(i, j) {
                        if (typeof i != "function") throw new TypeError();
                        var k, l = this.length, m = new Array(l);
                        for (k = 0; k < l; ++k) if (k in this) m[k] = i.call(j, this[k], k, this);
                        return m;
                    };
                    h.forEach = function(i, j) {
                        h.map.call(this, i, j);
                    };
                    h.filter = function(i, j) {
                        if (typeof i != "function") throw new TypeError();
                        var k, l, m = this.length, n = [];
                        for (k = 0; k < m; ++k) if (k in this) {
                            l = this[k];
                            if (i.call(j, l, k, this)) n.push(l);
                        }
                        return n;
                    };
                    h.every = function(i, j) {
                        if (typeof i != "function") throw new TypeError();
                        var k = new Object(this), l = k.length;
                        for (var m = 0; m < l; m++) if (m in k) if (!i.call(j, k[m], m, k)) return false;
                        return true;
                    };
                    h.some = function(i, j) {
                        if (typeof i != "function") throw new TypeError();
                        var k = new Object(this), l = k.length;
                        for (var m = 0; m < l; m++) if (m in k) if (i.call(j, k[m], m, k)) return true;
                        return false;
                    };
                    h.indexOf = function(i, j) {
                        var k = this.length;
                        j |= 0;
                        if (j < 0) j += k;
                        for (;j < k; j++) if (j in this && this[j] === i) return j;
                        return -1;
                    };
                    f.exports = h;
                }, null);
                __d("ES5Date", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.now = function() {
                        return new Date().getTime();
                    };
                    f.exports = h;
                }, null);
                __d("ES5FunctionPrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.bind = function(i) {
                        if (typeof this != "function") throw new TypeError("Bind must be called on a function");
                        var j = this, k = Array.prototype.slice.call(arguments, 1);
                        function l() {
                            return j.apply(i, k.concat(Array.prototype.slice.call(arguments)));
                        }
                        l.displayName = "bound:" + (j.displayName || j.name || "(?)");
                        l.toString = function m() {
                            return "bound: " + j;
                        };
                        return l;
                    };
                    f.exports = h;
                }, null);
                __d("ie8DontEnum", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "prototypeIsEnumerable", "constructor" ], i = {}.hasOwnProperty, j = function() {};
                    if ({
                        toString: true
                    }.propertyIsEnumerable("toString")) j = function(k, l) {
                        for (var m = 0; m < h.length; m++) {
                            var n = h[m];
                            if (i.call(k, n)) l(n);
                        }
                    };
                    f.exports = j;
                }, null);
                __d("ES5Object", [ "ie8DontEnum" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {}.hasOwnProperty, j = {};
                    function k() {}
                    j.create = function(l) {
                        var m = typeof l;
                        if (m != "object" && m != "function") throw new TypeError("Object prototype may only be a Object or null");
                        k.prototype = l;
                        return new k();
                    };
                    j.keys = function(l) {
                        var m = typeof l;
                        if (m != "object" && m != "function" || l === null) throw new TypeError("Object.keys called on non-object");
                        var n = [];
                        for (var o in l) if (i.call(l, o)) n.push(o);
                        h(l, function(p) {
                            return n.push(p);
                        });
                        return n;
                    };
                    f.exports = j;
                }, null);
                __d("ES5StringPrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.trim = function() {
                        if (this == null) throw new TypeError("String.prototype.trim called on null or undefined");
                        return String.prototype.replace.call(this, /^\s+|\s+$/g, "");
                    };
                    h.startsWith = function(i) {
                        var j = String(this);
                        if (this == null) throw new TypeError("String.prototype.startsWith called on null or undefined");
                        var k = arguments.length > 1 ? Number(arguments[1]) : 0;
                        if (isNaN(k)) k = 0;
                        var l = Math.min(Math.max(k, 0), j.length);
                        return j.indexOf(String(i), k) == l;
                    };
                    h.endsWith = function(i) {
                        var j = String(this);
                        if (this == null) throw new TypeError("String.prototype.endsWith called on null or undefined");
                        var k = j.length, l = String(i), m = arguments.length > 1 ? Number(arguments[1]) : k;
                        if (isNaN(m)) m = 0;
                        var n = Math.min(Math.max(m, 0), k), o = n - l.length;
                        if (o < 0) return false;
                        return j.lastIndexOf(l, o) == o;
                    };
                    h.includes = function(i) {
                        if (this == null) throw new TypeError("String.prototype.contains called on null or undefined");
                        var j = String(this), k = arguments.length > 1 ? Number(arguments[1]) : 0;
                        if (isNaN(k)) k = 0;
                        return j.indexOf(String(i), k) != -1;
                    };
                    h.contains = h.includes;
                    h.repeat = function(i) {
                        if (this == null) throw new TypeError("String.prototype.repeat called on null or undefined");
                        var j = String(this), k = i ? Number(i) : 0;
                        if (isNaN(k)) k = 0;
                        if (k < 0 || k === Infinity) throw RangeError();
                        if (k === 1) return j;
                        if (k === 0) return "";
                        var l = "";
                        while (k) {
                            if (k & 1) l += j;
                            if (k >>= 1) j += j;
                        }
                        return l;
                    };
                    f.exports = h;
                }, null);
                __d("ES6Array", [], function a(b, c, d, e, f, g) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        from: function(i) {
                            if (i == null) throw new TypeError("Object is null or undefined");
                            var j = arguments[1], k = arguments[2], l = this, m = Object(i), n = typeof Symbol === "function" ? typeof Symbol === "function" ? Symbol.iterator : "@@iterator" : "@@iterator", o = typeof j === "function", p = typeof m[n] === "function", q = 0, r = void 0, s = void 0;
                            if (p) {
                                r = typeof l === "function" ? new l() : [];
                                var t = m[n](), u = void 0;
                                while (!(u = t.next()).done) {
                                    s = u.value;
                                    if (o) s = j.call(k, s, q);
                                    r[q] = s;
                                    q += 1;
                                }
                                r.length = q;
                                return r;
                            }
                            var v = m.length;
                            if (isNaN(v) || v < 0) v = 0;
                            r = typeof l === "function" ? new l(v) : new Array(v);
                            while (q < v) {
                                s = m[q];
                                if (o) s = j.call(k, s, q);
                                r[q] = s;
                                q += 1;
                            }
                            r.length = q;
                            return r;
                        }
                    };
                    f.exports = h;
                }, null);
                __d("ES6ArrayPrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        find: function(i, j) {
                            if (this == null) throw new TypeError("Array.prototype.find called on null or undefined");
                            if (typeof i !== "function") throw new TypeError("predicate must be a function");
                            var k = h.findIndex.call(this, i, j);
                            return k === -1 ? void 0 : this[k];
                        },
                        findIndex: function(i, j) {
                            if (this == null) throw new TypeError("Array.prototype.findIndex called on null or undefined");
                            if (typeof i !== "function") throw new TypeError("predicate must be a function");
                            var k = Object(this), l = k.length >>> 0;
                            for (var m = 0; m < l; m++) if (i.call(j, k[m], m, k)) return m;
                            return -1;
                        },
                        fill: function(i) {
                            if (this == null) throw new TypeError("Array.prototype.fill called on null or undefined");
                            var j = Object(this), k = j.length >>> 0, l = arguments[1], m = l >> 0, n = m < 0 ? Math.max(k + m, 0) : Math.min(m, k), o = arguments[2], p = o === undefined ? k : o >> 0, q = p < 0 ? Math.max(k + p, 0) : Math.min(p, k);
                            while (n < q) {
                                j[n] = i;
                                n++;
                            }
                            return j;
                        }
                    };
                    f.exports = h;
                }, null);
                __d("ES6DatePrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(j) {
                        return (j < 10 ? "0" : "") + j;
                    }
                    var i = {
                        toISOString: function() {
                            if (!isFinite(this)) throw new Error("Invalid time value");
                            var j = this.getUTCFullYear();
                            j = (j < 0 ? "-" : j > 9999 ? "+" : "") + ("00000" + Math.abs(j)).slice(0 <= j && j <= 9999 ? -4 : -6);
                            return j + "-" + h(this.getUTCMonth() + 1) + "-" + h(this.getUTCDate()) + "T" + h(this.getUTCHours()) + ":" + h(this.getUTCMinutes()) + ":" + h(this.getUTCSeconds()) + "." + (this.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
                        }
                    };
                    f.exports = i;
                }, null);
                __d("ES6Number", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = Math.pow(2, -52), i = Math.pow(2, 53) - 1, j = -1 * i, k = {
                        isFinite: function(l) {
                            return typeof l == "number" && isFinite(l);
                        },
                        isNaN: function(l) {
                            return typeof l == "number" && isNaN(l);
                        },
                        isInteger: function(l) {
                            return this.isFinite(l) && Math.floor(l) === l;
                        },
                        isSafeInteger: function(l) {
                            return this.isFinite(l) && l >= this.MIN_SAFE_INTEGER && l <= this.MAX_SAFE_INTEGER && Math.floor(l) === l;
                        },
                        EPSILON: h,
                        MAX_SAFE_INTEGER: i,
                        MIN_SAFE_INTEGER: j
                    };
                    f.exports = k;
                }, null);
                __d("ES6Object", [ "ie8DontEnum" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {}.hasOwnProperty, j = {
                        assign: function(k) {
                            if (k == null) throw new TypeError("Object.assign target cannot be null or undefined");
                            k = Object(k);
                            for (var l = arguments.length, m = Array(l > 1 ? l - 1 : 0), n = 1; n < l; n++) m[n - 1] = arguments[n];
                            for (var o = 0; o < m.length; o++) {
                                var p = m[o];
                                if (p == null) continue;
                                p = Object(p);
                                for (var q in p) if (i.call(p, q)) k[q] = p[q];
                                h(p, function(r) {
                                    return k[r] = p[r];
                                });
                            }
                            return k;
                        },
                        is: function(k, l) {
                            if (k === l) {
                                return k !== 0 || 1 / k === 1 / l;
                            } else return k !== k && l !== l;
                        }
                    };
                    f.exports = j;
                }, null);
                __d("ES7Object", [ "ie8DontEnum" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {}.hasOwnProperty, j = {};
                    j.entries = function(k) {
                        if (k == null) throw new TypeError("Object.entries called on non-object");
                        var l = [];
                        for (var m in k) if (i.call(k, m)) l.push([ m, k[m] ]);
                        h(k, function(n) {
                            return l.push([ n, k[n] ]);
                        });
                        return l;
                    };
                    j.values = function(k) {
                        if (k == null) throw new TypeError("Object.values called on non-object");
                        var l = [];
                        for (var m in k) if (i.call(k, m)) l.push(k[m]);
                        h(k, function(n) {
                            return l.push(k[n]);
                        });
                        return l;
                    };
                    f.exports = j;
                }, null);
                __d("ES7StringPrototype", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    h.trimLeft = function() {
                        return this.replace(/^\s+/, "");
                    };
                    h.trimRight = function() {
                        return this.replace(/\s+$/, "");
                    };
                    f.exports = h;
                }, null);
                /**
 * @providesModule JSON3
 * @preserve-header
 *
 *! JSON v3.2.3 | http://bestiejs.github.com/json3 | Copyright 2012, Kit Cambridge | http://kit.mit-license.org
 */
                __d("JSON3", [], function a(b, c, d, e, f, g) {
                    c.__markCompiled && c.__markCompiled();
                    (function() {
                        var h = {}.toString, i, j, k, l = f.exports = {}, m = '{"A":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}', n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ba, ca = new Date((-0xc782b5b800cec)), da, ea, fa;
                        try {
                            ca = ca.getUTCFullYear() == -109252 && ca.getUTCMonth() === 0 && ca.getUTCDate() == 1 && ca.getUTCHours() == 10 && ca.getUTCMinutes() == 37 && ca.getUTCSeconds() == 6 && ca.getUTCMilliseconds() == 708;
                        } catch (ga) {}
                        if (!ca) {
                            da = Math.floor;
                            ea = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ];
                            fa = function(ha, ia) {
                                return ea[ia] + 365 * (ha - 1970) + da((ha - 1969 + (ia = +(ia > 1))) / 4) - da((ha - 1901 + ia) / 100) + da((ha - 1601 + ia) / 400);
                            };
                        }
                        if (typeof JSON == "object" && JSON) {
                            l.stringify = JSON.stringify;
                            l.parse = JSON.parse;
                        }
                        if (n = typeof l.stringify == "function" && !fa) {
                            (ca = function() {
                                return 1;
                            }).toJSON = ca;
                            try {
                                n = l.stringify(0) === "0" && l.stringify(new Number()) === "0" && l.stringify(new String()) == '""' && l.stringify(h) === k && l.stringify(k) === k && l.stringify() === k && l.stringify(ca) === "1" && l.stringify([ ca ]) == "[1]" && l.stringify([ k ]) == "[null]" && l.stringify(null) == "null" && l.stringify([ k, h, null ]) == "[null,null,null]" && l.stringify({
                                    result: [ ca, true, false, null, "\0\b\n\f\r\t" ]
                                }) == m && l.stringify(null, ca) === "1" && l.stringify([ 1, 2 ], null, 1) == "[\n 1,\n 2\n]" && l.stringify(new Date((-864e13))) == '"-271821-04-20T00:00:00.000Z"' && l.stringify(new Date(864e13)) == '"+275760-09-13T00:00:00.000Z"' && l.stringify(new Date((-621987552e5))) == '"-000001-01-01T00:00:00.000Z"' && l.stringify(new Date((-1))) == '"1969-12-31T23:59:59.999Z"';
                            } catch (ga) {
                                n = false;
                            }
                        }
                        if (typeof l.parse == "function") try {
                            if (l.parse("0") === 0 && !l.parse(false)) {
                                ca = l.parse(m);
                                if (s = ca.A.length == 5 && ca.A[0] == 1) {
                                    try {
                                        s = !l.parse('"\t"');
                                    } catch (ga) {}
                                    if (s) try {
                                        s = l.parse("01") != 1;
                                    } catch (ga) {}
                                }
                            }
                        } catch (ga) {
                            s = false;
                        }
                        ca = m = null;
                        if (!n || !s) {
                            if (!(i = {}.hasOwnProperty)) i = function(ha) {
                                var ia = {}, ja;
                                if ((ia.__proto__ = null, ia.__proto__ = {
                                    toString: 1
                                }, ia).toString != h) {
                                    i = function(ka) {
                                        var la = this.__proto__, ma = ka in (this.__proto__ = null, this);
                                        this.__proto__ = la;
                                        return ma;
                                    };
                                } else {
                                    ja = ia.constructor;
                                    i = function(ka) {
                                        var la = (this.constructor || ja).prototype;
                                        return ka in this && !(ka in la && this[ka] === la[ka]);
                                    };
                                }
                                ia = null;
                                return i.call(this, ha);
                            };
                            j = function(ha, ia) {
                                var ja = 0, ka, la, ma, na;
                                (ka = function() {
                                    this.valueOf = 0;
                                }).prototype.valueOf = 0;
                                la = new ka();
                                for (ma in la) if (i.call(la, ma)) ja++;
                                ka = la = null;
                                if (!ja) {
                                    la = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ];
                                    na = function(oa, pa) {
                                        var qa = h.call(oa) == "[object Function]", ra, sa;
                                        for (ra in oa) if (!(qa && ra == "prototype") && i.call(oa, ra)) pa(ra);
                                        for (sa = la.length; ra = la[--sa]; i.call(oa, ra) && pa(ra)) ;
                                    };
                                } else if (ja == 2) {
                                    na = function(oa, pa) {
                                        var qa = {}, ra = h.call(oa) == "[object Function]", sa;
                                        for (sa in oa) if (!(ra && sa == "prototype") && !i.call(qa, sa) && (qa[sa] = 1) && i.call(oa, sa)) pa(sa);
                                    };
                                } else na = function(oa, pa) {
                                    var qa = h.call(oa) == "[object Function]", ra, sa;
                                    for (ra in oa) if (!(qa && ra == "prototype") && i.call(oa, ra) && !(sa = ra === "constructor")) pa(ra);
                                    if (sa || i.call(oa, ra = "constructor")) pa(ra);
                                };
                                return na(ha, ia);
                            };
                            if (!n) {
                                o = {
                                    "\\": "\\\\",
                                    '"': '\\"',
                                    "\b": "\\b",
                                    "\f": "\\f",
                                    "\n": "\\n",
                                    "\r": "\\r",
                                    "\t": "\\t"
                                };
                                p = function(ha, ia) {
                                    return ("000000" + (ia || 0)).slice(-ha);
                                };
                                q = function(ha) {
                                    var ia = '"', ja = 0, ka;
                                    for (;ka = ha.charAt(ja); ja++) ia += '\\"\b\f\n\r\t'.indexOf(ka) > -1 ? o[ka] : ka < " " ? "\\u00" + p(2, ka.charCodeAt(0).toString(16)) : ka;
                                    return ia + '"';
                                };
                                r = function(ha, ia, ja, ka, la, ma, na) {
                                    var oa = ia[ha], pa, qa, ra, sa, ta, ua, va, wa, xa, ya, za, ab, bb, cb, db;
                                    if (typeof oa == "object" && oa) {
                                        pa = h.call(oa);
                                        if (pa == "[object Date]" && !i.call(oa, "toJSON")) {
                                            if (oa > -1 / 0 && oa < 1 / 0) {
                                                if (fa) {
                                                    sa = da(oa / 864e5);
                                                    for (qa = da(sa / 365.2425) + 1970 - 1; fa(qa + 1, 0) <= sa; qa++) ;
                                                    for (ra = da((sa - fa(qa, 0)) / 30.42); fa(qa, ra + 1) <= sa; ra++) ;
                                                    sa = 1 + sa - fa(qa, ra);
                                                    ta = (oa % 864e5 + 864e5) % 864e5;
                                                    ua = da(ta / 36e5) % 24;
                                                    va = da(ta / 6e4) % 60;
                                                    wa = da(ta / 1e3) % 60;
                                                    xa = ta % 1e3;
                                                } else {
                                                    qa = oa.getUTCFullYear();
                                                    ra = oa.getUTCMonth();
                                                    sa = oa.getUTCDate();
                                                    ua = oa.getUTCHours();
                                                    va = oa.getUTCMinutes();
                                                    wa = oa.getUTCSeconds();
                                                    xa = oa.getUTCMilliseconds();
                                                }
                                                oa = (qa <= 0 || qa >= 1e4 ? (qa < 0 ? "-" : "+") + p(6, qa < 0 ? -qa : qa) : p(4, qa)) + "-" + p(2, ra + 1) + "-" + p(2, sa) + "T" + p(2, ua) + ":" + p(2, va) + ":" + p(2, wa) + "." + p(3, xa) + "Z";
                                            } else oa = null;
                                        } else if (typeof oa.toJSON == "function" && (pa != "[object Number]" && pa != "[object String]" && pa != "[object Array]" || i.call(oa, "toJSON"))) oa = oa.toJSON(ha);
                                    }
                                    if (ja) oa = ja.call(ia, ha, oa);
                                    if (oa === null) return "null";
                                    pa = h.call(oa);
                                    if (pa == "[object Boolean]") {
                                        return "" + oa;
                                    } else if (pa == "[object Number]") {
                                        return oa > -1 / 0 && oa < 1 / 0 ? "" + oa : "null";
                                    } else if (pa == "[object String]") return q(oa);
                                    if (typeof oa == "object") {
                                        for (bb = na.length; bb--; ) if (na[bb] === oa) throw TypeError();
                                        na.push(oa);
                                        ya = [];
                                        cb = ma;
                                        ma += la;
                                        if (pa == "[object Array]") {
                                            for (ab = 0, bb = oa.length; ab < bb; db || (db = true), ab++) {
                                                za = r(ab, oa, ja, ka, la, ma, na);
                                                ya.push(za === k ? "null" : za);
                                            }
                                            return db ? la ? "[\n" + ma + ya.join(",\n" + ma) + "\n" + cb + "]" : "[" + ya.join(",") + "]" : "[]";
                                        } else {
                                            j(ka || oa, function(eb) {
                                                var fb = r(eb, oa, ja, ka, la, ma, na);
                                                if (fb !== k) ya.push(q(eb) + ":" + (la ? " " : "") + fb);
                                                db || (db = true);
                                            });
                                            return db ? la ? "{\n" + ma + ya.join(",\n" + ma) + "\n" + cb + "}" : "{" + ya.join(",") + "}" : "{}";
                                        }
                                        na.pop();
                                    }
                                };
                                l.stringify = function(ha, ia, ja) {
                                    var ka, la, ma, na, oa, pa;
                                    if (typeof ia == "function" || typeof ia == "object" && ia) if (h.call(ia) == "[object Function]") {
                                        la = ia;
                                    } else if (h.call(ia) == "[object Array]") {
                                        ma = {};
                                        for (na = 0, oa = ia.length; na < oa; pa = ia[na++], (h.call(pa) == "[object String]" || h.call(pa) == "[object Number]") && (ma[pa] = 1)) ;
                                    }
                                    if (ja) if (h.call(ja) == "[object Number]") {
                                        if ((ja -= ja % 1) > 0) for (ka = "", ja > 10 && (ja = 10); ka.length < ja; ka += " ") ;
                                    } else if (h.call(ja) == "[object String]") ka = ja.length <= 10 ? ja : ja.slice(0, 10);
                                    return r("", (pa = {}, pa[""] = ha, pa), la, ma, ka, "", []);
                                };
                            }
                            if (!s) {
                                t = String.fromCharCode;
                                u = {
                                    "\\": "\\",
                                    '"': '"',
                                    "/": "/",
                                    b: "\b",
                                    t: "\t",
                                    n: "\n",
                                    f: "\f",
                                    r: "\r"
                                };
                                v = function() {
                                    aa = ba = null;
                                    throw SyntaxError();
                                };
                                w = function() {
                                    var ha = ba, ia = ha.length, ja, ka, la, ma, na;
                                    while (aa < ia) {
                                        ja = ha.charAt(aa);
                                        if ("\t\r\n ".indexOf(ja) > -1) {
                                            aa++;
                                        } else if ("{}[]:,".indexOf(ja) > -1) {
                                            aa++;
                                            return ja;
                                        } else if (ja == '"') {
                                            for (ka = "@", aa++; aa < ia; ) {
                                                ja = ha.charAt(aa);
                                                if (ja < " ") {
                                                    v();
                                                } else if (ja == "\\") {
                                                    ja = ha.charAt(++aa);
                                                    if ('\\"/btnfr'.indexOf(ja) > -1) {
                                                        ka += u[ja];
                                                        aa++;
                                                    } else if (ja == "u") {
                                                        la = ++aa;
                                                        for (ma = aa + 4; aa < ma; aa++) {
                                                            ja = ha.charAt(aa);
                                                            if (!(ja >= "0" && ja <= "9" || ja >= "a" && ja <= "f" || ja >= "A" && ja <= "F")) v();
                                                        }
                                                        ka += t("0x" + ha.slice(la, aa));
                                                    } else v();
                                                } else {
                                                    if (ja == '"') break;
                                                    ka += ja;
                                                    aa++;
                                                }
                                            }
                                            if (ha.charAt(aa) == '"') {
                                                aa++;
                                                return ka;
                                            }
                                            v();
                                        } else {
                                            la = aa;
                                            if (ja == "-") {
                                                na = true;
                                                ja = ha.charAt(++aa);
                                            }
                                            if (ja >= "0" && ja <= "9") {
                                                if (ja == "0" && (ja = ha.charAt(aa + 1), ja >= "0" && ja <= "9")) v();
                                                na = false;
                                                for (;aa < ia && (ja = ha.charAt(aa), ja >= "0" && ja <= "9"); aa++) ;
                                                if (ha.charAt(aa) == ".") {
                                                    ma = ++aa;
                                                    for (;ma < ia && (ja = ha.charAt(ma), ja >= "0" && ja <= "9"); ma++) ;
                                                    if (ma == aa) v();
                                                    aa = ma;
                                                }
                                                ja = ha.charAt(aa);
                                                if (ja == "e" || ja == "E") {
                                                    ja = ha.charAt(++aa);
                                                    if (ja == "+" || ja == "-") aa++;
                                                    for (ma = aa; ma < ia && (ja = ha.charAt(ma), ja >= "0" && ja <= "9"); ma++) ;
                                                    if (ma == aa) v();
                                                    aa = ma;
                                                }
                                                return +ha.slice(la, aa);
                                            }
                                            if (na) v();
                                            if (ha.slice(aa, aa + 4) == "true") {
                                                aa += 4;
                                                return true;
                                            } else if (ha.slice(aa, aa + 5) == "false") {
                                                aa += 5;
                                                return false;
                                            } else if (ha.slice(aa, aa + 4) == "null") {
                                                aa += 4;
                                                return null;
                                            }
                                            v();
                                        }
                                    }
                                    return "$";
                                };
                                x = function(ha) {
                                    var ia, ja, ka;
                                    if (ha == "$") v();
                                    if (typeof ha == "string") {
                                        if (ha.charAt(0) == "@") return ha.slice(1);
                                        if (ha == "[") {
                                            ia = [];
                                            for (;;ja || (ja = true)) {
                                                ha = w();
                                                if (ha == "]") break;
                                                if (ja) if (ha == ",") {
                                                    ha = w();
                                                    if (ha == "]") v();
                                                } else v();
                                                if (ha == ",") v();
                                                ia.push(x(ha));
                                            }
                                            return ia;
                                        } else if (ha == "{") {
                                            ia = {};
                                            for (;;ja || (ja = true)) {
                                                ha = w();
                                                if (ha == "}") break;
                                                if (ja) if (ha == ",") {
                                                    ha = w();
                                                    if (ha == "}") v();
                                                } else v();
                                                if (ha == "," || typeof ha != "string" || ha.charAt(0) != "@" || w() != ":") v();
                                                ia[ha.slice(1)] = x(w());
                                            }
                                            return ia;
                                        }
                                        v();
                                    }
                                    return ha;
                                };
                                z = function(ha, ia, ja) {
                                    var ka = y(ha, ia, ja);
                                    if (ka === k) {
                                        delete ha[ia];
                                    } else ha[ia] = ka;
                                };
                                y = function(ha, ia, ja) {
                                    var ka = ha[ia], la;
                                    if (typeof ka == "object" && ka) if (h.call(ka) == "[object Array]") {
                                        for (la = ka.length; la--; ) z(ka, la, ja);
                                    } else j(ka, function(ma) {
                                        z(ka, ma, ja);
                                    });
                                    return ja.call(ha, ia, ka);
                                };
                                l.parse = function(ha, ia) {
                                    aa = 0;
                                    ba = ha;
                                    var ja = x(w());
                                    if (w() != "$") v();
                                    aa = ba = null;
                                    return ia && h.call(ia) == "[object Function]" ? y((ca = {}, ca[""] = ja, ca), "", ia) : ja;
                                };
                            }
                        }
                    }).call(this);
                }, null);
                __d("ES", [ "ES5ArrayPrototype", "ES5FunctionPrototype", "ES5StringPrototype", "ES5Array", "ES5Object", "ES5Date", "JSON3", "ES6Array", "ES6Object", "ES6ArrayPrototype", "ES6DatePrototype", "ES6Number", "ES7StringPrototype", "ES7Object" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
                    if (c.__markCompiled) c.__markCompiled();
                    var v = {}.toString, w = {
                        "JSON.stringify": n.stringify,
                        "JSON.parse": n.parse
                    }, x = {
                        "Array.prototype": h,
                        "Function.prototype": i,
                        "String.prototype": j,
                        Object: l,
                        Array: k,
                        Date: m
                    }, y = {
                        Object: p,
                        "Array.prototype": q,
                        "Date.prototype": r,
                        Number: s,
                        Array: o
                    }, z = {
                        Object: u,
                        "String.prototype": t
                    };
                    function aa(ca) {
                        for (var da in ca) {
                            if (!ca.hasOwnProperty(da)) continue;
                            var ea = ca[da], fa = da.split("."), ga = fa.length == 2 ? window[fa[0]][fa[1]] : window[da];
                            for (var ha in ea) {
                                if (!ea.hasOwnProperty(ha)) continue;
                                if (typeof ea[ha] !== "function") {
                                    w[da + "." + ha] = ea[ha];
                                    continue;
                                }
                                var ia = ga[ha];
                                w[da + "." + ha] = ia && /\{\s+\[native code\]\s\}/.test(ia) ? ia : ea[ha];
                            }
                        }
                    }
                    aa(x);
                    aa(y);
                    aa(z);
                    function ba(ca, da, ea) {
                        var fa = ea ? v.call(ca).slice(8, -1) + ".prototype" : ca, ga = w[fa + "." + da] || ca[da];
                        if (typeof ga === "function") {
                            for (var ha = arguments.length, ia = Array(ha > 3 ? ha - 3 : 0), ja = 3; ja < ha; ja++) ia[ja - 3] = arguments[ja];
                            return ga.apply(ca, ia);
                        } else if (ga) return ga;
                        throw new Error("Polyfill " + fa + " does not have implementation of " + da);
                    }
                    f.exports = ba;
                }, null);
                __d("sdk.babelHelpers", [ "ES5FunctionPrototype", "ES5Object", "ES6Object" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = {}, l = Object.prototype.hasOwnProperty;
                    k.inherits = function(m, n) {
                        j.assign(m, n);
                        m.prototype = i.create(n && n.prototype);
                        m.prototype.constructor = m;
                        m.__superConstructor__ = n;
                        return n;
                    };
                    k._extends = j.assign;
                    k["extends"] = k._extends;
                    k.objectWithoutProperties = function(m, n) {
                        var o = {};
                        for (var p in m) {
                            if (!l.call(m, p) || n.indexOf(p) >= 0) continue;
                            o[p] = m[p];
                        }
                        return o;
                    };
                    k.taggedTemplateLiteralLoose = function(m, n) {
                        m.raw = n;
                        return m;
                    };
                    k.bind = h.bind;
                    f.exports = k;
                }, null);
                var ES = require("ES");
                var babelHelpers = require("sdk.babelHelpers");
                __d("UrlMapConfig", [], {
                    www: "www.facebook.com",
                    m: "m.facebook.com",
                    connect: "connect.facebook.net",
                    business: "business.facebook.com",
                    api_https: "api.facebook.com",
                    api_read_https: "api-read.facebook.com",
                    graph_https: "graph.facebook.com",
                    an_https: "an.facebook.com",
                    fbcdn_http: "fbstatic-a.akamaihd.net",
                    fbcdn_https: "fbstatic-a.akamaihd.net",
                    cdn_http: "staticxx.facebook.com",
                    cdn_https: "staticxx.facebook.com"
                });
                __d("JSSDKRuntimeConfig", [], {
                    locale: "en_GB",
                    rtl: false,
                    revision: "2425895"
                });
                __d("JSSDKConfig", [], {
                    bustCache: true,
                    tagCountLogRate: .01,
                    errorHandling: {
                        rate: 4
                    },
                    usePluginPipe: true,
                    features: {
                        dialog_resize_refactor: true,
                        one_comment_controller: true,
                        allow_non_canvas_app_events: false,
                        event_subscriptions_log: {
                            rate: .01,
                            value: 1e4
                        },
                        should_force_single_dialog_instance: true,
                        js_sdk_force_status_on_load: true,
                        kill_fragment: true,
                        xfbml_profile_pic_server: true,
                        error_handling: {
                            rate: 4
                        },
                        e2e_ping_tracking: {
                            rate: 1e-6
                        },
                        getloginstatus_tracking: {
                            rate: .001
                        },
                        xd_timeout: {
                            rate: 4,
                            value: 3e4
                        },
                        use_bundle: false,
                        launch_payment_dialog_via_pac: {
                            rate: 100
                        },
                        plugin_tags_blacklist: [ "recommendations_bar", "registration", "activity", "recommendations", "facepile" ],
                        should_log_response_error: true
                    },
                    api: {
                        mode: "warn",
                        whitelist: [ "AppEvents", "AppEvents.EventNames", "AppEvents.ParameterNames", "AppEvents.activateApp", "AppEvents.logEvent", "AppEvents.logPurchase", "Canvas", "Canvas.Prefetcher", "Canvas.Prefetcher.addStaticResource", "Canvas.Prefetcher.setCollectionMode", "Canvas.getPageInfo", "Canvas.hideFlashElement", "Canvas.scrollTo", "Canvas.setAutoGrow", "Canvas.setDoneLoading", "Canvas.setSize", "Canvas.setUrlHandler", "Canvas.showFlashElement", "Canvas.startTimer", "Canvas.stopTimer", "Event", "Event.subscribe", "Event.unsubscribe", "Music.flashCallback", "Music.init", "Music.send", "Payment", "Payment.cancelFlow", "Payment.continueFlow", "Payment.init", "Payment.lockForProcessing", "Payment.parse", "Payment.setSize", "Payment.unlockForProcessing", "ThirdPartyProvider", "ThirdPartyProvider.init", "ThirdPartyProvider.sendData", "UA", "UA.nativeApp", "XFBML", "XFBML.RecommendationsBar", "XFBML.RecommendationsBar.markRead", "XFBML.parse", "addFriend", "api", "getAccessToken", "getAuthResponse", "getLoginStatus", "getUserID", "init", "login", "logout", "publish", "share", "ui" ]
                    },
                    initSitevars: {
                        enableMobileComments: 1,
                        iframePermissions: {
                            read_stream: false,
                            manage_mailbox: false,
                            manage_friendlists: false,
                            read_mailbox: false,
                            publish_checkins: true,
                            status_update: true,
                            photo_upload: true,
                            video_upload: true,
                            sms: false,
                            create_event: true,
                            rsvp_event: true,
                            offline_access: true,
                            email: true,
                            xmpp_login: false,
                            create_note: true,
                            share_item: true,
                            export_stream: false,
                            publish_stream: true,
                            publish_likes: true,
                            ads_management: false,
                            contact_email: true,
                            access_private_data: false,
                            read_insights: false,
                            read_requests: false,
                            read_friendlists: true,
                            manage_pages: false,
                            physical_login: false,
                            manage_groups: false,
                            read_deals: false
                        }
                    }
                });
                __d("JSSDKXDConfig", [], {
                    XdUrl: "/connect/xd_arbiter.php?version=42",
                    XdBundleUrl: "/connect/xd_arbiter/r/bz-D0tzmBsw.js?version=42",
                    Flash: {
                        path: "https://connect.facebook.net/rsrc.php/v1/yW/r/yOZN1vHw3Z_.swf"
                    },
                    useCdn: true
                });
                __d("JSSDKCssConfig", [], {
                    rules: '.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}.fb_link img{border:none}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}\n.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_reset .fb_dialog_legacy{overflow:visible}.fb_dialog_advanced{padding:10px;-moz-border-radius:8px;-webkit-border-radius:8px;border-radius:8px}.fb_dialog_content{background:#fff;color:#333}.fb_dialog_close_icon{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif);cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{top:5px;left:5px;right:auto}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_close_icon:active{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v2/yL/r/s816eWC-2sl.gif)}.fb_dialog_loader{background-color:#f6f7f9;border:1px solid #606060;font-size:24px;padding:20px}.fb_dialog_top_left,.fb_dialog_top_right,.fb_dialog_bottom_left,.fb_dialog_bottom_right{height:10px;width:10px;overflow:hidden;position:absolute}.fb_dialog_top_left{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 0;left:-10px;top:-10px}.fb_dialog_top_right{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -10px;right:-10px;top:-10px}.fb_dialog_bottom_left{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -20px;bottom:-10px;left:-10px}.fb_dialog_bottom_right{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/ye/r/8YeTNIlTZjm.png) no-repeat 0 -30px;right:-10px;bottom:-10px}.fb_dialog_vert_left,.fb_dialog_vert_right,.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{position:absolute;background:#525252;filter:alpha(opacity=70);opacity:.7}.fb_dialog_vert_left,.fb_dialog_vert_right{width:10px;height:100%}.fb_dialog_vert_left{margin-left:-10px}.fb_dialog_vert_right{right:0;margin-right:-10px}.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{width:100%;height:10px}.fb_dialog_horiz_top{margin-top:-10px}.fb_dialog_horiz_bottom{bottom:0;margin-bottom:-10px}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{-webkit-transform:none;height:100%;margin:0;overflow:visible;position:absolute;top:-10000px;left:0;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{width:auto;height:auto;min-height:initial;min-width:initial;background:none}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{color:#fff;display:block;padding-top:20px;clear:both;font-size:18px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .45);position:absolute;bottom:0;left:0;right:0;top:0;width:100%;min-height:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_content .dialog_header{-webkit-box-shadow:white 0 1px 1px -1px inset;background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#738ABA), to(#2C4987));border-bottom:1px solid;border-color:#1d4088;color:#fff;font:14px Helvetica, sans-serif;font-weight:bold;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{-webkit-font-smoothing:subpixel-antialiased;height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#4966A6), color-stop(.5, #355492), to(#2A4887));border:1px solid #29487d;-webkit-background-clip:padding-box;-webkit-border-radius:3px;-webkit-box-shadow:rgba(0, 0, 0, .117188) 0 1px 1px inset, rgba(255, 255, 255, .167969) 0 1px 0;display:inline-block;margin-top:3px;max-width:85px;line-height:18px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{border:none;background:none;color:#fff;font:12px Helvetica, sans-serif;font-weight:bold;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #555;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f6f7f9;border:1px solid #555;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://static.xx.fbcdn.net/rsrc.php/v2/yD/r/t-wz8gw1xG1.png);background-repeat:no-repeat;background-position:50% 50%;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_hide_iframes iframe{position:relative;left:-10000px}.fb_iframe_widget_loader{position:relative;display:inline-block}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}.fb_iframe_widget_loader iframe{min-height:32px;z-index:2;zoom:1}.fb_iframe_widget_loader .FB_Loader{background:url(https://static.xx.fbcdn.net/rsrc.php/v2/y9/r/jKEcVPZFk-2.gif) no-repeat;height:32px;width:32px;margin-left:-16px;position:absolute;left:50%;z-index:4}',
                    components: [ "css:fb.css.base", "css:fb.css.dialog", "css:fb.css.iframewidget" ]
                });
                __d("ApiClientConfig", [], {
                    FlashRequest: {
                        swfUrl: "https://connect.facebook.net/rsrc.php/v1/yd/r/mxzow1Sdmxr.swf"
                    }
                });
                __d("JSSDKCanvasPrefetcherConfig", [], {
                    blacklist: [ 0x83d70a64a992, 768691303149786 ],
                    sampleRate: 500
                });
                __d("DOMWrapper", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h, i, j = {
                        setRoot: function(k) {
                            h = k;
                        },
                        getRoot: function() {
                            return h || document.body;
                        },
                        setWindow: function(k) {
                            i = k;
                        },
                        getWindow: function() {
                            return i || self;
                        }
                    };
                    f.exports = j;
                }, null);
                __d("dotAccess", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i, j, k) {
                        var l = j.split(".");
                        do {
                            var m = l.shift();
                            i = i[m] || k && (i[m] = {});
                        } while (l.length && i);
                        return i;
                    }
                    f.exports = h;
                }, null);
                __d("guid", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h() {
                        return "f" + (Math.random() * (1 << 30)).toString(16).replace(".", "");
                    }
                    f.exports = h;
                }, null);
                __d("wrapFunction", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {}, i = function j(k, l, m) {
                        var n = l || "default";
                        return function() {
                            var o = n in h ? h[n](k, m) : k;
                            return o.apply(this, arguments);
                        };
                    };
                    i.setWrapper = function(j) {
                        var k = arguments.length <= 1 || arguments[1] === undefined ? "default" : arguments[1];
                        h[k] = j;
                    };
                    f.exports = i;
                }, null);
                __d("GlobalCallback", [ "DOMWrapper", "dotAccess", "guid", "wrapFunction" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    var l, m, n = {
                        setPrefix: function(o) {
                            l = i(h.getWindow(), o, true);
                            m = o;
                        },
                        create: function(o, p) {
                            if (!l) this.setPrefix("__globalCallbacks");
                            var q = j();
                            l[q] = k(o, "entry", p || "GlobalCallback");
                            return m + "." + q;
                        },
                        remove: function(o) {
                            var p = o.substring(m.length + 1);
                            delete l[p];
                        }
                    };
                    f.exports = n;
                }, null);
                __d("sprintf", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        for (var j = arguments.length, k = Array(j > 1 ? j - 1 : 0), l = 1; l < j; l++) k[l - 1] = arguments[l];
                        var m = 0;
                        return i.replace(/%s/g, function(n) {
                            return k[m++];
                        });
                    }
                    f.exports = h;
                }, null);
                __d("Log", [ "sprintf" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {
                        DEBUG: 3,
                        INFO: 2,
                        WARNING: 1,
                        ERROR: 0
                    };
                    function j(l, m) {
                        var n = Array.prototype.slice.call(arguments, 2), o = h.apply(null, n), p = window.console;
                        if (p && k.level >= m) p[l in p ? l : "log"](o);
                    }
                    var k = {
                        level: -1,
                        Level: i,
                        debug: ES(j, "bind", true, null, "debug", i.DEBUG),
                        info: ES(j, "bind", true, null, "info", i.INFO),
                        warn: ES(j, "bind", true, null, "warn", i.WARNING),
                        error: ES(j, "bind", true, null, "error", i.ERROR)
                    };
                    f.exports = k;
                }, null);
                __d("ObservableMixin", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h() {
                        this.__observableEvents = {};
                    }
                    h.prototype = {
                        inform: function(i) {
                            var j = Array.prototype.slice.call(arguments, 1), k = Array.prototype.slice.call(this.getSubscribers(i));
                            for (var l = 0; l < k.length; l++) {
                                if (k[l] === null) continue;
                                try {
                                    k[l].apply(this, j);
                                } catch (m) {
                                    setTimeout(function() {
                                        throw m;
                                    }, 0);
                                }
                            }
                            return this;
                        },
                        getSubscribers: function(i) {
                            return this.__observableEvents[i] || (this.__observableEvents[i] = []);
                        },
                        clearSubscribers: function(i) {
                            if (i) this.__observableEvents[i] = [];
                            return this;
                        },
                        clearAllSubscribers: function() {
                            this.__observableEvents = {};
                            return this;
                        },
                        subscribe: function(i, j) {
                            var k = this.getSubscribers(i);
                            k.push(j);
                            return this;
                        },
                        unsubscribe: function(i, j) {
                            var k = this.getSubscribers(i);
                            for (var l = 0; l < k.length; l++) if (k[l] === j) {
                                k.splice(l, 1);
                                break;
                            }
                            return this;
                        },
                        monitor: function(i, j) {
                            if (!j()) {
                                var k = ES(function(l) {
                                    if (j.apply(j, arguments)) this.unsubscribe(i, k);
                                }, "bind", true, this);
                                this.subscribe(i, k);
                            }
                            return this;
                        }
                    };
                    f.exports = h;
                }, null);
                __d("UrlMap", [ "UrlMapConfig" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {
                        resolve: function(j, k) {
                            var l = typeof k == "undefined" ? location.protocol.replace(":", "") : k ? "https" : "http";
                            if (j in h) return l + "://" + h[j];
                            if (typeof k == "undefined" && j + "_" + l in h) return l + "://" + h[j + "_" + l];
                            if (k !== true && j + "_http" in h) return "http://" + h[j + "_http"];
                            if (k !== false && j + "_https" in h) return "https://" + h[j + "_https"];
                        }
                    };
                    f.exports = i;
                }, null);
                __d("QueryString", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(l) {
                        var m = [];
                        ES(ES("Object", "keys", false, l).sort(), "forEach", true, function(n) {
                            var o = l[n];
                            if (typeof o === "undefined") return;
                            if (o === null) {
                                m.push(n);
                                return;
                            }
                            m.push(encodeURIComponent(n) + "=" + encodeURIComponent(o));
                        });
                        return m.join("&");
                    }
                    function i(l, m) {
                        var n = {};
                        if (l === "") return n;
                        var o = l.split("&");
                        for (var p = 0; p < o.length; p++) {
                            var q = o[p].split("=", 2), r = decodeURIComponent(q[0]);
                            if (m && n.hasOwnProperty(r)) throw new URIError("Duplicate key: " + r);
                            n[r] = q.length === 2 ? decodeURIComponent(q[1]) : null;
                        }
                        return n;
                    }
                    function j(l, m) {
                        return l + (ES(l, "indexOf", true, "?") !== -1 ? "&" : "?") + (typeof m === "string" ? m : k.encode(m));
                    }
                    var k = {
                        encode: h,
                        decode: i,
                        appendToUrl: j
                    };
                    f.exports = k;
                }, null);
                __d("ManagedError", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i, j) {
                        Error.prototype.constructor.call(this, i);
                        this.message = i;
                        this.innerError = j;
                    }
                    h.prototype = new Error();
                    h.prototype.constructor = h;
                    f.exports = h;
                }, null);
                __d("AssertionError", [ "ManagedError" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j) {
                        h.prototype.constructor.apply(this, arguments);
                    }
                    i.prototype = new h();
                    i.prototype.constructor = i;
                    f.exports = i;
                }, null);
                __d("Assert", [ "AssertionError", "sprintf" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    function j(o, p) {
                        if (typeof o !== "boolean" || !o) throw new h(p);
                        return o;
                    }
                    function k(o, p, q) {
                        var r;
                        if (p === undefined) {
                            r = "undefined";
                        } else if (p === null) {
                            r = "null";
                        } else {
                            var s = Object.prototype.toString.call(p);
                            r = /\s(\w*)/.exec(s)[1].toLowerCase();
                        }
                        j(ES(o, "indexOf", true, r) !== -1, q || i("Expression is of type %s, not %s", r, o));
                        return p;
                    }
                    function l(o, p, q) {
                        j(p instanceof o, q || "Expression not instance of type");
                        return p;
                    }
                    function m(o, p) {
                        n["is" + o] = p;
                        n["maybe" + o] = function(q, r) {
                            if (q != null) p(q, r);
                        };
                    }
                    var n = {
                        isInstanceOf: l,
                        isTrue: j,
                        isTruthy: function(o, p) {
                            return j(!!o, p);
                        },
                        type: k,
                        define: function(o, p) {
                            o = o.substring(0, 1).toUpperCase() + o.substring(1).toLowerCase();
                            m(o, function(q, r) {
                                j(p(q), r);
                            });
                        }
                    };
                    ES([ "Array", "Boolean", "Date", "Function", "Null", "Number", "Object", "Regexp", "String", "Undefined" ], "forEach", true, function(o) {
                        m(o, ES(k, "bind", true, null, o.toLowerCase()));
                    });
                    f.exports = n;
                }, null);
                __d("Type", [ "Assert" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i() {
                        var m = this.__mixins;
                        if (m) for (var n = 0; n < m.length; n++) m[n].apply(this, arguments);
                    }
                    function j(m, n) {
                        if (n instanceof m) return true;
                        if (n instanceof i) for (var o = 0; o < n.__mixins.length; o++) if (n.__mixins[o] == m) return true;
                        return false;
                    }
                    function k(m, n) {
                        var o = m.prototype;
                        if (!ES("Array", "isArray", false, n)) n = [ n ];
                        for (var p = 0; p < n.length; p++) {
                            var q = n[p];
                            if (typeof q == "function") {
                                o.__mixins.push(q);
                                q = q.prototype;
                            }
                            ES(ES("Object", "keys", false, q), "forEach", true, function(r) {
                                o[r] = q[r];
                            });
                        }
                    }
                    function l(m, n, o) {
                        var p = n && n.hasOwnProperty("constructor") ? n.constructor : function() {
                            this.parent.apply(this, arguments);
                        };
                        h.isFunction(p);
                        if (m && m.prototype instanceof i === false) throw new Error("parent type does not inherit from Type");
                        m = m || i;
                        function q() {}
                        q.prototype = m.prototype;
                        p.prototype = new q();
                        if (n) ES("Object", "assign", false, p.prototype, n);
                        p.prototype.constructor = p;
                        p.parent = m;
                        p.prototype.__mixins = m.prototype.__mixins ? Array.prototype.slice.call(m.prototype.__mixins) : [];
                        if (o) k(p, o);
                        p.prototype.parent = function() {
                            this.parent = m.prototype.parent;
                            m.apply(this, arguments);
                        };
                        p.prototype.parentCall = function(r) {
                            return m.prototype[r].apply(this, Array.prototype.slice.call(arguments, 1));
                        };
                        p.extend = function(r, s) {
                            return l(this, r, s);
                        };
                        return p;
                    }
                    ES("Object", "assign", false, i.prototype, {
                        instanceOf: function(m) {
                            return j(m, this);
                        }
                    });
                    ES("Object", "assign", false, i, {
                        extend: function(m, n) {
                            return typeof m === "function" ? l.apply(null, arguments) : l(null, m, n);
                        },
                        instanceOf: j
                    });
                    f.exports = i;
                }, null);
                __d("sdk.Model", [ "Type", "ObservableMixin" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = h.extend({
                        constructor: function(k) {
                            this.parent();
                            var l = {}, m = this;
                            ES(ES("Object", "keys", false, k), "forEach", true, function(n) {
                                l[n] = k[n];
                                m["set" + n] = function(o) {
                                    if (o === l[n]) return this;
                                    l[n] = o;
                                    m.inform(n + ".change", o);
                                    return m;
                                };
                                m["get" + n] = function() {
                                    return l[n];
                                };
                            });
                        }
                    }, i);
                    f.exports = j;
                }, null);
                __d("sdk.Runtime", [ "sdk.Model", "JSSDKRuntimeConfig" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = {
                        UNKNOWN: 0,
                        PAGETAB: 1,
                        CANVAS: 2,
                        PLATFORM: 4
                    }, k = new h({
                        AccessToken: "",
                        ClientID: "",
                        CookieUserID: "",
                        Environment: j.UNKNOWN,
                        Initialized: false,
                        IsVersioned: false,
                        KidDirectedSite: undefined,
                        Locale: i.locale,
                        LoggedIntoFacebook: undefined,
                        LoginStatus: undefined,
                        Revision: i.revision,
                        Rtl: i.rtl,
                        Scope: undefined,
                        Secure: undefined,
                        UseCookie: false,
                        UserID: "",
                        Version: undefined
                    });
                    ES("Object", "assign", false, k, {
                        ENVIRONMENTS: j,
                        isEnvironment: function(l) {
                            var m = this.getEnvironment();
                            return (l | m) === m;
                        },
                        isCanvasEnvironment: function() {
                            return this.isEnvironment(j.CANVAS) || this.isEnvironment(j.PAGETAB);
                        }
                    });
                    (function() {
                        var l = /app_runner/.test(window.name) ? j.PAGETAB : /iframe_canvas/.test(window.name) ? j.CANVAS : j.UNKNOWN;
                        if ((l | j.PAGETAB) === l) l = l | j.CANVAS;
                        k.setEnvironment(l);
                    })();
                    f.exports = k;
                }, null);
                __d("sdk.Cookie", [ "QueryString", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = null;
                    function k(n, o, p) {
                        n = n + i.getClientID();
                        var q = j && j !== ".";
                        if (q) {
                            document.cookie = n + "=; expires=Wed, 04 Feb 2004 08:00:00 GMT;";
                            document.cookie = n + "=; expires=Wed, 04 Feb 2004 08:00:00 GMT;" + "domain=" + location.hostname + ";";
                        }
                        var r = new Date(p).toGMTString();
                        document.cookie = n + "=" + o + (o && p === 0 ? "" : "; expires=" + r) + "; path=/" + (q ? "; domain=" + j : "");
                    }
                    function l(n) {
                        n = n + i.getClientID();
                        var o = new RegExp("\\b" + n + "=([^;]*)\\b");
                        return o.test(document.cookie) ? RegExp.$1 : null;
                    }
                    var m = {
                        setDomain: function(n) {
                            j = n;
                            var o = h.encode({
                                base_domain: j && j !== "." ? j : ""
                            }), p = new Date();
                            p.setFullYear(p.getFullYear() + 1);
                            k("fbm_", o, p.getTime());
                        },
                        getDomain: function() {
                            return j;
                        },
                        loadMeta: function() {
                            var n = l("fbm_");
                            if (n) {
                                var o = h.decode(n);
                                if (!j) j = o.base_domain;
                                return o;
                            }
                        },
                        loadSignedRequest: function() {
                            return l("fbsr_");
                        },
                        setSignedRequestCookie: function(n, o) {
                            if (!n) throw new Error("Value passed to Cookie.setSignedRequestCookie " + "was empty.");
                            k("fbsr_", n, o);
                        },
                        clearSignedRequestCookie: function() {
                            k("fbsr_", "", 0);
                        },
                        setRaw: k,
                        getRaw: l
                    };
                    f.exports = m;
                }, null);
                __d("Miny", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = "Miny1", i = "wxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_".split(""), j = {
                        encode: function(k) {
                            if (/^$|[~\\]|__proto__/.test(k)) return k;
                            var l = k.match(/\w+|\W+/g), m, n = ES("Object", "create", false, null);
                            for (m = 0; m < l.length; m++) n[l[m]] = (n[l[m]] || 0) + 1;
                            var o = ES("Object", "keys", false, n);
                            o.sort(function(r, s) {
                                return n[s] - n[r];
                            });
                            for (m = 0; m < o.length; m++) {
                                var p = (m - m % 32) / 32;
                                n[o[m]] = p ? p.toString(32) + i[m % 32] : i[m % 32];
                            }
                            var q = "";
                            for (m = 0; m < l.length; m++) q += n[l[m]];
                            o.unshift(h, o.length);
                            o.push(q);
                            return o.join("~");
                        }
                    };
                    f.exports = j;
                }, null);
                __d("sdk.UA", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = navigator.userAgent, i = {
                        iphone: /\b(iPhone|iP[ao]d)/.test(h),
                        ipad: /\b(iP[ao]d)/.test(h),
                        android: /Android/i.test(h),
                        nativeApp: /FBAN\/\w+;/i.test(h)
                    }, j = /Mobile/i.test(h), k = {
                        ie: "",
                        firefox: "",
                        chrome: "",
                        webkit: "",
                        osx: "",
                        edge: "",
                        operaMini: "",
                        ucWeb: ""
                    }, l = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(h);
                    if (l) {
                        k.ie = l[1] ? parseFloat(l[1]) : l[4] ? parseFloat(l[4]) : "";
                        k.firefox = l[2] || "";
                        k.webkit = l[3] || "";
                        if (l[3]) {
                            var m = /(?:Chrome\/(\d+\.\d+))/.exec(h);
                            k.chrome = m ? m[1] : "";
                            var n = /(?:Edge\/(\d+\.\d+))/.exec(h);
                            k.edge = n ? n[1] : "";
                        }
                    }
                    var o = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(h);
                    if (o) k.osx = o[1];
                    var p = /(?:Opera Mini\/(\d+(?:\.\d+)?))/.exec(h);
                    if (p) k.operaMini = p[1];
                    var q = /(?:UCWEB\/(\d+(?:\.\d+))?)/.exec(h);
                    if (q) k.ucWeb = q[1] || "2.0";
                    function r(t) {
                        return ES(t.split("."), "map", true, function(u) {
                            return parseFloat(u);
                        });
                    }
                    var s = {};
                    ES(ES("Object", "keys", false, k), "map", true, function(t) {
                        s[t] = function() {
                            return parseFloat(k[t]);
                        };
                        s[t].getVersionParts = function() {
                            return r(k[t]);
                        };
                    });
                    ES(ES("Object", "keys", false, i), "map", true, function(t) {
                        s[t] = function() {
                            return i[t];
                        };
                    });
                    s.mobile = function() {
                        return i.iphone || i.ipad || i.android || j;
                    };
                    s.mTouch = function() {
                        return i.android || i.iphone || i.ipad;
                    };
                    s.mBasic = function() {
                        return !!(k.ucWeb || k.operaMini);
                    };
                    f.exports = s;
                }, null);
                __d("getBlankIframeSrc", [ "sdk.UA" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i() {
                        return h.ie() < 10 ? "javascript:false" : "about:blank";
                    }
                    f.exports = i;
                }, null);
                __d("insertIframe", [ "GlobalCallback", "getBlankIframeSrc", "guid" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    function k(l) {
                        l.id = l.id || j();
                        l.name = l.name || j();
                        var m = false, n = false, o = function() {
                            if (m && !n) {
                                n = true;
                                l.onload && l.onload(l.root.firstChild);
                            }
                        }, p = h.create(o);
                        if (document.attachEvent) {
                            var q = "<iframe" + ' id="' + l.id + '"' + ' name="' + l.name + '"' + (l.title ? ' title="' + l.title + '"' : "") + (l.className ? ' class="' + l.className + '"' : "") + ' style="border:none;' + (l.width ? "width:" + l.width + "px;" : "") + (l.height ? "height:" + l.height + "px;" : "") + '"' + ' src="' + i() + '"' + ' frameborder="0"' + ' scrolling="no"' + ' allowtransparency="true"' + ' onload="' + p + '()"' + "></iframe>";
                            l.root.innerHTML = '<iframe src="' + i() + '"' + ' frameborder="0"' + ' scrolling="no"' + ' style="height:1px"></iframe>';
                            m = true;
                            setTimeout(function() {
                                l.root.innerHTML = q;
                                l.root.firstChild.src = l.url;
                                l.onInsert && l.onInsert(l.root.firstChild);
                            }, 0);
                        } else {
                            var r = document.createElement("iframe");
                            r.id = l.id;
                            r.name = l.name;
                            r.onload = o;
                            r.scrolling = "no";
                            r.style.border = "none";
                            r.style.overflow = "hidden";
                            if (l.title) r.title = l.title;
                            if (l.className) r.className = l.className;
                            if (l.height !== undefined) r.style.height = l.height + "px";
                            if (l.width !== undefined) if (l.width == "100%") {
                                r.style.width = l.width;
                            } else r.style.width = l.width + "px";
                            l.root.appendChild(r);
                            m = true;
                            r.src = l.url;
                            l.onInsert && l.onInsert(r);
                        }
                    }
                    f.exports = k;
                }, null);
                __d("sdk.domReady", [ "sdk.Runtime" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i, j = "readyState" in document ? /loaded|complete/.test(document.readyState) : !!document.body;
                    function k() {
                        if (!i) return;
                        var n;
                        while (n = i.shift()) n();
                        i = null;
                    }
                    function l(n) {
                        if (i) {
                            i.push(n);
                            return;
                        } else n();
                    }
                    if (!j) {
                        i = [];
                        if (document.addEventListener) {
                            document.addEventListener("DOMContentLoaded", k, false);
                            window.addEventListener("load", k, false);
                        } else if (document.attachEvent) {
                            document.attachEvent("onreadystatechange", k);
                            window.attachEvent("onload", k);
                        }
                        if (document.documentElement.doScroll && window == window.top) {
                            var m = function() {
                                try {
                                    h.getRtl() ? document.documentElement.doScroll("right") : document.documentElement.doScroll("left");
                                } catch (n) {
                                    setTimeout(m, 0);
                                    return;
                                }
                                k();
                            };
                            m();
                        }
                    }
                    f.exports = l;
                }, 3);
                __d("sdk.Content", [ "Log", "sdk.UA", "sdk.domReady" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k, l, m = {
                        append: function(n, o) {
                            if (!o) if (!k) {
                                k = o = document.getElementById("fb-root");
                                if (!o) {
                                    h.warn('The "fb-root" div has not been created, auto-creating');
                                    k = o = document.createElement("div");
                                    o.id = "fb-root";
                                    if (i.ie() || !document.body) {
                                        j(function() {
                                            document.body.appendChild(o);
                                        });
                                    } else document.body.appendChild(o);
                                }
                                o.className += " fb_reset";
                            } else o = k;
                            if (typeof n == "string") {
                                var p = document.createElement("div");
                                o.appendChild(p).innerHTML = n;
                                return p;
                            } else return o.appendChild(n);
                        },
                        appendHidden: function(n) {
                            if (!o) {
                                var o = document.createElement("div"), p = o.style;
                                p.position = "absolute";
                                p.top = "-10000px";
                                p.width = p.height = 0;
                                o = m.append(o);
                            }
                            return m.append(n, o);
                        },
                        submitToTarget: function(n, o) {
                            var p = document.createElement("form");
                            p.action = n.url;
                            p.target = n.target;
                            p.method = o ? "GET" : "POST";
                            m.appendHidden(p);
                            for (var q in n.params) if (n.params.hasOwnProperty(q)) {
                                var r = n.params[q];
                                if (r !== null && r !== undefined) {
                                    var s = document.createElement("input");
                                    s.name = q;
                                    s.value = r;
                                    p.appendChild(s);
                                }
                            }
                            p.submit();
                            p.parentNode.removeChild(p);
                        }
                    };
                    f.exports = m;
                }, null);
                __d("sdk.Impressions", [ "sdk.Content", "Miny", "QueryString", "sdk.Runtime", "UrlMap", "getBlankIframeSrc", "guid", "insertIframe" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
                    if (c.__markCompiled) c.__markCompiled();
                    function p(r) {
                        var s = k.getClientID();
                        if (!r.api_key && s) r.api_key = s;
                        r.kid_directed_site = k.getKidDirectedSite();
                        var t = l.resolve("www", true) + "/impression.php/" + n() + "/", u = j.appendToUrl(t, r);
                        if (u.length > 2e3) if (r.payload && typeof r.payload === "string") {
                            var v = i.encode(r.payload);
                            if (v && v.length < r.payload.length) {
                                r.payload = v;
                                u = j.appendToUrl(t, r);
                            }
                        }
                        if (u.length <= 2e3) {
                            var w = new Image();
                            w.src = u;
                        } else {
                            var x = n(), y = h.appendHidden("");
                            o({
                                url: m(),
                                root: y,
                                name: x,
                                className: "fb_hidden fb_invisible",
                                onload: function() {
                                    y.parentNode.removeChild(y);
                                }
                            });
                            h.submitToTarget({
                                url: t,
                                target: x,
                                params: r
                            });
                        }
                    }
                    var q = {
                        log: function(r, s) {
                            if (!s.source) s.source = "jssdk";
                            p({
                                lid: r,
                                payload: ES("JSON", "stringify", false, s)
                            });
                        },
                        impression: p
                    };
                    f.exports = q;
                }, null);
                __d("sdk.Scribe", [ "QueryString", "sdk.Runtime", "UrlMap" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    function k(m, n) {
                        if (typeof n.extra == "object") n.extra.revision = i.getRevision();
                        new Image().src = h.appendToUrl(j.resolve("www", true) + "/common/scribe_endpoint.php", {
                            c: m,
                            m: ES("JSON", "stringify", false, n)
                        });
                    }
                    var l = {
                        log: k
                    };
                    f.exports = l;
                }, null);
                __d("Base64", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                    function i(m) {
                        m = m.charCodeAt(0) << 16 | m.charCodeAt(1) << 8 | m.charCodeAt(2);
                        return String.fromCharCode(h.charCodeAt(m >>> 18), h.charCodeAt(m >>> 12 & 63), h.charCodeAt(m >>> 6 & 63), h.charCodeAt(m & 63));
                    }
                    var j = ">___?456789:;<=_______" + "\0\b\t\n\x0B\f\r" + "______ !\"#$%&'()*+,-./0123";
                    function k(m) {
                        m = j.charCodeAt(m.charCodeAt(0) - 43) << 18 | j.charCodeAt(m.charCodeAt(1) - 43) << 12 | j.charCodeAt(m.charCodeAt(2) - 43) << 6 | j.charCodeAt(m.charCodeAt(3) - 43);
                        return String.fromCharCode(m >>> 16, m >>> 8 & 255, m & 255);
                    }
                    var l = {
                        encode: function(m) {
                            m = unescape(encodeURI(m));
                            var n = (m.length + 2) % 3;
                            m = (m + "\0\0".slice(n)).replace(/[\s\S]{3}/g, i);
                            return m.slice(0, m.length + n - 2) + "==".slice(n);
                        },
                        decode: function(m) {
                            m = m.replace(/[^A-Za-z0-9+\/]/g, "");
                            var n = m.length + 3 & 3;
                            m = (m + "AAA".slice(n)).replace(/..../g, k);
                            m = m.slice(0, m.length + n - 3);
                            try {
                                return decodeURIComponent(escape(m));
                            } catch (o) {
                                throw new Error("Not valid UTF-8");
                            }
                        },
                        encodeObject: function(m) {
                            return l.encode(ES("JSON", "stringify", false, m));
                        },
                        decodeObject: function(m) {
                            return ES("JSON", "parse", false, l.decode(m));
                        },
                        encodeNums: function(m) {
                            return String.fromCharCode.apply(String, ES(m, "map", true, function(n) {
                                return h.charCodeAt((n | -(n > 63)) & -(n > 0) & 63);
                            }));
                        }
                    };
                    f.exports = l;
                }, null);
                __d("sdk.SignedRequest", [ "Base64" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(k) {
                        if (!k) return null;
                        var l = k.split(".", 2)[1].replace(/\-/g, "+").replace(/\_/g, "/");
                        return h.decodeObject(l);
                    }
                    var j = {
                        parse: i
                    };
                    f.exports = j;
                }, null);
                __d("URIRFC3986", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = new RegExp("^" + "([^:/?#]+:)?" + "(//" + "([^\\\\/?#@]*@)?" + "(" + "\\[[A-Fa-f0-9:.]+\\]|" + "[^\\/?#:]*" + ")" + "(:[0-9]*)?" + ")?" + "([^?#]*)" + "(\\?[^#]*)?" + "(#.*)?"), i = {
                        parse: function(j) {
                            if (ES(j, "trim", true) === "") return null;
                            var k = j.match(h);
                            if (k == null) return null;
                            var l = {};
                            l.uri = k[0] ? k[0] : null;
                            l.scheme = k[1] ? k[1].substr(0, k[1].length - 1) : null;
                            l.authority = k[2] ? k[2].substr(2) : null;
                            l.userinfo = k[3] ? k[3].substr(0, k[3].length - 1) : null;
                            l.host = k[2] ? k[4] : null;
                            l.port = k[5] ? k[5].substr(1) ? parseInt(k[5].substr(1), 10) : null : null;
                            l.path = k[6] ? k[6] : null;
                            l.query = k[7] ? k[7].substr(1) : null;
                            l.fragment = k[8] ? k[8].substr(1) : null;
                            l.isGenericURI = l.authority === null && !!l.scheme;
                            return l;
                        }
                    };
                    f.exports = i;
                }, null);
                __d("createObjectFrom", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i, j) {
                        var k = {}, l = ES("Array", "isArray", false, j);
                        if (j === undefined) j = true;
                        for (var m = i.length - 1; m >= 0; m--) k[i[m]] = l ? j[m] : j;
                        return k;
                    }
                    f.exports = h;
                }, null);
                __d("URISchemes", [ "createObjectFrom" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = h([ "blob", "cmms", "fb", "fb-ama", "fb-messenger", "fb-page-messages", "fbcf", "fbconnect", "fbmobilehome", "fbrpc", "file", "ftp", "http", "https", "mailto", "ms-app", "intent", "itms", "itms-apps", "itms-services", "market", "svn+ssh", "fbstaging", "tel", "sms", "pebblejs", "sftp", "whatsapp", "moments", "fblite", "chrome-extension" ]), j = {
                        isAllowed: function(k) {
                            if (!k) return true;
                            return i.hasOwnProperty(k.toLowerCase());
                        }
                    };
                    f.exports = j;
                }, null);
                __d("eprintf", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = function(i) {
                        var j = ES(Array.prototype.slice.call(arguments), "map", true, function(m) {
                            return String(m);
                        }), k = i.split("%s").length - 1;
                        if (k !== j.length - 1) return h("eprintf args number mismatch: %s", ES("JSON", "stringify", false, j));
                        var l = 1;
                        return i.replace(/%s/g, function(m) {
                            return String(j[l++]);
                        });
                    };
                    f.exports = h;
                }, null);
                __d("ex", [ "eprintf" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = function() {
                        for (var j = arguments.length, k = Array(j), l = 0; l < j; l++) k[l] = arguments[l];
                        k = ES(k, "map", true, function(m) {
                            return String(m);
                        });
                        if (k[0].split("%s").length !== k.length) return i("ex args number mismatch: %s", ES("JSON", "stringify", false, k));
                        return i._prefix + ES("JSON", "stringify", false, k) + i._suffix;
                    };
                    i._prefix = "<![EX[";
                    i._suffix = "]]>";
                    f.exports = i;
                }, null);
                __d("invariant", [ "ex", "sprintf" ], function a(b, c, d, e, f, g, h, i) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var j = h;
                    function k(l, m) {
                        if (!l) {
                            var n = void 0;
                            if (m === undefined) {
                                n = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
                            } else {
                                var o = [ m ];
                                for (var p = 2, q = arguments.length; p < q; p++) o.push(arguments[p]);
                                n = new Error(j.apply(null, o));
                                n.name = "Invariant Violation";
                                n.messageWithParams = o;
                            }
                            n.framesToPop = 1;
                            throw n;
                        }
                    }
                    f.exports = k;
                }, null);
                __d("URIBase", [ "URIRFC3986", "URISchemes", "ex", "invariant" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    var l = new RegExp("[\\x00-\\x2c\\x2f\\x3b-\\x40\\x5c\\x5e\\x60\\x7b-\\x7f" + "\\uFDD0-\\uFDEF\\uFFF0-\\uFFFF" + "\\u2047\\u2048\\uFE56\\uFE5F\\uFF03\\uFF0F\\uFF1F]"), m = new RegExp("^(?:[^/]*:|" + "[\\x00-\\x1f]*/[\\x00-\\x1f]*/)");
                    function n(q, r, s, t) {
                        if (!r) return true;
                        if (r instanceof p) {
                            q.setProtocol(r.getProtocol());
                            q.setDomain(r.getDomain());
                            q.setPort(r.getPort());
                            q.setPath(r.getPath());
                            q.setQueryData(t.deserialize(t.serialize(r.getQueryData())));
                            q.setFragment(r.getFragment());
                            q.setForceFragmentSeparator(r.getForceFragmentSeparator());
                            return true;
                        }
                        r = ES(r.toString(), "trim", true);
                        var u = h.parse(r) || {
                            fragment: null,
                            scheme: null
                        };
                        if (!s && !i.isAllowed(u.scheme)) return false;
                        q.setProtocol(u.scheme || "");
                        if (!s && l.test(u.host || "")) return false;
                        q.setDomain(u.host || "");
                        q.setPort(u.port || "");
                        q.setPath(u.path || "");
                        if (s) {
                            q.setQueryData(t.deserialize(u.query || "") || {});
                        } else try {
                            q.setQueryData(t.deserialize(u.query || "") || {});
                        } catch (v) {
                            return false;
                        }
                        q.setFragment(u.fragment || "");
                        if (u.fragment === "") q.setForceFragmentSeparator(true);
                        if (u.userinfo !== null) if (s) {
                            throw new Error(j("URI.parse: invalid URI (userinfo is not allowed in a URI): %s", q.toString()));
                        } else return false;
                        if (!q.getDomain() && ES(q.getPath(), "indexOf", true, "\\") !== -1) if (s) {
                            throw new Error(j("URI.parse: invalid URI (no domain but multiple back-slashes): %s", q.toString()));
                        } else return false;
                        if (!q.getProtocol() && m.test(r)) if (s) {
                            throw new Error(j("URI.parse: invalid URI (unsafe protocol-relative URLs): %s", q.toString()));
                        } else return false;
                        return true;
                    }
                    var o = [];
                    function p(q, r) {
                        "use strict";
                        !r ? k(0) : void 0;
                        this.$URIBase8 = r;
                        this.$URIBase6 = "";
                        this.$URIBase1 = "";
                        this.$URIBase5 = "";
                        this.$URIBase4 = "";
                        this.$URIBase3 = "";
                        this.$URIBase7 = {};
                        this.$URIBase2 = false;
                        n(this, q, true, r);
                    }
                    p.prototype.setProtocol = function(q) {
                        "use strict";
                        !i.isAllowed(q) ? k(0) : void 0;
                        this.$URIBase6 = q;
                        return this;
                    };
                    p.prototype.getProtocol = function() {
                        "use strict";
                        return this.$URIBase6;
                    };
                    p.prototype.setSecure = function(q) {
                        "use strict";
                        return this.setProtocol(q ? "https" : "http");
                    };
                    p.prototype.isSecure = function() {
                        "use strict";
                        return this.getProtocol() === "https";
                    };
                    p.prototype.setDomain = function(q) {
                        "use strict";
                        if (l.test(q)) throw new Error(j("URI.setDomain: unsafe domain specified: %s for url %s", q, this.toString()));
                        this.$URIBase1 = q;
                        return this;
                    };
                    p.prototype.getDomain = function() {
                        "use strict";
                        return this.$URIBase1;
                    };
                    p.prototype.setPort = function(q) {
                        "use strict";
                        this.$URIBase5 = q;
                        return this;
                    };
                    p.prototype.getPort = function() {
                        "use strict";
                        return this.$URIBase5;
                    };
                    p.prototype.setPath = function(q) {
                        "use strict";
                        this.$URIBase4 = q;
                        return this;
                    };
                    p.prototype.getPath = function() {
                        "use strict";
                        return this.$URIBase4;
                    };
                    p.prototype.addQueryData = function(q, r) {
                        "use strict";
                        if (Object.prototype.toString.call(q) === "[object Object]") {
                            ES("Object", "assign", false, this.$URIBase7, q);
                        } else this.$URIBase7[q] = r;
                        return this;
                    };
                    p.prototype.setQueryData = function(q) {
                        "use strict";
                        this.$URIBase7 = q;
                        return this;
                    };
                    p.prototype.getQueryData = function() {
                        "use strict";
                        return this.$URIBase7;
                    };
                    p.prototype.removeQueryData = function(q) {
                        "use strict";
                        if (!ES("Array", "isArray", false, q)) q = [ q ];
                        for (var r = 0, s = q.length; r < s; ++r) delete this.$URIBase7[q[r]];
                        return this;
                    };
                    p.prototype.setFragment = function(q) {
                        "use strict";
                        this.$URIBase3 = q;
                        this.setForceFragmentSeparator(false);
                        return this;
                    };
                    p.prototype.getFragment = function() {
                        "use strict";
                        return this.$URIBase3;
                    };
                    p.prototype.setForceFragmentSeparator = function(q) {
                        "use strict";
                        this.$URIBase2 = q;
                        return this;
                    };
                    p.prototype.getForceFragmentSeparator = function() {
                        "use strict";
                        return this.$URIBase2;
                    };
                    p.prototype.isEmpty = function() {
                        "use strict";
                        return !(this.getPath() || this.getProtocol() || this.getDomain() || this.getPort() || ES("Object", "keys", false, this.getQueryData()).length > 0 || this.getFragment());
                    };
                    p.prototype.toString = function() {
                        "use strict";
                        var q = this;
                        for (var r = 0; r < o.length; r++) q = o[r](q);
                        return q.$URIBase9();
                    };
                    p.prototype.$URIBase9 = function() {
                        "use strict";
                        var q = "", r = this.getProtocol();
                        if (r) q += r + "://";
                        var s = this.getDomain();
                        if (s) q += s;
                        var t = this.getPort();
                        if (t) q += ":" + t;
                        var u = this.getPath();
                        if (u) {
                            q += u;
                        } else if (q) q += "/";
                        var v = this.$URIBase8.serialize(this.getQueryData());
                        if (v) q += "?" + v;
                        var w = this.getFragment();
                        if (w) {
                            q += "#" + w;
                        } else if (this.getForceFragmentSeparator()) q += "#";
                        return q;
                    };
                    p.registerFilter = function(q) {
                        "use strict";
                        o.push(q);
                    };
                    p.prototype.getOrigin = function() {
                        "use strict";
                        var q = this.getPort();
                        return this.getProtocol() + "://" + this.getDomain() + (q ? ":" + q : "");
                    };
                    p.prototype.getQualifiedURIBase = function() {
                        "use strict";
                        return new p(this, this.$URIBase8).qualify();
                    };
                    p.prototype.qualify = function() {
                        "use strict";
                        if (!this.getDomain()) {
                            var q = new p(window.location.href, this.$URIBase8);
                            this.setProtocol(q.getProtocol()).setDomain(q.getDomain()).setPort(q.getPort());
                        }
                        return this;
                    };
                    p.prototype.setSubdomain = function(q) {
                        "use strict";
                        var r = this.qualify().getDomain().split(".");
                        if (r.length <= 2) {
                            r.unshift(q);
                        } else r[0] = q;
                        return this.setDomain(r.join("."));
                    };
                    p.prototype.getSubdomain = function() {
                        "use strict";
                        if (!this.getDomain()) return "";
                        var q = this.getDomain().split(".");
                        if (q.length <= 2) {
                            return "";
                        } else return q[0];
                    };
                    p.isValidURI = function(q, r) {
                        return n(new p(null, r), q, false, r);
                    };
                    f.exports = p;
                }, null);
                __d("sdk.URI", [ "Assert", "QueryString", "URIBase" ], function a(b, c, d, e, f, g, h, i, j) {
                    var k, l;
                    if (c.__markCompiled) c.__markCompiled();
                    var m = /\.facebook\.com$/, n = {
                        serialize: function(p) {
                            return p ? i.encode(p) : "";
                        },
                        deserialize: function(p) {
                            return p ? i.decode(p) : {};
                        }
                    };
                    k = babelHelpers.inherits(o, j);
                    l = k && k.prototype;
                    function o(p) {
                        "use strict";
                        h.isString(p, "The passed argument was of invalid type.");
                        l.constructor.call(this, p, n);
                    }
                    o.prototype.isFacebookURI = function() {
                        "use strict";
                        return m.test(this.getDomain());
                    };
                    o.prototype.valueOf = function() {
                        "use strict";
                        return this.toString();
                    };
                    f.exports = o;
                }, null);
                __d("Queue", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {};
                    function i(j) {
                        "use strict";
                        this._opts = babelHelpers["extends"]({
                            interval: 0,
                            processor: null
                        }, j);
                        this._queue = [];
                        this._stopped = true;
                    }
                    i.prototype._dispatch = function(j) {
                        "use strict";
                        if (this._stopped || this._queue.length === 0) return;
                        if (!this._opts.processor) {
                            this._stopped = true;
                            throw new Error("No processor available");
                        }
                        if (this._opts.interval) {
                            this._opts.processor.call(this, this._queue.shift());
                            this._timeout = setTimeout(ES(this._dispatch, "bind", true, this), this._opts.interval);
                        } else while (this._queue.length) this._opts.processor.call(this, this._queue.shift());
                    };
                    i.prototype.enqueue = function(j) {
                        "use strict";
                        if (this._opts.processor && !this._stopped) {
                            this._opts.processor.call(this, j);
                        } else this._queue.push(j);
                        return this;
                    };
                    i.prototype.start = function(j) {
                        "use strict";
                        if (j) this._opts.processor = j;
                        this._stopped = false;
                        this._dispatch();
                        return this;
                    };
                    i.prototype.isStarted = function() {
                        "use strict";
                        return !this._stopped;
                    };
                    i.prototype.dispatch = function() {
                        "use strict";
                        this._dispatch(true);
                    };
                    i.prototype.stop = function(j) {
                        "use strict";
                        this._stopped = true;
                        if (j) clearTimeout(this._timeout);
                        return this;
                    };
                    i.prototype.merge = function(j, k) {
                        "use strict";
                        this._queue[k ? "unshift" : "push"].apply(this._queue, j._queue);
                        j._queue = [];
                        this._dispatch();
                        return this;
                    };
                    i.prototype.getLength = function() {
                        "use strict";
                        return this._queue.length;
                    };
                    i.get = function(j, k) {
                        "use strict";
                        var l;
                        if (j in h) {
                            l = h[j];
                        } else l = h[j] = new i(k);
                        return l;
                    };
                    i.exists = function(j) {
                        "use strict";
                        return j in h;
                    };
                    i.remove = function(j) {
                        "use strict";
                        return delete h[j];
                    };
                    f.exports = i;
                }, null);
                __d("DOMEventListener", [ "invariant", "wrapFunction" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = void 0, k = void 0;
                    if (window.addEventListener) {
                        j = function(m, n, o) {
                            o.wrapper = i(o, "entry", "DOMEventListener.add " + n);
                            m.addEventListener(n, o.wrapper, false);
                        };
                        k = function(m, n, o) {
                            m.removeEventListener(n, o.wrapper, false);
                        };
                    } else if (window.attachEvent) {
                        j = function(m, n, o) {
                            o.wrapper = i(o, "entry", "DOMEventListener.add " + n);
                            !m.attachEvent ? h(0) : void 0;
                            m.attachEvent("on" + n, o.wrapper);
                        };
                        k = function(m, n, o) {
                            !m.detachEvent ? h(0) : void 0;
                            m.detachEvent("on" + n, o.wrapper);
                        };
                    } else k = j = function() {};
                    var l = {
                        add: function(m, n, o) {
                            j(m, n, o);
                            return {
                                remove: function() {
                                    k(m, n, o);
                                }
                            };
                        },
                        remove: k
                    };
                    f.exports = l;
                }, null);
                __d("UserAgent_DEPRECATED", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = false, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w;
                    function x() {
                        if (h) return;
                        h = true;
                        var z = navigator.userAgent, aa = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(z), ba = /(Mac OS X)|(Windows)|(Linux)/.exec(z);
                        t = /\b(iPhone|iP[ao]d)/.exec(z);
                        u = /\b(iP[ao]d)/.exec(z);
                        r = /Android/i.exec(z);
                        v = /FBAN\/\w+;/i.exec(z);
                        w = /Mobile/i.exec(z);
                        s = !!/Win64/.exec(z);
                        if (aa) {
                            i = aa[1] ? parseFloat(aa[1]) : aa[5] ? parseFloat(aa[5]) : NaN;
                            if (i && document && document.documentMode) i = document.documentMode;
                            var ca = /(?:Trident\/(\d+.\d+))/.exec(z);
                            n = ca ? parseFloat(ca[1]) + 4 : i;
                            j = aa[2] ? parseFloat(aa[2]) : NaN;
                            k = aa[3] ? parseFloat(aa[3]) : NaN;
                            l = aa[4] ? parseFloat(aa[4]) : NaN;
                            if (l) {
                                aa = /(?:Chrome\/(\d+\.\d+))/.exec(z);
                                m = aa && aa[1] ? parseFloat(aa[1]) : NaN;
                            } else m = NaN;
                        } else i = j = k = m = l = NaN;
                        if (ba) {
                            if (ba[1]) {
                                var da = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(z);
                                o = da ? parseFloat(da[1].replace("_", ".")) : true;
                            } else o = false;
                            p = !!ba[2];
                            q = !!ba[3];
                        } else o = p = q = false;
                    }
                    var y = {
                        ie: function() {
                            return x() || i;
                        },
                        ieCompatibilityMode: function() {
                            return x() || n > i;
                        },
                        ie64: function() {
                            return y.ie() && s;
                        },
                        firefox: function() {
                            return x() || j;
                        },
                        opera: function() {
                            return x() || k;
                        },
                        webkit: function() {
                            return x() || l;
                        },
                        safari: function() {
                            return y.webkit();
                        },
                        chrome: function() {
                            return x() || m;
                        },
                        windows: function() {
                            return x() || p;
                        },
                        osx: function() {
                            return x() || o;
                        },
                        linux: function() {
                            return x() || q;
                        },
                        iphone: function() {
                            return x() || t;
                        },
                        mobile: function() {
                            return x() || t || u || r || w;
                        },
                        nativeApp: function() {
                            return x() || v;
                        },
                        android: function() {
                            return x() || r;
                        },
                        ipad: function() {
                            return x() || u;
                        }
                    };
                    f.exports = y;
                }, null);
                __d("htmlSpecialChars", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = /&/g, i = /</g, j = />/g, k = /"/g, l = /'/g;
                    function m(n) {
                        if (typeof n == "undefined" || n === null || !n.toString) return "";
                        if (n === false) {
                            return "0";
                        } else if (n === true) return "1";
                        return n.toString().replace(h, "&amp;").replace(k, "&quot;").replace(l, "&#039;").replace(i, "&lt;").replace(j, "&gt;");
                    }
                    f.exports = m;
                }, null);
                __d("Flash", [ "DOMEventListener", "DOMWrapper", "QueryString", "UserAgent_DEPRECATED", "guid", "htmlSpecialChars" ], function a(b, c, d, e, f, g, h, i, j, k, l, m) {
                    if (c.__markCompiled) c.__markCompiled();
                    var n = {}, o, p = i.getWindow().document;
                    function q(v) {
                        var w = p.getElementById(v);
                        if (w) w.parentNode.removeChild(w);
                        delete n[v];
                    }
                    function r() {
                        for (var v in n) if (n.hasOwnProperty(v)) q(v);
                    }
                    function s(v) {
                        return v.replace(/\d+/g, function(w) {
                            return "000".substring(w.length) + w;
                        });
                    }
                    function t(v) {
                        if (!o) {
                            if (k.ie() >= 9) h.add(window, "unload", r);
                            o = true;
                        }
                        n[v] = v;
                    }
                    var u = {
                        embed: function(v, w, x, y) {
                            var z = l();
                            v = m(v).replace(/&amp;/g, "&");
                            x = babelHelpers["extends"]({
                                allowscriptaccess: "always",
                                flashvars: y,
                                movie: v
                            }, x);
                            if (typeof x.flashvars == "object") x.flashvars = j.encode(x.flashvars);
                            var aa = [];
                            for (var ba in x) if (x.hasOwnProperty(ba) && x[ba]) aa.push('<param name="' + m(ba) + '" value="' + m(x[ba]) + '">');
                            var ca = w.appendChild(p.createElement("span")), da = "<object " + (k.ie() ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" ' : 'type="application/x-shockwave-flash"') + 'data="' + v + '" ' + (x.height ? 'height="' + x.height + '" ' : "") + (x.width ? 'width="' + x.width + '" ' : "") + 'id="' + z + '">' + aa.join("") + "</object>";
                            ca.innerHTML = da;
                            var ea = ca.firstChild;
                            t(z);
                            return ea;
                        },
                        remove: q,
                        getVersion: function() {
                            var v = "Shockwave Flash", w = "application/x-shockwave-flash", x = "ShockwaveFlash.ShockwaveFlash", y;
                            if (navigator.plugins && typeof navigator.plugins[v] == "object") {
                                var z = navigator.plugins[v].description;
                                if (z && navigator.mimeTypes && navigator.mimeTypes[w] && navigator.mimeTypes[w].enabledPlugin) y = z.match(/\d+/g);
                            }
                            if (!y) try {
                                y = new ActiveXObject(x).GetVariable("$version").match(/(\d+),(\d+),(\d+),(\d+)/);
                                y = Array.prototype.slice.call(y, 1);
                            } catch (aa) {}
                            return y;
                        },
                        getVersionString: function() {
                            var v = u.getVersion();
                            return v ? v.join(".") : "";
                        },
                        checkMinVersion: function(v) {
                            var w = u.getVersion();
                            if (!w) return false;
                            return s(w.join(".")) >= s(v);
                        },
                        isAvailable: function() {
                            return !!u.getVersion();
                        }
                    };
                    f.exports = u;
                }, null);
                __d("emptyFunction", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(j) {
                        return function() {
                            return j;
                        };
                    }
                    var i = function() {};
                    i.thatReturns = h;
                    i.thatReturnsFalse = h(false);
                    i.thatReturnsTrue = h(true);
                    i.thatReturnsNull = h(null);
                    i.thatReturnsThis = function() {
                        return this;
                    };
                    i.thatReturnsArgument = function(j) {
                        return j;
                    };
                    f.exports = i;
                }, null);
                __d("XDM", [ "DOMEventListener", "DOMWrapper", "emptyFunction", "Flash", "GlobalCallback", "guid", "Log", "UserAgent_DEPRECATED", "wrapFunction" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                    if (c.__markCompiled) c.__markCompiled();
                    var q = {}, r = {
                        transports: []
                    }, s = i.getWindow();
                    function t(w) {
                        var x = {}, y = w.length, z = r.transports;
                        while (y--) x[w[y]] = 1;
                        y = z.length;
                        while (y--) {
                            var aa = z[y], ba = q[aa];
                            if (!x[aa] && ba.isAvailable()) return aa;
                        }
                    }
                    var u = {
                        register: function(w, x) {
                            n.debug("Registering %s as XDM provider", w);
                            r.transports.push(w);
                            q[w] = x;
                        },
                        create: function(w) {
                            if (!w.whenReady && !w.onMessage) {
                                n.error("An instance without whenReady or onMessage makes no sense");
                                throw new Error("An instance without whenReady or " + "onMessage makes no sense");
                            }
                            if (!w.channel) {
                                n.warn("Missing channel name, selecting at random");
                                w.channel = m();
                            }
                            if (!w.whenReady) w.whenReady = j;
                            if (!w.onMessage) w.onMessage = j;
                            var x = w.transport || t(w.blacklist || []), y = q[x];
                            if (y && y.isAvailable()) {
                                n.debug("%s is available", x);
                                y.init(w);
                                return x;
                            }
                        }
                    };
                    u.register("flash", function() {
                        var w = false, x, y = false, z = 15e3, aa;
                        return {
                            isAvailable: function() {
                                return k.checkMinVersion("8.0.24");
                            },
                            init: function(ba) {
                                n.debug("init flash: " + ba.channel);
                                var ca = {
                                    send: function(fa, ga, ha, ia) {
                                        n.debug("sending to: %s (%s)", ga, ia);
                                        x.postMessage(fa, ga, ia);
                                    }
                                };
                                if (w) {
                                    ba.whenReady(ca);
                                    return;
                                }
                                var da = ba.root.appendChild(s.document.createElement("div")), ea = l.create(function() {
                                    l.remove(ea);
                                    clearTimeout(aa);
                                    n.info("xdm.swf called the callback");
                                    var fa = l.create(function(ga, ha) {
                                        ga = decodeURIComponent(ga);
                                        ha = decodeURIComponent(ha);
                                        n.debug("received message %s from %s", ga, ha);
                                        ba.onMessage(ga, ha);
                                    }, "xdm.swf:onMessage");
                                    x.init(ba.channel, fa);
                                    ba.whenReady(ca);
                                }, "xdm.swf:load");
                                x = k.embed(ba.flashUrl, da, null, {
                                    protocol: location.protocol.replace(":", ""),
                                    host: location.host,
                                    callback: ea,
                                    log: y
                                });
                                aa = setTimeout(function() {
                                    n.warn("The Flash component did not load within %s ms - " + "verify that the container is not set to hidden or invisible " + "using CSS as this will cause some browsers to not load " + "the components", z);
                                }, z);
                                w = true;
                            }
                        };
                    }());
                    var v = /\.facebook\.com(\/|$)/;
                    u.register("postmessage", function() {
                        var w = false;
                        return {
                            isAvailable: function() {
                                return !!s.postMessage;
                            },
                            init: function(x) {
                                n.debug("init postMessage: " + x.channel);
                                var y = "_FB_" + x.channel, z = {
                                    send: function(aa, ba, ca, da) {
                                        if (s === ca) {
                                            n.error("Invalid windowref, equal to window (self)");
                                            throw new Error();
                                        }
                                        n.debug("sending to: %s (%s)", ba, da);
                                        var ea = function() {
                                            ca.postMessage("_FB_" + da + aa, ba);
                                        };
                                        if (o.ie() == 8 || o.ieCompatibilityMode()) {
                                            setTimeout(ea, 0);
                                        } else ea();
                                    }
                                };
                                if (w) {
                                    x.whenReady(z);
                                    return;
                                }
                                h.add(s, "message", p(function(event) {
                                    var aa = event.data, ba = event.origin || "native";
                                    if (!/^(https?:\/\/|native$)/.test(ba)) {
                                        n.debug("Received message from invalid origin type: %s", ba);
                                        return;
                                    }
                                    if (ba !== "native" && !(v.test(location.hostname) || v.test(event.origin))) return;
                                    if (typeof aa != "string") {
                                        n.warn("Received message of type %s from %s, expected a string", typeof aa, ba);
                                        return;
                                    }
                                    n.debug("received message %s from %s", aa, ba);
                                    if (aa.substring(0, y.length) == y) aa = aa.substring(y.length);
                                    x.onMessage(aa, ba);
                                }, "entry", "onMessage"));
                                x.whenReady(z);
                                w = true;
                            }
                        };
                    }());
                    f.exports = u;
                }, null);
                __d("isFacebookURI", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = null, i = [ "http", "https" ];
                    function j(k) {
                        if (!h) h = new RegExp("(^|\\.)facebook\\.com$", "i");
                        if (k.isEmpty() && k.toString() !== "#") return false;
                        if (!k.getDomain() && !k.getProtocol()) return true;
                        return ES(i, "indexOf", true, k.getProtocol()) !== -1 && h.test(k.getDomain());
                    }
                    j.setRegex = function(k) {
                        h = k;
                    };
                    f.exports = j;
                }, null);
                __d("sdk.Event", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        SUBSCRIBE: "event.subscribe",
                        UNSUBSCRIBE: "event.unsubscribe",
                        subscribers: function() {
                            if (!this._subscribersMap) this._subscribersMap = {};
                            return this._subscribersMap;
                        },
                        subscribe: function(i, j) {
                            var k = this.subscribers();
                            if (!k[i]) {
                                k[i] = [ j ];
                            } else if (ES(k[i], "indexOf", true, j) == -1) k[i].push(j);
                            if (i != this.SUBSCRIBE && i != this.UNSUBSCRIBE) this.fire(this.SUBSCRIBE, i, k[i]);
                        },
                        unsubscribe: function(i, j) {
                            var k = this.subscribers()[i];
                            if (k) ES(k, "forEach", true, function(l, m) {
                                if (l == j) k.splice(m, 1);
                            });
                            if (i != this.SUBSCRIBE && i != this.UNSUBSCRIBE) this.fire(this.UNSUBSCRIBE, i, k);
                        },
                        monitor: function(i, j) {
                            if (!j()) {
                                var k = this, l = function() {
                                    if (j.apply(j, arguments)) k.unsubscribe(i, l);
                                };
                                this.subscribe(i, l);
                            }
                        },
                        clear: function(i) {
                            delete this.subscribers()[i];
                        },
                        fire: function(i) {
                            var j = Array.prototype.slice.call(arguments, 1), k = this.subscribers()[i];
                            if (k) ES(k, "forEach", true, function(l) {
                                if (l) l.apply(this, j);
                            });
                        }
                    };
                    f.exports = h;
                }, null);
                __d("JSONRPC", [ "Log" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j) {
                        "use strict";
                        this.$JSONRPC1 = 0;
                        this.$JSONRPC2 = {};
                        this.remote = ES(function(k) {
                            this.$JSONRPC3 = k;
                            return this.remote;
                        }, "bind", true, this);
                        this.local = {};
                        this.$JSONRPC4 = j;
                    }
                    i.prototype.stub = function(j) {
                        "use strict";
                        this.remote[j] = ES(function() {
                            var k = {
                                jsonrpc: "2.0",
                                method: j
                            };
                            for (var l = arguments.length, m = Array(l), n = 0; n < l; n++) m[n] = arguments[n];
                            if (typeof m[m.length - 1] == "function") {
                                k.id = ++this.$JSONRPC1;
                                this.$JSONRPC2[k.id] = m.pop();
                            }
                            k.params = m;
                            this.$JSONRPC4(ES("JSON", "stringify", false, k), this.$JSONRPC3 || {
                                method: j
                            });
                        }, "bind", true, this);
                    };
                    i.prototype.read = function(j, k) {
                        "use strict";
                        var l = ES("JSON", "parse", false, j), m = l.id;
                        if (!l.method) {
                            if (!this.$JSONRPC2[m]) {
                                h.warn("Could not find callback %s", m);
                                return;
                            }
                            var n = this.$JSONRPC2[m];
                            delete this.$JSONRPC2[m];
                            delete l.id;
                            delete l.jsonrpc;
                            n(l);
                            return;
                        }
                        var o = this, p = this.local[l.method], q;
                        if (m) {
                            q = function(t, u) {
                                var v = {
                                    jsonrpc: "2.0",
                                    id: m
                                };
                                v[t] = u;
                                setTimeout(function() {
                                    o.$JSONRPC4(ES("JSON", "stringify", false, v), k);
                                }, 0);
                            };
                        } else q = function() {};
                        if (!p) {
                            h.error('Method "%s" has not been defined', l.method);
                            q("error", {
                                code: -32601,
                                message: "Method not found",
                                data: l.method
                            });
                            return;
                        }
                        l.params.push(ES(q, "bind", true, null, "result"));
                        l.params.push(ES(q, "bind", true, null, "error"));
                        try {
                            var s = p.apply(k || null, l.params);
                            if (typeof s !== "undefined") q("result", s);
                        } catch (r) {
                            h.error("Invokation of RPC method %s resulted in the error: %s", l.method, r.message);
                            q("error", {
                                code: -32603,
                                message: "Internal error",
                                data: r.message
                            });
                        }
                    };
                    f.exports = i;
                }, null);
                __d("sdk.RPC", [ "Assert", "JSONRPC", "Queue" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = new j(), l = new i(function(n) {
                        k.enqueue(n);
                    }), m = {
                        local: l.local,
                        remote: l.remote,
                        stub: ES(l.stub, "bind", true, l),
                        setInQueue: function(n) {
                            h.isInstanceOf(j, n);
                            n.start(function(o) {
                                l.read(o);
                            });
                        },
                        getOutQueue: function() {
                            return k;
                        }
                    };
                    f.exports = m;
                }, null);
                __d("hasNamePropertyBug", [ "guid", "UserAgent_DEPRECATED" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = i.ie() ? undefined : false;
                    function k() {
                        var m = document.createElement("form"), n = m.appendChild(document.createElement("input"));
                        n.name = h();
                        j = n !== m.elements[n.name];
                        m = n = null;
                        return j;
                    }
                    function l() {
                        return typeof j === "undefined" ? k() : j;
                    }
                    f.exports = l;
                }, null);
                __d("sdk.createIframe", [ "DOMEventListener", "getBlankIframeSrc", "guid", "hasNamePropertyBug" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    function l(m) {
                        m = ES("Object", "assign", false, {}, m);
                        var n, o = m.name || j(), p = m.root, q = m.style || {
                            border: "none"
                        }, r = m.url, s = m.onload, t = m.onerror;
                        if (k()) {
                            n = document.createElement('<iframe name="' + o + '"/>');
                        } else {
                            n = document.createElement("iframe");
                            n.name = o;
                        }
                        delete m.style;
                        delete m.name;
                        delete m.url;
                        delete m.root;
                        delete m.onload;
                        delete m.onerror;
                        var u = ES("Object", "assign", false, {
                            frameBorder: 0,
                            allowTransparency: true,
                            allowFullscreen: true,
                            scrolling: "no"
                        }, m);
                        if (u.width) n.width = u.width + "px";
                        if (u.height) n.height = u.height + "px";
                        delete u.height;
                        delete u.width;
                        for (var v in u) if (u.hasOwnProperty(v)) n.setAttribute(v, u[v]);
                        ES("Object", "assign", false, n.style, q);
                        n.src = i();
                        p.appendChild(n);
                        if (s) var w = h.add(n, "load", function() {
                            w.remove();
                            s();
                        });
                        if (t) var x = h.add(n, "error", function() {
                            x.remove();
                            t();
                        });
                        n.src = r;
                        return n;
                    }
                    f.exports = l;
                }, null);
                __d("sdk.FeatureFunctor", [ "invariant" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(k, l, m) {
                        if (k.features && l in k.features) {
                            var n = k.features[l];
                            if (typeof n === "object" && typeof n.rate === "number") {
                                if (n.rate && Math.random() * 100 <= n.rate) {
                                    return n.value || true;
                                } else return n.value ? null : false;
                            } else return n;
                        }
                        return m;
                    }
                    function j(k) {
                        return function(l, m) {
                            !(arguments.length >= 2) ? h(0) : void 0;
                            return i(k, l, m);
                        };
                    }
                    f.exports = {
                        create: j
                    };
                }, null);
                __d("sdk.feature", [ "sdk.FeatureFunctor", "JSSDKConfig" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    f.exports = h.create(i);
                }, null);
                __d("sdk.XD", [ "sdk.Content", "sdk.Event", "Log", "QueryString", "Queue", "sdk.RPC", "sdk.Runtime", "sdk.Scribe", "sdk.URI", "UrlMap", "JSSDKXDConfig", "XDM", "isFacebookURI", "sdk.createIframe", "sdk.feature", "guid" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w) {
                    if (c.__markCompiled) c.__markCompiled();
                    var x = new l(), y = new l(), z = new l(), aa, ba, ca = w(), da = r.useCdn ? "cdn" : "www", ea = v("use_bundle", false) ? r.XdBundleUrl : r.XdUrl, fa = q.resolve(da, false) + ea, ga = q.resolve(da, true) + ea, ha = function() {
                        if ("origin" in location) if (location.origin && location.origin !== "null") {
                            return location.origin;
                        } else if (window !== window.parent) try {
                            var wa = parent.location.origin;
                            if (wa && wa !== "null") return wa;
                        } catch (va) {}
                        return location.protocol + "//" + location.host;
                    }, ia = w(), ja = ha(), ka, la = false, ma = "Facebook Cross Domain Communication Frame", na = {}, oa = new l();
                    m.setInQueue(oa);
                    function pa(va) {
                        j.info("Remote XD can talk to facebook.com (%s)", va);
                        n.setEnvironment(va === "canvas" ? n.ENVIRONMENTS.CANVAS : n.ENVIRONMENTS.PAGETAB);
                    }
                    function qa(va, wa) {
                        if (!wa) {
                            j.error("No senderOrigin");
                            throw new Error();
                        }
                        var xa = /^https?/.exec(wa)[0];
                        switch (va.xd_action) {
                          case "proxy_ready":
                            var ya, za;
                            if (xa == "https") {
                                ya = z;
                                za = ba;
                                n.setLoggedIntoFacebook(va.logged_in === "true");
                            } else {
                                ya = y;
                                za = aa;
                            }
                            if (va.registered) {
                                pa(va.registered);
                                x = ya.merge(x);
                            }
                            j.info("Proxy ready, starting queue %s containing %s messages", xa + "ProxyQueue", ya.getLength());
                            ya.start(function(bb) {
                                ka.send(typeof bb === "string" ? bb : k.encode(bb), wa, za.contentWindow, ia + "_" + xa);
                            });
                            break;

                          case "plugin_ready":
                            j.info("Plugin %s ready, protocol: %s", va.name, xa);
                            na[va.name] = {
                                protocol: xa
                            };
                            if (l.exists(va.name)) {
                                var ab = l.get(va.name);
                                j.debug("Enqueuing %s messages for %s in %s", ab.getLength(), va.name, xa + "ProxyQueue");
                                (xa == "https" ? z : y).merge(ab);
                            }
                            break;
                        }
                        if (va.data) ra(va.data, wa);
                    }
                    function ra(va, wa) {
                        if (wa && wa !== "native" && !t(new p(wa))) return;
                        if (typeof va == "string") {
                            if (/^FB_RPC:/.test(va)) {
                                oa.enqueue(va.substring(7));
                                return;
                            }
                            if (va.substring(0, 1) == "{") {
                                try {
                                    va = ES("JSON", "parse", false, va);
                                } catch (xa) {
                                    j.warn("Failed to decode %s as JSON", va);
                                    return;
                                }
                            } else va = k.decode(va);
                        }
                        if (!wa) if (va.xd_sig == ca) wa = va.xd_origin;
                        if (va.xd_action) {
                            qa(va, wa);
                            return;
                        }
                        if (va.access_token) n.setSecure(/^https/.test(ja));
                        if (va.cb) {
                            var ya = ua._callbacks[va.cb];
                            if (!ua._forever[va.cb]) delete ua._callbacks[va.cb];
                            if (ya) ya(va);
                        }
                    }
                    function sa(va, wa) {
                        if (va == "facebook") {
                            wa.relation = "parent.parent";
                            x.enqueue(wa);
                        } else {
                            wa.relation = 'parent.frames["' + va + '"]';
                            var xa = na[va];
                            if (xa) {
                                j.debug("Enqueuing message for plugin %s in %s", va, xa.protocol + "ProxyQueue");
                                (xa.protocol == "https" ? z : y).enqueue(wa);
                            } else {
                                j.debug("Buffering message for plugin %s", va);
                                l.get(va).enqueue(wa);
                            }
                        }
                    }
                    m.getOutQueue().start(function(va) {
                        sa("facebook", "FB_RPC:" + va);
                    });
                    function ta(va) {
                        if (la) return;
                        var wa = h.appendHidden(document.createElement("div")), xa = s.create({
                            blacklist: null,
                            root: wa,
                            channel: ia,
                            flashUrl: r.Flash.path,
                            whenReady: function(ya) {
                                ka = ya;
                                var za = {
                                    channel: ia,
                                    origin: ja,
                                    transport: xa,
                                    xd_name: va
                                }, ab = "#" + k.encode(za);
                                if (n.getSecure() !== true) aa = u({
                                    url: fa + ab,
                                    name: "fb_xdm_frame_http",
                                    id: "fb_xdm_frame_http",
                                    root: wa,
                                    "aria-hidden": true,
                                    title: ma,
                                    tabindex: -1
                                });
                                ba = u({
                                    url: ga + ab,
                                    name: "fb_xdm_frame_https",
                                    id: "fb_xdm_frame_https",
                                    root: wa,
                                    "aria-hidden": true,
                                    title: ma,
                                    tabindex: -1
                                });
                            },
                            onMessage: ra
                        });
                        if (!xa) o.log("jssdk_error", {
                            appId: n.getClientID(),
                            error: "XD_TRANSPORT",
                            extra: {
                                message: "Failed to create a valid transport"
                            }
                        });
                        la = true;
                    }
                    var ua = {
                        rpc: m,
                        _callbacks: {},
                        _forever: {},
                        _channel: ia,
                        _origin: ja,
                        onMessage: ra,
                        recv: ra,
                        init: ta,
                        sendToFacebook: sa,
                        inform: function(va, wa, xa, ya) {
                            sa("facebook", {
                                method: va,
                                params: ES("JSON", "stringify", false, wa || {}),
                                behavior: ya || "p",
                                relation: xa
                            });
                        },
                        handler: function(va, wa, xa, ya) {
                            var za = "#" + k.encode({
                                cb: this.registerCallback(va, xa, ya),
                                origin: ja + "/" + ia,
                                domain: location.hostname,
                                relation: wa || "opener"
                            });
                            return (location.protocol == "https:" ? ga : fa) + za;
                        },
                        registerCallback: function(va, wa, xa) {
                            xa = xa || w();
                            if (wa) ua._forever[xa] = true;
                            ua._callbacks[xa] = va;
                            return xa;
                        },
                        getXDArbiterURL: function(va) {
                            return va ? ga : fa;
                        }
                    };
                    i.subscribe("init:post", function(va) {
                        ta(va.xdProxyName);
                        var wa = v("xd_timeout", false);
                        if (wa) setTimeout(function() {
                            var xa = ba && !!aa == y.isStarted() && !!ba == z.isStarted();
                            if (!xa) o.log("jssdk_error", {
                                appId: n.getClientID(),
                                error: "XD_INITIALIZATION",
                                extra: {
                                    message: "Failed to initialize in " + wa + "ms"
                                }
                            });
                        }, wa);
                    });
                    f.exports = ua;
                }, null);
                __d("sdk.getContextType", [ "sdk.Runtime", "sdk.UA" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    function j() {
                        if (i.nativeApp()) return 3;
                        if (i.mobile()) return 2;
                        if (h.isEnvironment(h.ENVIRONMENTS.CANVAS)) return 5;
                        return 1;
                    }
                    f.exports = j;
                }, null);
                __d("sdk.Auth", [ "sdk.Cookie", "sdk.createIframe", "DOMWrapper", "sdk.feature", "sdk.getContextType", "guid", "sdk.Impressions", "Log", "ObservableMixin", "sdk.Runtime", "sdk.Scribe", "sdk.SignedRequest", "UrlMap", "sdk.URI", "sdk.XD" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v) {
                    if (c.__markCompiled) c.__markCompiled();
                    var w = "fblo_", x = 365 * 24 * 60 * 60 * 1e3, y, z, aa = new p();
                    function ba(ja, ka) {
                        var la = q.getUserID(), ma = "";
                        if (ja) if (ja.userID) {
                            ma = ja.userID;
                        } else if (ja.signedRequest) {
                            var na = s.parse(ja.signedRequest);
                            if (na && na.user_id) ma = na.user_id;
                        }
                        var oa = q.getLoginStatus(), pa = oa === "unknown" && ja || q.getUseCookie() && q.getCookieUserID() !== ma, qa = la && !ja, ra = ja && la && la != ma, sa = ja != y, ta = ka != (oa || "unknown");
                        q.setLoginStatus(ka);
                        q.setAccessToken(ja && ja.accessToken || null);
                        q.setUserID(ma);
                        y = ja;
                        var ua = {
                            authResponse: ja,
                            status: ka
                        };
                        if (qa || ra) aa.inform("logout", ua);
                        if (pa || ra) aa.inform("login", ua);
                        if (sa) aa.inform("authresponse.change", ua);
                        if (ta) aa.inform("status.change", ua);
                        return ua;
                    }
                    function ca() {
                        return y;
                    }
                    function da(ja, ka, la) {
                        return function(ma) {
                            var na;
                            if (ma && ma.access_token) {
                                var oa = s.parse(ma.signed_request);
                                ka = {
                                    accessToken: ma.access_token,
                                    userID: oa.user_id,
                                    expiresIn: parseInt(ma.expires_in, 10),
                                    signedRequest: ma.signed_request
                                };
                                if (ma.granted_scopes) ka.grantedScopes = ma.granted_scopes;
                                if (q.getUseCookie()) {
                                    var pa = ka.expiresIn === 0 ? 0 : ES("Date", "now", false) + ka.expiresIn * 1e3, qa = h.getDomain();
                                    if (!qa && ma.base_domain) h.setDomain("." + ma.base_domain);
                                    h.setSignedRequestCookie(ma.signed_request, pa);
                                    ea();
                                }
                                na = "connected";
                                ba(ka, na);
                            } else if (la === "logout" || la === "login_status") {
                                if (ma.error && ma.error === "not_authorized") {
                                    na = "not_authorized";
                                } else na = "unknown";
                                ba(null, na);
                                if (q.getUseCookie()) h.clearSignedRequestCookie();
                                if (la === "logout") {
                                    fa();
                                    r.log("jssdk_error", {
                                        appId: q.getClientID(),
                                        error: "PLATFORM_AUTH_LOGOUT",
                                        extra: {
                                            args: {
                                                fblo: true
                                            }
                                        }
                                    });
                                }
                            }
                            if (ma && ma.https == 1) q.setSecure(true);
                            if (ja) ja({
                                authResponse: ka,
                                status: q.getLoginStatus()
                            });
                            return ka;
                        };
                    }
                    function ea() {
                        h.setRaw(w, "", 0);
                    }
                    function fa() {
                        h.setRaw(w, "y", ES("Date", "now", false) + x);
                    }
                    function ga(ja) {
                        var ka, la = ES("Date", "now", false);
                        if (z) {
                            clearTimeout(z);
                            z = null;
                        }
                        var ma = h.getRaw(w) === "y";
                        if (k("getloginstatus_tracking", true)) r.log("jssdk_error", {
                            appId: q.getClientID(),
                            error: "PLATFORM_AUTH_GETLOGINSTATUS",
                            extra: {
                                args: {
                                    fblo: ma
                                }
                            }
                        });
                        if (ma) {
                            var na = "unknown";
                            ba(null, na);
                            if (ja) ja({
                                authResponse: null,
                                status: na
                            });
                            return;
                        }
                        var oa = da(ja, y, "login_status"), pa = new u(t.resolve("www", true) + "/connect/ping").setQueryData({
                            client_id: q.getClientID(),
                            response_type: "token,signed_request,code",
                            domain: location.hostname,
                            origin: l(),
                            redirect_uri: v.handler(function(qa) {
                                if (k("e2e_ping_tracking", true)) {
                                    var ra = {
                                        init: la,
                                        close: ES("Date", "now", false),
                                        method: "ping"
                                    };
                                    o.debug("e2e: %s", ES("JSON", "stringify", false, ra));
                                    n.log(114, {
                                        payload: ra
                                    });
                                }
                                ka.parentNode.removeChild(ka);
                                if (oa(qa)) z = setTimeout(function() {
                                    ga(function() {});
                                }, 12e5);
                            }, "parent"),
                            sdk: "joey",
                            kid_directed_site: q.getKidDirectedSite()
                        });
                        ka = i({
                            root: j.getRoot(),
                            name: m(),
                            url: pa.toString(),
                            style: {
                                display: "none"
                            }
                        });
                    }
                    var ha;
                    function ia(ja, ka) {
                        if (!q.getClientID()) {
                            o.warn("FB.getLoginStatus() called before calling FB.init().");
                            return;
                        }
                        if (ja) if (!ka && ha == "loaded") {
                            ja({
                                status: q.getLoginStatus(),
                                authResponse: ca()
                            });
                            return;
                        } else aa.subscribe("FB.loginStatus", ja);
                        if (!ka && ha == "loading") return;
                        ha = "loading";
                        var la = function(ma) {
                            ha = "loaded";
                            aa.inform("FB.loginStatus", ma);
                            aa.clearSubscribers("FB.loginStatus");
                        };
                        ga(la);
                    }
                    ES("Object", "assign", false, aa, {
                        removeLogoutState: ea,
                        getLoginStatus: ia,
                        fetchLoginStatus: ga,
                        setAuthResponse: ba,
                        getAuthResponse: ca,
                        parseSignedRequest: s.parse,
                        xdResponseWrapper: da
                    });
                    f.exports = aa;
                }, null);
                __d("sdk.DOM", [ "Assert", "sdk.UA", "sdk.domReady" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = {};
                    function l(z, aa) {
                        var ba = z.getAttribute(aa) || z.getAttribute(aa.replace(/_/g, "-")) || z.getAttribute(aa.replace(/-/g, "_")) || z.getAttribute(aa.replace(/-/g, "")) || z.getAttribute(aa.replace(/_/g, "")) || z.getAttribute("data-" + aa) || z.getAttribute("data-" + aa.replace(/_/g, "-")) || z.getAttribute("data-" + aa.replace(/-/g, "_")) || z.getAttribute("data-" + aa.replace(/-/g, "")) || z.getAttribute("data-" + aa.replace(/_/g, ""));
                        return ba ? String(ba) : null;
                    }
                    function m(z, aa) {
                        var ba = l(z, aa);
                        return ba ? /^(true|1|yes|on)$/.test(ba) : null;
                    }
                    function n(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        try {
                            return String(z[aa]);
                        } catch (ba) {
                            throw new Error("Could not read property " + aa + " : " + ba.message);
                        }
                    }
                    function o(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        try {
                            z.innerHTML = aa;
                        } catch (ba) {
                            throw new Error("Could not set innerHTML : " + ba.message);
                        }
                    }
                    function p(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        var ba = " " + n(z, "className") + " ";
                        return ES(ba, "indexOf", true, " " + aa + " ") >= 0;
                    }
                    function q(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        if (!p(z, aa)) z.className = n(z, "className") + " " + aa;
                    }
                    function r(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        var ba = new RegExp("\\s*" + aa, "g");
                        z.className = ES(n(z, "className").replace(ba, ""), "trim", true);
                    }
                    function s(z, aa, ba) {
                        h.isString(z);
                        aa = aa || document.body;
                        ba = ba || "*";
                        if (aa.querySelectorAll) return ES("Array", "from", false, aa.querySelectorAll(ba + "." + z));
                        var ca = aa.getElementsByTagName(ba), da = [];
                        for (var ea = 0, fa = ca.length; ea < fa; ea++) if (p(ca[ea], z)) da[da.length] = ca[ea];
                        return da;
                    }
                    function t(z, aa) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        aa = aa.replace(/-(\w)/g, function(da, ea) {
                            return ea.toUpperCase();
                        });
                        var ba = z.currentStyle || document.defaultView.getComputedStyle(z, null), ca = ba[aa];
                        if (/backgroundPosition?/.test(aa) && /top|left/.test(ca)) ca = "0%";
                        return ca;
                    }
                    function u(z, aa, ba) {
                        h.isTruthy(z, "element not specified");
                        h.isString(aa);
                        aa = aa.replace(/-(\w)/g, function(ca, da) {
                            return da.toUpperCase();
                        });
                        z.style[aa] = ba;
                    }
                    function v(z, aa) {
                        var ba = true;
                        for (var ca = 0, da; da = aa[ca++]; ) if (!(da in k)) {
                            ba = false;
                            k[da] = true;
                        }
                        if (ba) return;
                        if (i.ie() < 11) {
                            try {
                                document.createStyleSheet().cssText = z;
                            } catch (ea) {
                                if (document.styleSheets[0]) document.styleSheets[0].cssText += z;
                            }
                        } else {
                            var fa = document.createElement("style");
                            fa.type = "text/css";
                            fa.textContent = z;
                            document.getElementsByTagName("head")[0].appendChild(fa);
                        }
                    }
                    function w() {
                        var z = document.documentElement && document.compatMode == "CSS1Compat" ? document.documentElement : document.body;
                        return {
                            scrollTop: z.scrollTop || document.body.scrollTop,
                            scrollLeft: z.scrollLeft || document.body.scrollLeft,
                            width: window.innerWidth ? window.innerWidth : z.clientWidth,
                            height: window.innerHeight ? window.innerHeight : z.clientHeight
                        };
                    }
                    function x(z) {
                        h.isTruthy(z, "element not specified");
                        var aa = 0, ba = 0;
                        do {
                            aa += z.offsetLeft;
                            ba += z.offsetTop;
                        } while (z = z.offsetParent);
                        return {
                            x: aa,
                            y: ba
                        };
                    }
                    var y = {
                        containsCss: p,
                        addCss: q,
                        removeCss: r,
                        getByClass: s,
                        getStyle: t,
                        setStyle: u,
                        getAttr: l,
                        getBoolAttr: m,
                        getProp: n,
                        html: o,
                        addCssRules: v,
                        getViewportInfo: w,
                        getPosition: x,
                        ready: j
                    };
                    f.exports = y;
                }, null);
                __d("normalizeError", [ "sdk.UA" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j) {
                        var k = {
                            line: j.lineNumber || j.line,
                            message: j.message,
                            name: j.name,
                            script: j.fileName || j.sourceURL || j.script,
                            stack: j.stackTrace || j.stack
                        };
                        k._originalError = j;
                        var l = /([\w:\.\/]+\.js):(\d+)/.exec(j.stack);
                        if (h.chrome() && l) {
                            k.script = l[1];
                            k.line = parseInt(l[2], 10);
                        }
                        for (var m in k) k[m] == null && delete k[m];
                        return k;
                    }
                    f.exports = i;
                }, null);
                __d("sdk.ErrorHandling", [ "ManagedError", "sdk.Runtime", "sdk.Scribe", "sdk.feature", "normalizeError", "wrapFunction" ], function a(b, c, d, e, f, g, h, i, j, k, l, m) {
                    if (c.__markCompiled) c.__markCompiled();
                    var n = k("error_handling", false), o = "";
                    function p(v) {
                        var w = v._originalError;
                        delete v._originalError;
                        j.log("jssdk_error", {
                            appId: i.getClientID(),
                            error: v.name || v.message,
                            extra: v
                        });
                        throw w;
                    }
                    function q(v, w) {
                        return function() {
                            if (!n) return v.apply(this, arguments);
                            try {
                                o = w;
                                return v.apply(this, arguments);
                            } catch (x) {
                                if (x instanceof h) throw x;
                                var y = l(x);
                                y.entry = w;
                                var z = ES(Array.prototype.slice.call(arguments), "map", true, function(aa) {
                                    var ba = Object.prototype.toString.call(aa);
                                    return /^\[object (String|Number|Boolean|Object|Date)\]$/.test(ba) ? aa : aa.toString();
                                });
                                y.args = ES("JSON", "stringify", false, z).substring(0, 200);
                                p(y);
                            } finally {
                                o = "";
                            }
                        };
                    }
                    function r(v) {
                        if (!v.__wrapper) v.__wrapper = function() {
                            try {
                                return v.apply(this, arguments);
                            } catch (w) {
                                window.setTimeout(function() {
                                    throw w;
                                }, 0);
                                return false;
                            }
                        };
                        return v.__wrapper;
                    }
                    function s(v) {
                        try {
                            return v && v.callee && v.callee.caller ? v.callee.caller.name : "";
                        } catch (w) {
                            return "";
                        }
                    }
                    function t(v, w) {
                        return function(x, y) {
                            var z = w + ":" + (o || "[global]") + ":" + (x.name || "[anonymous]" + s(arguments));
                            return v(m(x, "entry", z), y);
                        };
                    }
                    if (n) {
                        setTimeout = t(setTimeout, "setTimeout");
                        setInterval = t(setInterval, "setInterval");
                        m.setWrapper(q, "entry");
                    }
                    var u = {
                        guard: q,
                        unguard: r
                    };
                    f.exports = u;
                }, null);
                __d("sdk.Insights", [ "sdk.Impressions" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {
                        TYPE: {
                            NOTICE: "notice",
                            WARNING: "warn",
                            ERROR: "error"
                        },
                        CATEGORY: {
                            DEPRECATED: "deprecated",
                            APIERROR: "apierror"
                        },
                        log: function(j, k, l) {
                            var m = {
                                source: "jssdk",
                                type: j,
                                category: k,
                                payload: l
                            };
                            h.log(113, m);
                        },
                        impression: h.impression
                    };
                    f.exports = i;
                }, null);
                __d("FB", [ "sdk.Auth", "JSSDKCssConfig", "dotAccess", "sdk.domReady", "sdk.DOM", "sdk.ErrorHandling", "sdk.Content", "DOMWrapper", "GlobalCallback", "sdk.Insights", "Log", "sdk.Runtime", "sdk.Scribe", "JSSDKConfig" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
                    if (c.__markCompiled) c.__markCompiled();
                    var v, w, x = j(u, "api.mode"), y = {};
                    v = window.FB = {};
                    var z = {};
                    r.level = 0;
                    p.setPrefix("FB.__globalCallbacks");
                    var aa = document.createElement("div");
                    o.setRoot(aa);
                    k(function() {
                        r.info("domReady");
                        n.appendHidden(aa);
                        if (i.rules) l.addCssRules(i.rules, i.components);
                    });
                    s.subscribe("AccessToken.change", function(da) {
                        if (!da && s.getLoginStatus() === "connected") h.getLoginStatus(null, true);
                    });
                    if (j(u, "api.whitelist.length")) {
                        w = {};
                        ES(u.api.whitelist, "forEach", true, function(da) {
                            w[da] = 1;
                        });
                    }
                    function ba(da, ea, fa, ga) {
                        var ha;
                        if (/^_/.test(fa)) {
                            ha = "hide";
                        } else if (w && !w[ea]) ha = x;
                        switch (ha) {
                          case "hide":
                            return;

                          case "stub":
                            return function() {
                                r.warn("The method FB.%s has been removed from the JS SDK.", ea);
                            };

                          default:
                            return m.guard(function() {
                                if (ha === "warn") {
                                    r.warn("The method FB.%s is not officially supported by " + "Facebook and access to it will soon be removed.", ea);
                                    if (!y.hasOwnProperty(ea)) {
                                        q.log(q.TYPE.WARNING, q.CATEGORY.DEPRECATED, "FB." + ea);
                                        t.log("jssdk_error", {
                                            appId: s.getClientID(),
                                            error: "Private method used",
                                            extra: {
                                                args: ea
                                            }
                                        });
                                        y[ea] = true;
                                    }
                                }
                                function ia(pa) {
                                    if (ES("Array", "isArray", false, pa)) return ES(pa, "map", true, ia);
                                    if (pa && typeof pa === "object" && pa.__wrapped) return pa.__wrapped;
                                    return typeof pa === "function" && /^function/.test(pa.toString()) ? m.unguard(pa) : pa;
                                }
                                var ja = ES(Array.prototype.slice.call(arguments), "map", true, ia), ka = da.apply(ga, ja), la, ma = true;
                                if (ka && typeof ka === "object") {
                                    la = ES("Object", "create", false, ka);
                                    la.__wrapped = ka;
                                    for (var na in ka) {
                                        var oa = ka[na];
                                        if (typeof oa !== "function" || na === "constructor") continue;
                                        ma = false;
                                        la[na] = ba(oa, ea + ":" + na, na, ka);
                                    }
                                }
                                if (!ma) return la;
                                return ma ? ka : la;
                            }, ea);
                        }
                    }
                    function ca(da, ea) {
                        var fa = da ? j(v, da, true) : v;
                        ES(ES("Object", "keys", false, ea), "forEach", true, function(ga) {
                            var ha = ea[ga];
                            if (typeof ha === "function") {
                                var ia = (da ? da + "." : "") + ga, ja = ba(ha, ia, ga, ea);
                                if (ja) fa[ga] = ja;
                            } else if (typeof ha === "object") {
                                ia = (da ? da + "." : "") + ga;
                                if (w && w[ia]) fa[ga] = ha;
                            }
                        });
                    }
                    s.setSecure(function() {
                        var da = /iframe_canvas|app_runner/.test(window.name), ea = /dialog/.test(window.name);
                        if (location.protocol == "https:" && (window == top || !(da || ea))) return true;
                        if (/_fb_https?/.test(window.name)) return ES(window.name, "indexOf", true, "_fb_https") != -1;
                    }());
                    ES("Object", "assign", false, z, {
                        provide: ca
                    });
                    f.exports = z;
                }, null);
                __d("ArgumentError", [ "ManagedError" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j, k) {
                        h.prototype.constructor.apply(this, arguments);
                    }
                    i.prototype = new h();
                    i.prototype.constructor = i;
                    f.exports = i;
                }, null);
                __d("errorCode", [], function a(b, c, d, e, f, g) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        throw new Error("errorCode" + '("' + i + '"): This should not happen. Oh noes!');
                    }
                    f.exports = h;
                }, null);
                __d("CORSRequest", [ "wrapFunction", "QueryString", "errorCode" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    function k(n, o) {
                        if (!self.XMLHttpRequest) return null;
                        var p = new XMLHttpRequest(), q = function() {};
                        if ("withCredentials" in p) {
                            p.open(n, o, true);
                            p.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                        } else if (self.XDomainRequest) {
                            p = new XDomainRequest();
                            try {
                                p.open(n, o);
                                p.onprogress = p.ontimeout = q;
                            } catch (r) {
                                return null;
                            }
                        } else return null;
                        var s = {
                            send: function(v) {
                                p.send(v);
                            }
                        }, t = h(function() {
                            t = q;
                            if ("onload" in s) s.onload(p);
                        }, "entry", "XMLHttpRequest:load"), u = h(function() {
                            u = q;
                            if ("onerror" in s) s.onerror(p);
                        }, "entry", "XMLHttpRequest:error");
                        p.onload = function() {
                            t();
                        };
                        p.onerror = function() {
                            u();
                        };
                        p.onreadystatechange = function() {
                            if (p.readyState == 4) if (p.status == 200) {
                                t();
                            } else u();
                        };
                        return s;
                    }
                    function l(n, o, p, q) {
                        p.suppress_http_code = 1;
                        var r = i.encode(p);
                        if (o != "post") {
                            n = i.appendToUrl(n, r);
                            r = "";
                        }
                        var s = k(o, n);
                        if (!s) return false;
                        s.onload = function(t) {
                            q(ES("JSON", "parse", false, t.responseText));
                        };
                        s.onerror = function(t) {
                            if (t.responseText) {
                                q(ES("JSON", "parse", false, t.responseText));
                            } else q({
                                error: {
                                    code: 1,
                                    error_subcode: 1357045,
                                    message: "unknown error (empty response)",
                                    status: t.status,
                                    type: "http"
                                }
                            });
                        };
                        s.send(r);
                        return true;
                    }
                    var m = {
                        execute: l
                    };
                    f.exports = m;
                }, null);
                __d("FlashRequest", [ "DOMWrapper", "Flash", "GlobalCallback", "QueryString", "Queue" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    var m, n = {}, o, p;
                    function q() {
                        if (!o) throw new Error("swfUrl has not been set");
                        var t = j.create(function() {
                            m.start(function(v) {
                                var w = p.execute(v.method, v.url, v.body);
                                if (!w) throw new Error("Could create request");
                                n[w] = v.callback;
                            });
                        }), u = j.create(function(v, w, x) {
                            var y;
                            try {
                                y = ES("JSON", "parse", false, decodeURIComponent(x));
                            } catch (z) {
                                y = {
                                    error: {
                                        type: "SyntaxError",
                                        message: z.message,
                                        status: w,
                                        raw: x
                                    }
                                };
                            }
                            n[v](y);
                            delete n[v];
                        });
                        p = i.embed(o, h.getRoot(), null, {
                            log: false,
                            initCallback: t,
                            requestCallback: u
                        });
                    }
                    function r(t, u, v, w) {
                        v.suppress_http_code = 1;
                        if (!v.method) v.method = u;
                        var x = k.encode(v);
                        if (u === "get" && t.length + x.length < 2e3) {
                            t = k.appendToUrl(t, x);
                            x = "";
                        } else u = "post";
                        if (!m) {
                            if (!i.isAvailable()) return false;
                            m = new l();
                            q();
                        }
                        m.enqueue({
                            method: u,
                            url: t,
                            body: x,
                            callback: w
                        });
                        return true;
                    }
                    var s = {
                        setSwfUrl: function(t) {
                            o = t;
                        },
                        execute: r
                    };
                    f.exports = s;
                }, null);
                __d("JSONPRequest", [ "DOMWrapper", "GlobalCallback", "QueryString" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = 2e3;
                    function l(n, o, p, q) {
                        var r = document.createElement("script"), s = function(u) {
                            s = function() {};
                            i.remove(p.callback);
                            q(u);
                            r.parentNode.removeChild(r);
                        };
                        p.callback = i.create(s);
                        if (!p.method) p.method = o;
                        n = j.appendToUrl(n, p);
                        if (n.length > k) {
                            i.remove(p.callback);
                            return false;
                        }
                        r.onerror = function() {
                            s({
                                error: {
                                    type: "http",
                                    message: "unknown error"
                                }
                            });
                        };
                        var t = function() {
                            setTimeout(function() {
                                s({
                                    error: {
                                        type: "http",
                                        message: "unknown error"
                                    }
                                });
                            }, 0);
                        };
                        if (r.addEventListener) {
                            r.addEventListener("load", t, false);
                        } else r.onreadystatechange = function() {
                            if (/loaded|complete/.test(this.readyState)) t();
                        };
                        r.src = n;
                        h.getRoot().appendChild(r);
                        return true;
                    }
                    var m = {
                        execute: l,
                        MAX_QUERYSTRING_LENGTH: k
                    };
                    f.exports = m;
                }, null);
                __d("flattenObject", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        var j = {};
                        for (var k in i) if (i.hasOwnProperty(k)) {
                            var l = i[k];
                            if (null === l || undefined === l) {
                                continue;
                            } else if (typeof l == "string") {
                                j[k] = l;
                            } else j[k] = ES("JSON", "stringify", false, l);
                        }
                        return j;
                    }
                    f.exports = h;
                }, null);
                __d("ApiClient", [ "ArgumentError", "Assert", "CORSRequest", "FlashRequest", "flattenObject", "JSONPRequest", "Log", "ObservableMixin", "QueryString", "sprintf", "sdk.URI", "UrlMap", "ApiClientConfig", "invariant" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u) {
                    if (c.__markCompiled) c.__markCompiled();
                    var v, w, x, y = m.MAX_QUERYSTRING_LENGTH, z = {
                        get: true,
                        post: true,
                        "delete": true,
                        put: true
                    }, aa = {
                        fql_query: true,
                        fql_multiquery: true,
                        friends_get: true,
                        notifications_get: true,
                        stream_get: true,
                        users_getinfo: true
                    }, ba = [ "jsonp", "cors", "flash" ], ca = [], da = [], ea = null, fa = 0, ga = [], ha = 0, ia = 50, ja = 105440539523;
                    function ka(ua, va, wa, xa) {
                        var ya = ha !== 0 && fa >= ha;
                        if (ya) {
                            ga.push(function() {
                                return ka(ua, va, wa, xa);
                            });
                            sa.inform("request.queued", ua, va, wa);
                            return;
                        }
                        fa++;
                        if (x) wa = ES("Object", "assign", false, {}, x, wa);
                        wa.pretty = wa.pretty || 0;
                        wa = l(wa);
                        var za = {
                            jsonp: m,
                            cors: j,
                            flash: k
                        }, ab = wa.access_token || v;
                        if (ab) {
                            ua = p.appendToUrl(ua, {
                                access_token: ab
                            });
                            delete wa.access_token;
                        }
                        var bb;
                        if (wa.transport) {
                            bb = [ wa.transport ];
                            delete wa.transport;
                        } else bb = ba;
                        for (var cb = 0; cb < bb.length; cb++) {
                            var db = za[bb[cb]], eb = ES("Object", "assign", false, {}, wa);
                            if (db.execute(ua, va, eb, xa)) return;
                        }
                        xa({
                            error: {
                                type: "no-transport",
                                message: "Could not find a usable transport for request"
                            }
                        });
                    }
                    function la(ua, va, wa, xa, ya, za) {
                        if (za && za.error) sa.inform("request.error", va, wa, xa, za, ES("Date", "now", false) - ya);
                        sa.inform("request.complete", va, wa, xa, za, ES("Date", "now", false) - ya);
                        fa--;
                        if (ua) ua(za);
                        var ab = ga.length > 0 && fa < ha;
                        if (ab) {
                            var bb = ga.shift();
                            bb();
                        }
                    }
                    function ma(ua) {
                        var va = ua.shift();
                        i.isString(va, "Invalid path");
                        if (!/^https?/.test(va) && va.charAt(0) !== "/") va = "/" + va;
                        var wa, xa = {};
                        try {
                            wa = new r(va);
                        } catch (ya) {
                            throw new h(ya.message, ya);
                        }
                        ES(ua, "forEach", true, function(cb) {
                            return xa[typeof cb] = cb;
                        });
                        var za = (xa.string || "get").toLowerCase();
                        i.isTrue(z.hasOwnProperty(za), q("Invalid method passed to ApiClient: %s", za));
                        var ab = xa["function"];
                        if (!ab) n.warn("No callback passed to the ApiClient");
                        if (xa.object) wa.addQueryData(l(xa.object));
                        var bb = wa.getQueryData();
                        bb.method = za;
                        return {
                            uri: wa,
                            callback: ab,
                            params: bb
                        };
                    }
                    function na() {
                        for (var ua = arguments.length, va = Array(ua), wa = 0; wa < ua; wa++) va[wa] = arguments[wa];
                        var xa = ma(va), ya = xa.uri, za = xa.callback, ab = xa.params, bb = ab.method;
                        if (ta(ya, bb)) bb = "post";
                        var cb = ya.getProtocol() && ya.getDomain() ? ya.setQueryData({}).toString() : s.resolve("graph") + ya.getPath();
                        sa.inform("request.prepare", cb, ab);
                        ka(cb, bb == "get" ? "get" : "post", ab, ES(la, "bind", true, null, za, ya.getPath(), bb, ab, ES("Date", "now", false)));
                    }
                    function oa(ua) {
                        var va = ma(ua), wa = va.uri, xa = va.callback, ya = va.params.method, za, ab = wa.removeQueryData("method").toString();
                        if (ya.toLowerCase() == "post") {
                            za = p.encode(wa.getQueryData());
                            ab = wa.setQueryData({}).toString();
                        }
                        return {
                            body: za,
                            callback: xa,
                            method: ya,
                            relative_url: ab
                        };
                    }
                    function pa() {
                        for (var ua = arguments.length, va = Array(ua), wa = 0; wa < ua; wa++) va[wa] = arguments[wa];
                        var xa = oa(va), ya = xa.body, za = xa.callback, ab = xa.method, bb = xa.relative_url, cb = {
                            method: ab,
                            relative_url: bb
                        };
                        if (ya) cb.body = ya;
                        ca.push(cb);
                        da.push(za);
                        if (ca.length == ia) {
                            if (ea) clearTimeout(ea);
                            qa();
                        } else if (!ea) ea = setTimeout(qa, 0);
                    }
                    function qa() {
                        !(ca.length > 0) ? u(0) : void 0;
                        !(ca.length === da.length) ? u(0) : void 0;
                        var ua = ca, va = da;
                        ca = [];
                        da = [];
                        ea = null;
                        if (ua.length === 1) {
                            var wa = ua[0], xa = va[0], ya = wa.body ? p.decode(wa.body) : null;
                            na(wa.relative_url, wa.method, ya, xa);
                            return;
                        }
                        na("/", "POST", {
                            batch: ua,
                            include_headers: false,
                            batch_app_id: w || ja
                        }, function(za) {
                            if (ES("Array", "isArray", false, za)) {
                                ES(za, "forEach", true, function(ab, bb) {
                                    va[bb](ES("JSON", "parse", false, ab.body));
                                });
                            } else ES(va, "forEach", true, function(ab) {
                                return ab({
                                    error: {
                                        message: "Fatal: batch call failed."
                                    }
                                });
                            });
                        });
                    }
                    function ra(ua, va) {
                        i.isObject(ua);
                        i.isString(ua.method, "method missing");
                        if (!va) n.warn("No callback passed to the ApiClient");
                        var wa = ua.method.toLowerCase().replace(".", "_");
                        ua.format = "json-strings";
                        ua.api_key = w;
                        var xa = wa in aa ? "api_read" : "api", ya = s.resolve(xa) + "/restserver.php", za = ES(la, "bind", true, null, va, "/restserver.php", "get", ua, ES("Date", "now", false));
                        ka(ya, "get", ua, za);
                    }
                    var sa = ES("Object", "assign", false, new o(), {
                        setAccessToken: function(ua) {
                            v = ua;
                        },
                        setAccessTokenForClientID: function(ua, va) {
                            if (!(v && w && w !== va)) v = ua;
                        },
                        getAccessToken: function() {
                            return v;
                        },
                        setClientID: function(ua) {
                            w = ua;
                        },
                        setDefaultParams: function(ua) {
                            x = ua;
                        },
                        setDefaultTransports: function(ua) {
                            ba = ua;
                        },
                        setMaxConcurrentRequests: function(ua) {
                            ha = ua;
                        },
                        getCurrentlyExecutingRequestCount: function() {
                            return fa;
                        },
                        getQueuedRequestCount: function() {
                            return ga.length;
                        },
                        rest: ra,
                        graph: na,
                        scheduleBatchCall: pa,
                        prepareBatchParams: oa
                    });
                    function ta(ua, va) {
                        return ua.toString().length > y && va === "get";
                    }
                    k.setSwfUrl(t.FlashRequest.swfUrl);
                    f.exports = sa;
                }, null);
                __d("sdk.PlatformVersioning", [ "sdk.Runtime", "ManagedError" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = /^v\d+\.\d\d?$/, k = {
                        REGEX: j,
                        assertVersionIsSet: function() {
                            if (!h.getVersion()) throw new i("init not called with valid version");
                        },
                        assertValidVersion: function(l) {
                            if (!j.test(l)) throw new i("invalid version specified");
                        }
                    };
                    f.exports = k;
                }, null);
                __d("sdk.api", [ "ApiClient", "sdk.PlatformVersioning", "sdk.Runtime", "sdk.Scribe", "sdk.URI", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l, m) {
                    if (c.__markCompiled) c.__markCompiled();
                    var n = m("should_log_response_error", false), o;
                    j.subscribe("ClientID.change", function(q) {
                        return h.setClientID(q);
                    });
                    j.subscribe("AccessToken.change", function(q) {
                        o = q;
                        h.setAccessToken(q);
                    });
                    h.setDefaultParams({
                        sdk: "joey"
                    });
                    h.subscribe("request.complete", function(q, r, s, t) {
                        var u = false;
                        if (t && typeof t == "object") if (t.error) {
                            if (t.error == "invalid_token" || t.error.type == "OAuthException" && t.error.code == 190) u = true;
                        } else if (t.error_code) if (t.error_code == "190") u = true;
                        if (u && o === j.getAccessToken()) j.setAccessToken(null);
                    });
                    h.subscribe("request.complete", function(q, r, s, t) {
                        if ((q == "/me/permissions" && r === "delete" || q == "/restserver.php" && s.method == "Auth.revokeAuthorization") && t === true) j.setAccessToken(null);
                    });
                    h.subscribe("request.error", function(q, r, s, t) {
                        if (n && t.error.type === "http") k.log("jssdk_error", {
                            appId: j.getClientID(),
                            error: "transport",
                            extra: {
                                name: "transport",
                                message: ES("JSON", "stringify", false, t.error)
                            }
                        });
                    });
                    function p(q) {
                        if (typeof q === "string") {
                            if (j.getIsVersioned()) {
                                i.assertVersionIsSet();
                                if (!/https?/.test(q) && q.charAt(0) !== "/") q = "/" + q;
                                q = new l(q).setDomain(null).setProtocol(null).toString();
                                if (!i.REGEX.test(q.substring(1, ES(q, "indexOf", true, "/", 1)))) q = "/" + j.getVersion() + q;
                                var r = [ q ].concat(Array.prototype.slice.call(arguments, 1));
                                h.graph.apply(h, r);
                            } else h.graph.apply(h, arguments);
                        } else h.rest.apply(h, arguments);
                    }
                    f.exports = p;
                }, null);
                __d("legacy:fb.api", [ "FB", "sdk.api" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.provide("", {
                        api: i
                    });
                }, 3);
                __d("sdk.AppEvents", [ "Assert", "sdk.Impressions", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = {
                        COMPLETED_REGISTRATION: "fb_mobile_complete_registration",
                        VIEWED_CONTENT: "fb_mobile_content_view",
                        SEARCHED: "fb_mobile_search",
                        RATED: "fb_mobile_rate",
                        COMPLETED_TUTORIAL: "fb_mobile_tutorial_completion",
                        ADDED_TO_CART: "fb_mobile_add_to_cart",
                        ADDED_TO_WISHLIST: "fb_mobile_add_to_wishlist",
                        INITIATED_CHECKOUT: "fb_mobile_initiated_checkout",
                        ADDED_PAYMENT_INFO: "fb_mobile_add_payment_info",
                        ACHIEVED_LEVEL: "fb_mobile_level_achieved",
                        UNLOCKED_ACHIEVEMENT: "fb_mobile_achievement_unlocked",
                        SPENT_CREDITS: "fb_mobile_spent_credits"
                    }, l = {
                        ACTIVATED_APP: "fb_mobile_activate_app",
                        PURCHASED: "fb_mobile_purchase"
                    }, m = {
                        CURRENCY: "fb_currency",
                        REGISTRATION_METHOD: "fb_registration_method",
                        CONTENT_TYPE: "fb_content_type",
                        CONTENT_ID: "fb_content_id",
                        SEARCH_STRING: "fb_search_string",
                        SUCCESS: "fb_success",
                        MAX_RATING_VALUE: "fb_max_rating_value",
                        PAYMENT_INFO_AVAILABLE: "fb_payment_info_available",
                        NUM_ITEMS: "fb_num_items",
                        LEVEL: "fb_level",
                        DESCRIPTION: "fb_description"
                    }, n = 40, o = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";
                    function p(t, u, v, w) {
                        h.isTrue(q(u), "Invalid event name: " + u + ". " + "It must be between 1 and " + n + " characters, " + "and must be contain only alphanumerics, _, - or spaces, " + "starting with alphanumeric or _.");
                        var x = {
                            ae: 1,
                            ev: u,
                            vts: v,
                            canvas: j.isCanvasEnvironment() ? 1 : 0
                        };
                        if (w) x.cd = w;
                        i.impression({
                            api_key: t,
                            payload: ES("JSON", "stringify", false, x)
                        });
                    }
                    function q(t) {
                        if (t === null || t.length === 0 || t.length > n || !new RegExp(o).test(t)) return false;
                        return true;
                    }
                    function r(t, u, v, w) {
                        var x = {};
                        x[m.CURRENCY] = v;
                        p(t, l.PURCHASED, u, babelHelpers["extends"]({}, w, x));
                    }
                    function s(t) {
                        p(t, l.ACTIVATED_APP);
                    }
                    f.exports = {
                        activateApp: s,
                        logEvent: p,
                        logPurchase: r,
                        isValidEventName: q,
                        EventNames: k,
                        ParameterNames: m
                    };
                }, null);
                __d("legacy:fb.appevents", [ "Assert", "sdk.AppEvents", "FB", "sdk.feature", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    j.provide("AppEvents", {
                        logEvent: function(m, n, o) {
                            h.isTrue(k("allow_non_canvas_app_events", false) || l.isCanvasEnvironment(), "You can only use this function in Facebook Canvas environment");
                            h.isString(m, "Invalid eventName");
                            h.maybeNumber(n, "Invalid valueToSum");
                            h.maybeObject(o, "Invalid params");
                            var p = l.getClientID();
                            h.isTrue(p !== null && p.length > 0, "You need to call FB.init() with App ID first.");
                            i.logEvent(p, m, n, o);
                        },
                        logPurchase: function(m, n, o) {
                            h.isTrue(k("allow_non_canvas_app_events", false) || l.isCanvasEnvironment(), "You can only use this function in Facebook Canvas environment");
                            h.isNumber(m, "Invalid purchaseAmount");
                            h.isString(n, "Invalid currency");
                            h.maybeObject(o, "Invalid params");
                            var p = l.getClientID();
                            h.isTrue(p !== null && p.length > 0, "You need to call FB.init() with App ID first.");
                            i.logPurchase(p, m, n, o);
                        },
                        activateApp: function() {
                            h.isTrue(k("allow_non_canvas_app_events", false) || l.isCanvasEnvironment(), "You can only use this function in Facebook Canvas environment");
                            var m = l.getClientID();
                            h.isTrue(m !== null && m.length > 0, "You need to call FB.init() with App ID first.");
                            i.activateApp(m);
                        },
                        EventNames: i.EventNames,
                        ParameterNames: i.ParameterNames
                    });
                }, 3);
                __d("resolveURI", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        if (!i) return window.location.href;
                        i = i.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
                        var j = document.createElement("div");
                        j.innerHTML = '<a href="' + i + '"></a>';
                        return j.firstChild.href;
                    }
                    f.exports = h;
                }, null);
                __d("sdk.Canvas.Environment", [ "sdk.RPC" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(l) {
                        h.remote.getPageInfo(function(m) {
                            l(m.result);
                        });
                    }
                    function j(l, m) {
                        h.remote.scrollTo({
                            x: l || 0,
                            y: m || 0
                        });
                    }
                    h.stub("getPageInfo");
                    h.stub("scrollTo");
                    var k = {
                        getPageInfo: i,
                        scrollTo: j
                    };
                    f.exports = k;
                }, null);
                __d("sdk.DialogUtils", [ "sdk.Content", "sdk.DOM", "DOMEventListener", "sdk.UA", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var m = {
                        isOrientationPotrait: function() {
                            return window.innerWidth < window.innerHeight;
                        },
                        addDoubleClickAction: function(n, o, p) {
                            var q = null;
                            return j.add(n, "click", function() {
                                if (q !== null) {
                                    clearTimeout(q);
                                    q = null;
                                    o();
                                }
                                q = setTimeout(function() {
                                    q = null;
                                }, p);
                            });
                        },
                        addIdleDesktopAction: function(n, o, p) {
                            var q = void 0, event = void 0, r = function() {
                                q = setTimeout(o, p);
                            };
                            r();
                            return j.add(n, "mouseenter", function() {
                                clearTimeout(q);
                                if (!event) event = j.add(n, "mouseleave", function() {
                                    r();
                                });
                            });
                        },
                        addMobileOrientationChangeAction: function(n) {
                            if (!k.mobile()) return null;
                            var event = "onorientationchange" in window ? "orientationchange" : "resize", o = function(p) {
                                return setTimeout(function(q) {
                                    return n(q);
                                }, 50);
                            };
                            return j.add(window, event, o);
                        },
                        applyScreenDimensions: function(n) {
                            if (n == null) return;
                            var o = i.getViewportInfo();
                            n.style.minHeight = o.height || o.width ? o.height + "px" : "";
                            n.style.top = o.scrollTop ? o.scrollTop + "px" : "";
                        },
                        setDialogPositionToCenter: function(n, o, p) {
                            var q = function(aa) {
                                return typeof aa === "number" ? aa : parseInt(aa, 10);
                            }, r = i.getViewportInfo(), s = q(n.offsetWidth), t = q(n.offsetHeight), u = r.scrollLeft + (r.width - s) / 2, v = (r.height - t) / 2.5;
                            if (u < v) v = u;
                            var w = r.height - t - v, x = (r.height - t) / 2;
                            if (p) x = p.scrollTop - p.offsetTop + (p.clientHeight - t) / 2;
                            if (x < v) {
                                x = v;
                            } else if (x > w) x = w;
                            x += r.scrollTop;
                            if (k.mobile()) {
                                var y = 100;
                                if (o) {
                                    y += (r.height - t) / 2;
                                    i.addCss(document.body, "fb_reposition");
                                } else {
                                    i.addCss(document.body, "fb_hidden");
                                    if (l("dialog_resize_refactor", false)) document.body.style.width = "auto";
                                    x = 1e4;
                                }
                                var z = i.getByClass("fb_dialog_padding", n);
                                if (z.length) z[0].style.height = y + "px";
                            }
                            n.style.left = (u > 0 ? u : 0) + "px";
                            n.style.top = (x > 0 ? x : 0) + "px";
                        },
                        setDialogPositionToTop: function(n, o, p) {
                            this.setDialogPositionToCenter(n, o, p);
                            var q = i.getViewportInfo(), r = q.scrollTop + (q.height - n.offsetHeight) * .05;
                            i.setStyle(n, "top", r + "px");
                        },
                        setupNewDarkOverlay: function() {
                            var n = document.createElement("div");
                            n.setAttribute("id", "fb_dialog_ipad_overlay");
                            this.applyScreenDimensions(n);
                            return n;
                        },
                        setupNewDialog: function(n) {
                            n = n || {};
                            var o = document.createElement("div"), p = n, q = p.onClose;
                            if (n.closeIcon && q) {
                                var r = document.createElement("a");
                                r.className = "fb_dialog_close_icon";
                                j.add(r, "click", q);
                                o.appendChild(r);
                            }
                            var s = "fb_dialog";
                            s += " " + (n.classes || "");
                            if (k.ie()) {
                                s += " fb_dialog_legacy";
                                ES([ "vert_left", "vert_right", "horiz_top", "horiz_bottom", "top_left", "top_right", "bottom_left", "bottom_right" ], "forEach", true, function(w) {
                                    var x = document.createElement("span");
                                    x.className = "fb_dialog_" + w;
                                    o.appendChild(x);
                                });
                            } else s += k.mobile() ? " fb_dialog_mobile" : " fb_dialog_advanced";
                            o.className = s;
                            if (n.width) {
                                var t = parseInt(n.width, 10);
                                if (!isNaN(t)) o.style.width = t + "px";
                            }
                            var u = document.createElement("div");
                            if (n.content) h.append(n.content, u);
                            u.className = "fb_dialog_content";
                            o.appendChild(u);
                            if (k.mobile()) {
                                var v = document.createElement("div");
                                v.className = "fb_dialog_padding";
                                o.appendChild(v);
                            }
                            return {
                                dialogElement: o,
                                contentRoot: u
                            };
                        },
                        onDialogHideCleanup: function(n) {
                            var o = document.body;
                            if (n) {
                                i.removeCss(o, "fb_reposition");
                            } else i.removeCss(o, "fb_hidden");
                        }
                    };
                    f.exports = m;
                }, null);
                __d("sdk.fbt", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        _: function(i) {
                            return typeof i === "string" ? i : i[0];
                        }
                    };
                    f.exports = h;
                }, null);
                __d("sdk.Dialog", [ "sdk.Canvas.Environment", "sdk.Content", "sdk.DialogUtils", "sdk.DOM", "DOMEventListener", "ObservableMixin", "sdk.Runtime", "Type", "sdk.UA", "sdk.fbt", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
                    if (c.__markCompiled) c.__markCompiled();
                    var s = 30, t = 590, u = 500, v = 240, w = 575;
                    function x() {
                        if (r("dialog_resize_refactor", false)) {
                            var aa = k.getViewportInfo();
                            if (aa.height && aa.width) return {
                                width: Math.min(aa.width, u),
                                height: Math.min(aa.height, t)
                            };
                        }
                        return null;
                    }
                    var y = o.extend({
                        constructor: function aa(ba, ca) {
                            this.parent();
                            this.id = ba;
                            this.display = ca;
                            this._e2e = {};
                            if (!z._dialogs) {
                                z._dialogs = {};
                                z._addOrientationHandler();
                            }
                            z._dialogs[ba] = this;
                            this.trackEvent("init");
                        },
                        trackEvent: function(aa, ba) {
                            if (this._e2e[aa]) return this;
                            this._e2e[aa] = ba || ES("Date", "now", false);
                            if (aa == "close") this.inform("e2e:end", this._e2e);
                            return this;
                        },
                        trackEvents: function(aa) {
                            if (typeof aa === "string") aa = ES("JSON", "parse", false, aa);
                            for (var ba in aa) if (aa.hasOwnProperty(ba)) this.trackEvent(ba, aa[ba]);
                            return this;
                        }
                    }, m), z = {
                        newInstance: function(aa, ba) {
                            return new y(aa, ba);
                        },
                        _dialogs: null,
                        _lastYOffset: 0,
                        _overlayListeners: [],
                        _loaderEl: null,
                        _overlayEl: null,
                        _stack: [],
                        _active: null,
                        _forceTabletStyle: null,
                        _closeOnOverlayTap: null,
                        _positionDialogAtTopWhenPortrait: null,
                        get: function(aa) {
                            return z._dialogs[aa];
                        },
                        _findRoot: function(aa) {
                            while (aa) {
                                if (k.containsCss(aa, "fb_dialog")) return aa;
                                aa = aa.parentNode;
                            }
                        },
                        _createWWWLoader: function(aa) {
                            aa = aa ? aa : 460;
                            return z.create({
                                content: '<div class="dialog_title">' + '  <a id="fb_dialog_loader_close">' + '    <div class="fb_dialog_close_icon"></div>' + "  </a>" + "  <span>Facebook</span>" + '  <div style="clear:both;"></div>' + "</div>" + '<div class="dialog_content"></div>' + '<div class="dialog_footer"></div>',
                                width: aa
                            });
                        },
                        _createMobileLoader: function() {
                            var aa;
                            if (p.nativeApp()) {
                                aa = '<div class="dialog_header"></div>';
                            } else if (z.isTabletStyle()) {
                                aa = '<div class="overlayLoader">' + '<div id="fb_dialog_loader_spinner"></div>' + '<a id="fb_dialog_loader_close" href="#">' + q._("Cancel") + "</a>" + "</div>";
                            } else aa = '<div class="dialog_header">' + "<table>" + "  <tbody>" + "    <tr>" + '      <td class="header_left">' + '        <label class="touchable_button">' + '          <input type="submit" value="' + q._("Cancel") + '"' + '            id="fb_dialog_loader_close"/>' + "        </label>" + "      </td>" + '      <td class="header_center">' + "        <div>" + "         " + q._("Loading...") + "        </div>" + "      </td>" + '      <td class="header_right">' + "      </td>" + "    </tr>" + "  </tbody>" + "</table>" + "</div>";
                            return z.create({
                                classes: "loading" + (z.isTabletStyle() ? " centered" : ""),
                                content: aa
                            });
                        },
                        _setDialogOverlayStyle: function() {
                            j.applyScreenDimensions(z._overlayEl);
                        },
                        _showTabletOverlay: function(aa) {
                            if (!z.isTabletStyle()) return;
                            if (!z._overlayEl) {
                                z._overlayEl = j.setupNewDarkOverlay();
                                i.append(z._overlayEl, null);
                            }
                            if (z._closeOnOverlayTap) {
                                var ba = j.addDoubleClickAction(z._overlayEl, ES(aa, "bind", true, this), 5e3);
                                z._overlayListeners.push(ba);
                            }
                            z._overlayEl.className = "";
                        },
                        _hideTabletOverlay: function() {
                            if (z.isTabletStyle()) {
                                z._overlayEl.className = "hidden";
                                ES(z._overlayListeners, "forEach", true, function(aa) {
                                    return aa.remove();
                                });
                                z._overlayListeners = [];
                            }
                        },
                        showLoader: function(aa, ba) {
                            if (!aa) aa = function() {};
                            var ca = function() {
                                z._hideLoader();
                                j.onDialogHideCleanup(z.isTabletStyle());
                                z._hideTabletOverlay();
                                aa();
                            };
                            z._showTabletOverlay(ca);
                            if (!z._loaderEl) z._loaderEl = z._findRoot(p.mobile() ? z._createMobileLoader() : z._createWWWLoader(ba));
                            var da = document.getElementById("fb_dialog_loader_close");
                            if (da) {
                                k.removeCss(da, "fb_hidden");
                                var ea = l.add(da, "click", ca);
                                z._overlayListeners.push(ea);
                            }
                            z._makeActive(z._loaderEl);
                        },
                        setCloseOnOverlayTap: function(aa) {
                            z._closeOnOverlayTap = !!aa;
                        },
                        setPositionDialogAtTopWhenPortrait: function(aa) {
                            z._positionDialogAtTopWhenPortrait = !!aa;
                        },
                        _hideLoader: function() {
                            if (z._loaderEl && z._loaderEl == z._active) z._loaderEl.style.top = "-10000px";
                        },
                        _makeActive: function(aa) {
                            z._setDialogSizes();
                            z._lowerActive();
                            z._active = aa;
                            if (n.isEnvironment(n.ENVIRONMENTS.CANVAS)) h.getPageInfo(function(ba) {
                                z._centerActive(ba);
                            });
                            z._centerActive();
                        },
                        _lowerActive: function() {
                            if (!z._active) return;
                            z._active.style.top = "-10000px";
                            z._active = null;
                        },
                        _removeStacked: function(aa) {
                            z._stack = ES(z._stack, "filter", true, function(ba) {
                                return ba != aa;
                            });
                        },
                        _centerActive: function(aa) {
                            var ba = z._active;
                            if (!ba) return;
                            if (z._positionDialogAtTopWhenPortrait && j.isOrientationPotrait()) {
                                j.setDialogPositionToTop(ba, z.isTabletStyle(), aa);
                            } else j.setDialogPositionToCenter(ba, z.isTabletStyle(), aa);
                        },
                        _setDialogSizes: function() {
                            var aa = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
                            if (!p.mobile()) return;
                            for (var ba in z._dialogs) if (z._dialogs.hasOwnProperty(ba)) {
                                var ca = document.getElementById(ba);
                                if (ca) {
                                    ca.style.width = z.getDefaultSize().width + "px";
                                    if (!aa) ca.style.height = z.getDefaultSize().height + "px";
                                }
                            }
                        },
                        getDefaultSize: function() {
                            if (p.mobile()) {
                                var aa = x();
                                if (aa) {
                                    if (k.getViewportInfo().width <= aa.width) aa.width = k.getViewportInfo().width - s;
                                    if (k.getViewportInfo().height <= aa.height) aa.height = k.getViewportInfo().height - s;
                                    return aa;
                                }
                                if (p.ipad()) return {
                                    width: u,
                                    height: t
                                };
                                if (p.android()) {
                                    return {
                                        width: screen.availWidth,
                                        height: screen.availHeight
                                    };
                                } else {
                                    var ba = window.innerWidth, ca = window.innerHeight, da = ba / ca > 1.2;
                                    return {
                                        width: ba,
                                        height: Math.max(ca, da ? screen.width : screen.height)
                                    };
                                }
                            }
                            return {
                                width: w,
                                height: v
                            };
                        },
                        _handleOrientationChange: function() {
                            var aa = r("dialog_resize_refactor", false) ? k.getViewportInfo().width : screen.availWidth;
                            z._availScreenWidth = aa;
                            if (z.isTabletStyle()) {
                                z._setDialogSizes(true);
                                z._centerActive();
                                z._setDialogOverlayStyle();
                            } else {
                                var ba = z.getDefaultSize().width;
                                for (var ca in z._dialogs) if (z._dialogs.hasOwnProperty(ca)) {
                                    var da = document.getElementById(ca);
                                    if (da) da.style.width = ba + "px";
                                }
                            }
                        },
                        _addOrientationHandler: function() {
                            if (!p.mobile()) return null;
                            z._availScreenWidth = r("dialog_resize_refactor", false) ? k.getViewportInfo().width : screen.availWidth;
                            j.addMobileOrientationChangeAction(z._handleOrientationChange);
                        },
                        create: function(aa) {
                            var ba = j.setupNewDialog(aa);
                            i.append(ba.dialogElement);
                            if (aa.visible) z.show(ba.dialogElement);
                            if (typeof aa.styles === "object") ES("Object", "assign", false, ba.dialogElement.style, aa.styles);
                            return ba.contentRoot;
                        },
                        show: function(aa) {
                            var ba = z._findRoot(aa);
                            if (ba) {
                                z._removeStacked(ba);
                                z._hideLoader();
                                z._makeActive(ba);
                                z._stack.push(ba);
                                if ("fbCallID" in aa) z.get(aa.fbCallID).inform("iframe_show").trackEvent("show");
                            }
                        },
                        hide: function(aa) {
                            var ba = z._findRoot(aa);
                            z._hideLoader();
                            if (ba == z._active) {
                                z._lowerActive();
                                j.onDialogHideCleanup(z.isTabletStyle());
                                z._hideTabletOverlay();
                                if ("fbCallID" in aa) z.get(aa.fbCallID).inform("iframe_hide").trackEvent("hide");
                            }
                        },
                        remove: function(aa) {
                            aa = z._findRoot(aa);
                            if (aa) {
                                var ba = z._active == aa;
                                z._removeStacked(aa);
                                if (ba) {
                                    z._hideLoader();
                                    if (z._stack.length > 0) {
                                        z.show(z._stack.pop());
                                    } else {
                                        z._lowerActive();
                                        j.onDialogHideCleanup(z.isTabletStyle());
                                        z._hideTabletOverlay();
                                    }
                                } else if (z._active === null && z._stack.length > 0) z.show(z._stack.pop());
                                setTimeout(function() {
                                    aa.parentNode.removeChild(aa);
                                }, 3e3);
                            }
                        },
                        isActive: function(aa) {
                            var ba = z._findRoot(aa);
                            return ba && ba === z._active;
                        },
                        setForceTabletStyle: function(aa) {
                            z._forceTabletStyle = !!aa;
                        },
                        isTabletStyle: function() {
                            var aa;
                            if (!p.mobile()) return false;
                            if (z._forceTabletStyle) return true;
                            if (r("dialog_resize_refactor", false)) {
                                var ba = x();
                                aa = ba && (ba.height >= t || ba.width >= u);
                            } else aa = !!p.ipad();
                            return aa;
                        }
                    };
                    f.exports = z;
                }, null);
                __d("sdk.Frictionless", [ "sdk.Auth", "sdk.api", "sdk.Event", "sdk.Dialog" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    var l = {
                        _allowedRecipients: {},
                        _useFrictionless: false,
                        _updateRecipients: function() {
                            l._allowedRecipients = {};
                            i("/me/apprequestformerrecipients", function(m) {
                                if (!m || m.error) return;
                                ES(m.data, "forEach", true, function(n) {
                                    l._allowedRecipients[n.recipient_id] = true;
                                });
                            });
                        },
                        init: function() {
                            l._useFrictionless = true;
                            h.getLoginStatus(function(m) {
                                if (m.status == "connected") l._updateRecipients();
                            });
                            j.subscribe("auth.login", function(m) {
                                if (m.authResponse) l._updateRecipients();
                            });
                        },
                        _processRequestResponse: function(m, n) {
                            return function(o) {
                                var p = o && o.updated_frictionless;
                                if (l._useFrictionless && p) l._updateRecipients();
                                if (o) {
                                    if (!n && o.frictionless) {
                                        k._hideLoader();
                                        k._restoreBodyPosition();
                                        k._hideIPadOverlay();
                                    }
                                    delete o.frictionless;
                                    delete o.updated_frictionless;
                                }
                                m && m(o);
                            };
                        },
                        isAllowed: function(m) {
                            if (!m) return false;
                            if (typeof m === "number") return m in l._allowedRecipients;
                            if (typeof m === "string") m = m.split(",");
                            m = ES(m, "map", true, function(p) {
                                return ES(String(p), "trim", true);
                            });
                            var n = true, o = false;
                            ES(m, "forEach", true, function(p) {
                                n = n && p in l._allowedRecipients;
                                o = true;
                            });
                            return n && o;
                        }
                    };
                    j.subscribe("init:post", function(m) {
                        if (m.frictionlessRequests) l.init();
                    });
                    f.exports = l;
                }, null);
                __d("sdk.Native", [ "Log", "sdk.UA" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = "fbNativeReady", k = {
                        onready: function(l) {
                            if (!i.nativeApp()) {
                                h.error("FB.Native.onready only works when the page is rendered " + "in a WebView of the native Facebook app. Test if this is the " + "case calling FB.UA.nativeApp()");
                                return;
                            }
                            if (window.__fbNative && !this.nativeReady) ES("Object", "assign", false, this, window.__fbNative);
                            if (this.nativeReady) {
                                l();
                            } else {
                                var m = function(n) {
                                    window.removeEventListener(j, m);
                                    this.onready(l);
                                };
                                window.addEventListener(j, m, false);
                            }
                        }
                    };
                    f.exports = k;
                }, null);
                __d("sdk.openMessenger", [ "sdk.UA" ], function a(b, c, d, e, f, g, h) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var i = "https://itunes.apple.com/us/app/messenger/id454638411", j = "https://play.google.com/store/apps/details?id=com.facebook.orca", k = 3e3;
                    function l(m) {
                        var n = void 0, o = void 0, p = m.link, q = m.app_id;
                        if (h.android()) {
                            n = "intent://share/#Intent;" + "package=com.facebook.orca;" + "scheme=fb-messenger;" + "S.android.intent.extra.TEXT=" + encodeURIComponent(p) + ";" + "S.trigger=send_plugin;";
                            if (q) n += "S.platform_app_id=" + encodeURIComponent(q) + ";";
                            n += "end";
                            o = j;
                        } else {
                            n = "fb-messenger://share?link=" + encodeURIComponent(p);
                            if (q) n += "&app_id=" + encodeURIComponent(q);
                            o = i;
                        }
                        setTimeout(function() {
                            window.location.href = o;
                        }, k);
                        window.location.href = n;
                    }
                    f.exports = l;
                }, null);
                __d("sdk.UIServer", [ "sdk.Auth", "sdk.Content", "sdk.DOM", "sdk.Dialog", "sdk.Event", "sdk.Frictionless", "Log", "sdk.Native", "QueryString", "sdk.RPC", "sdk.Runtime", "JSSDKConfig", "sdk.UA", "UrlMap", "sdk.XD", "createObjectFrom", "sdk.feature", "sdk.fbt", "flattenObject", "sdk.getContextType", "guid", "insertIframe", "sdk.openMessenger", "resolveURI" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ba, ca, da, ea) {
                    if (c.__markCompiled) c.__markCompiled();
                    var fa = {
                        transform: function(la) {
                            if (la.params.display === "touch" && ka.canIframe(la.params) && window.postMessage) {
                                la.params.channel = ka._xdChannelHandler(la.id, "parent");
                                if (!t.nativeApp()) la.params.in_iframe = 1;
                                return la;
                            } else return ka.genericTransform(la);
                        },
                        getXdRelation: function(la) {
                            var ma = la.display;
                            if (ma === "touch" && window.postMessage && la.in_iframe) return "parent";
                            return ka.getXdRelation(la);
                        }
                    }, ga = {
                        "stream.share": {
                            size: {
                                width: 670,
                                height: 340
                            },
                            url: "sharer.php",
                            transform: function(la) {
                                if (!la.params.u) la.params.u = window.location.toString();
                                la.params.display = "popup";
                                return la;
                            }
                        },
                        apprequests: {
                            transform: function(la) {
                                la = fa.transform(la);
                                la.params.frictionless = m && m._useFrictionless;
                                if (la.params.frictionless) {
                                    if (m.isAllowed(la.params.to)) {
                                        la.params.display = "iframe";
                                        la.params.in_iframe = true;
                                        la.hideLoader = true;
                                    }
                                    la.cb = m._processRequestResponse(la.cb, la.hideLoader);
                                }
                                la.closeIcon = false;
                                return la;
                            },
                            getXdRelation: fa.getXdRelation
                        },
                        "permissions.oauth": {
                            url: "dialog/oauth",
                            size: {
                                width: t.mobile() ? null : 475,
                                height: t.mobile() ? null : 183
                            },
                            transform: function(la) {
                                if (!r.getClientID()) {
                                    n.error("FB.login() called before FB.init().");
                                    return;
                                }
                                if (h.getAuthResponse() && !la.params.scope && !la.params.auth_type) {
                                    n.error("FB.login() called when user is already connected.");
                                    la.cb && la.cb({
                                        status: r.getLoginStatus(),
                                        authResponse: h.getAuthResponse()
                                    });
                                    return;
                                }
                                var ma = la.cb, na = la.id;
                                delete la.cb;
                                var oa = ES("Object", "keys", false, ES("Object", "assign", false, la.params.response_type ? w(la.params.response_type.split(",")) : {}, {
                                    token: true,
                                    signed_request: true
                                })).join(",");
                                if (la.params.display === "async") {
                                    ES("Object", "assign", false, la.params, {
                                        client_id: r.getClientID(),
                                        origin: aa(),
                                        response_type: oa,
                                        domain: location.hostname
                                    });
                                    la.cb = h.xdResponseWrapper(ma, h.getAuthResponse(), "permissions.oauth");
                                } else ES("Object", "assign", false, la.params, {
                                    client_id: r.getClientID(),
                                    redirect_uri: ea(ka.xdHandler(ma, na, "opener", h.getAuthResponse(), "permissions.oauth")),
                                    origin: aa(),
                                    response_type: oa,
                                    domain: location.hostname
                                });
                                return la;
                            }
                        },
                        "auth.logout": {
                            url: "logout.php",
                            transform: function(la) {
                                if (!r.getClientID()) {
                                    n.error("FB.logout() called before calling FB.init().");
                                } else if (!h.getAuthResponse()) {
                                    n.error("FB.logout() called without an access token.");
                                } else {
                                    la.params.next = ka.xdHandler(la.cb, la.id, "parent", h.getAuthResponse(), "logout");
                                    return la;
                                }
                            }
                        },
                        "login.status": {
                            url: "dialog/oauth",
                            transform: function(la) {
                                var ma = la.cb, na = la.id;
                                delete la.cb;
                                ES("Object", "assign", false, la.params, {
                                    client_id: r.getClientID(),
                                    redirect_uri: ka.xdHandler(ma, na, "parent", h.getAuthResponse(), "login_status"),
                                    origin: aa(),
                                    response_type: "token,signed_request,code",
                                    domain: location.hostname
                                });
                                return la;
                            }
                        },
                        pay: {
                            size: {
                                width: 555,
                                height: 120
                            },
                            connectDisplay: "popup"
                        },
                        live_broadcast: {
                            transform: function(la) {
                                if (la.params.phase === "create") la.size = {
                                    width: 480,
                                    height: 280
                                };
                                if (la.params.phase === "publish") la.size = {
                                    width: 772,
                                    height: 540
                                };
                                return la;
                            },
                            require_access_token: true
                        }
                    }, ha = {};
                    function ia(la, ma) {
                        ha[ma] = true;
                        return function(na) {
                            delete ha[ma];
                            la(na);
                        };
                    }
                    function ja(la) {
                        if (!x("should_force_single_dialog_instance", true)) return false;
                        var ma = la.method.toLowerCase();
                        if (ma === "pay" && la.display === "async") return true;
                        return false;
                    }
                    var ka = {
                        Methods: ga,
                        _loadedNodes: {},
                        _defaultCb: {},
                        _resultToken: '"xxRESULTTOKENxx"',
                        genericTransform: function(la) {
                            if (la.params.display == "dialog" || la.params.display == "iframe") ES("Object", "assign", false, la.params, {
                                display: "iframe",
                                channel: ka._xdChannelHandler(la.id, "parent.parent")
                            }, true);
                            return la;
                        },
                        checkOauthDisplay: function(la) {
                            var ma = la.scope || la.perms || r.getScope();
                            if (!ma) return la.display;
                            var na = ma.split(/\s|,/g);
                            for (var oa = 0; oa < na.length; oa++) if (!s.initSitevars.iframePermissions[ES(na[oa], "trim", true)]) return "popup";
                            return la.display;
                        },
                        prepareCall: function(la, ma) {
                            var na = la.method.toLowerCase(), oa = ka.Methods.hasOwnProperty(na) ? ES("Object", "assign", false, {}, ka.Methods[na]) : {}, pa = ba(), qa = r.getSecure() || na !== "auth.status" && na != "login.status";
                            ES("Object", "assign", false, la, {
                                app_id: r.getClientID(),
                                locale: r.getLocale(),
                                sdk: "joey",
                                access_token: qa && r.getAccessToken() || undefined
                            });
                            if (na === "share" || na === "share_open_graph") {
                                la.mobile_iframe = t.mobile() && (la.mobile_iframe || la.iframe_test);
                                if (la.mobile_iframe) oa = ES("Object", "assign", false, {}, fa);
                            }
                            la.display = ka.getDisplayMode(oa, la);
                            if (!oa.url) oa.url = "dialog/" + na;
                            if ((oa.url == "dialog/oauth" || oa.url == "dialog/permissions.request") && (la.display == "iframe" || la.display == "touch" && la.in_iframe)) la.display = ka.checkOauthDisplay(la);
                            if (la.display == "popup" && !oa.require_access_token) delete la.access_token;
                            if (r.getIsVersioned() && oa.url.substring(0, 7) === "dialog/") oa.url = la.version + "/" + oa.url;
                            if (ja(la)) {
                                if (ha[na]) {
                                    var ra = 'Dialog "' + na + '" is trying to run more than once.';
                                    n.warn(ra);
                                    ma({
                                        error_code: -100,
                                        error_message: ra
                                    });
                                    return;
                                }
                                ma = ia(ma, na);
                            }
                            var sa = {
                                cb: ma,
                                id: pa,
                                size: oa.size || ka.getDefaultSize(),
                                url: u.resolve(la.display == "touch" ? "m" : "www", qa) + "/" + oa.url,
                                params: la,
                                name: na,
                                dialog: k.newInstance(pa, la.display)
                            }, ta = oa.transform ? oa.transform : ka.genericTransform;
                            if (ta) {
                                sa = ta(sa);
                                if (!sa) return;
                            }
                            if (la.display === "touch" && la.in_iframe) sa.params.parent_height = window.innerHeight;
                            var ua = oa.getXdRelation || ka.getXdRelation, va = ua(sa.params);
                            if (!(sa.id in ka._defaultCb) && !("next" in sa.params) && !("redirect_uri" in sa.params)) sa.params.next = ka._xdResult(sa.cb, sa.id, va, true);
                            if (va === "parent") ES("Object", "assign", false, sa.params, {
                                channel_url: ka._xdChannelHandler(pa, "parent.parent")
                            }, true);
                            sa = ka.prepareParams(sa);
                            return sa;
                        },
                        prepareParams: function(la) {
                            if (la.params.display !== "async") delete la.params.method;
                            la.params = z(la.params);
                            var ma = p.encode(la.params);
                            if (!t.nativeApp() && ka.urlTooLongForIE(la.url + "?" + ma)) {
                                la.post = true;
                            } else if (ma) la.url += "?" + ma;
                            return la;
                        },
                        urlTooLongForIE: function(la) {
                            return t.ie() && t.ie() <= 8 && la.length > 2048;
                        },
                        getDisplayMode: function(la, ma) {
                            if (ma.display === "hidden" || ma.display === "none" || ma.display === "native") return ma.display;
                            var na = r.isEnvironment(r.ENVIRONMENTS.CANVAS) || r.isEnvironment(r.ENVIRONMENTS.PAGETAB);
                            if (na && !ma.display) return "async";
                            if (t.mobile() || ma.display === "touch") return "touch";
                            if (ma.display == "iframe" || ma.display == "dialog") if (!ka.canIframe(ma)) {
                                n.error('"dialog" mode can only be used when the user is connected.');
                                return "popup";
                            }
                            if (la.connectDisplay && !na) return la.connectDisplay;
                            return ma.display || (ka.canIframe(ma) ? "dialog" : "popup");
                        },
                        canIframe: function(la) {
                            if (r.getAccessToken()) return true;
                            if (t.mobile() && r.getLoggedIntoFacebook()) return !!la.mobile_iframe;
                            return false;
                        },
                        getXdRelation: function(la) {
                            var ma = la.display;
                            if (ma === "popup" || ma === "touch") return "opener";
                            if (ma === "dialog" || ma === "iframe" || ma === "hidden" || ma === "none") return "parent";
                            if (ma === "async") return "parent.frames[" + window.name + "]";
                        },
                        popup: function(la) {
                            var ma = typeof window.screenX != "undefined" ? window.screenX : window.screenLeft, na = typeof window.screenY != "undefined" ? window.screenY : window.screenTop, oa = typeof window.outerWidth != "undefined" ? window.outerWidth : document.documentElement.clientWidth, pa = typeof window.outerHeight != "undefined" ? window.outerHeight : document.documentElement.clientHeight - 22, qa = t.mobile() ? null : la.size.width, ra = t.mobile() ? null : la.size.height, sa = ma < 0 ? window.screen.width + ma : ma, ta = parseInt(sa + (oa - qa) / 2, 10), ua = parseInt(na + (pa - ra) / 2.5, 10), va = [];
                            if (qa !== null) va.push("width=" + qa);
                            if (ra !== null) va.push("height=" + ra);
                            va.push("left=" + ta);
                            va.push("top=" + ua);
                            va.push("scrollbars=1");
                            if (la.name == "permissions.request" || la.name == "permissions.oauth") va.push("location=1,toolbar=0");
                            va = va.join(",");
                            var wa;
                            if (la.post) {
                                wa = window.open("about:blank", la.id, va);
                                if (wa) {
                                    ka.setLoadedNode(la, wa, "popup");
                                    i.submitToTarget({
                                        url: la.url,
                                        target: la.id,
                                        params: la.params
                                    });
                                }
                            } else {
                                wa = window.open(la.url, la.id, va);
                                if (wa) ka.setLoadedNode(la, wa, "popup");
                            }
                            if (!wa) return;
                            if (la.id in ka._defaultCb) ka._popupMonitor();
                        },
                        setLoadedNode: function(la, ma, na) {
                            if (na === "iframe") ma.fbCallID = la.id;
                            ma = {
                                node: ma,
                                type: na,
                                fbCallID: la.id
                            };
                            ka._loadedNodes[la.id] = ma;
                        },
                        getLoadedNode: function(la) {
                            var ma = typeof la == "object" ? la.id : la, na = ka._loadedNodes[ma];
                            return na ? na.node : null;
                        },
                        hidden: function(la) {
                            la.className = "FB_UI_Hidden";
                            la.root = i.appendHidden("");
                            ka._insertIframe(la);
                        },
                        iframe: function(la) {
                            la.className = "FB_UI_Dialog";
                            if (la.params.mobile_iframe) {
                                k.setForceTabletStyle(true);
                                k.setCloseOnOverlayTap(true);
                                k.setPositionDialogAtTopWhenPortrait(true);
                            }
                            var ma = function() {
                                var oa = ES("JSON", "stringify", false, {
                                    error_code: 4201,
                                    error_message: y._("User canceled the Dialog flow")
                                });
                                ka._triggerDefault(la.id, oa);
                            }, na = {
                                onClose: ma,
                                closeIcon: la.closeIcon === undefined ? true : la.closeIcon,
                                classes: k.isTabletStyle() ? "centered" : ""
                            };
                            if (la.params.mobile_iframe) na.styles = {
                                "border-radius": "8px"
                            };
                            la.root = k.create(na);
                            if (!la.hideLoader) k.showLoader(ma, la.size.width);
                            j.addCss(la.root, "fb_dialog_iframe");
                            ka._insertIframe(la);
                        },
                        touch: function(la) {
                            if (la.params && la.params.in_iframe) {
                                if (la.ui_created) {
                                    k.showLoader(function() {
                                        ka._triggerDefault(la.id, null);
                                    }, 0);
                                } else ka.iframe(la);
                            } else if (t.nativeApp() && !la.ui_created) {
                                la.frame = la.id;
                                o.onready(function() {
                                    ka.setLoadedNode(la, o.open(la.url + "#cb=" + la.frameName), "native");
                                });
                                ka._popupMonitor();
                            } else if (!la.ui_created) ka.popup(la);
                        },
                        async: function(la) {
                            la.params.redirect_uri = location.protocol + "//" + location.host + location.pathname;
                            delete la.params.access_token;
                            q.remote.showDialog(la.params, function(ma) {
                                var na = ma.result;
                                if (na && na.e2e) {
                                    var oa = k.get(la.id);
                                    oa.trackEvents(na.e2e);
                                    oa.trackEvent("close");
                                    delete na.e2e;
                                }
                                la.cb(na);
                            });
                        },
                        "native": function(la) {
                            da(la.params);
                        },
                        getDefaultSize: function() {
                            return k.getDefaultSize();
                        },
                        _insertIframe: function(la) {
                            ka._loadedNodes[la.id] = false;
                            var ma = function(na) {
                                if (la.id in ka._loadedNodes) ka.setLoadedNode(la, na, "iframe");
                            };
                            if (la.post) {
                                ca({
                                    url: "about:blank",
                                    root: la.root,
                                    className: la.className,
                                    width: la.size.width,
                                    height: la.size.height,
                                    id: la.id,
                                    onInsert: ma,
                                    onload: function(na) {
                                        i.submitToTarget({
                                            url: la.url,
                                            target: na.name,
                                            params: la.params
                                        });
                                    }
                                });
                            } else ca({
                                url: la.url,
                                root: la.root,
                                className: la.className,
                                width: la.size.width,
                                height: la.size.height,
                                id: la.id,
                                name: la.frameName,
                                onInsert: ma
                            });
                        },
                        _handleResizeMessage: function(la, ma) {
                            var na = ka.getLoadedNode(la);
                            if (!na) return;
                            if (ma.height) na.style.height = ma.height + "px";
                            if (ma.width) na.style.width = ma.width + "px";
                            v.inform("resize.ack", ma || {}, "parent.frames[" + na.name + "]");
                            if (!k.isActive(na)) {
                                k.show(na);
                            } else k._centerActive();
                        },
                        _triggerDefault: function(la, ma) {
                            var na = {
                                frame: la
                            };
                            if (ma) na.result = ma;
                            ka._xdRecv(na, ka._defaultCb[la] || function() {});
                        },
                        _popupMonitor: function() {
                            var la;
                            for (var ma in ka._loadedNodes) if (ka._loadedNodes.hasOwnProperty(ma) && ma in ka._defaultCb) {
                                var na = ka._loadedNodes[ma];
                                if (na.type != "popup" && na.type != "native") continue;
                                var oa = na.node;
                                try {
                                    if (oa.closed) {
                                        ka._triggerDefault(ma, null);
                                    } else la = true;
                                } catch (pa) {}
                            }
                            if (la && !ka._popupInterval) {
                                ka._popupInterval = setInterval(ka._popupMonitor, 100);
                            } else if (!la && ka._popupInterval) {
                                clearInterval(ka._popupInterval);
                                ka._popupInterval = null;
                            }
                        },
                        _xdChannelHandler: function(la, ma) {
                            return v.handler(function(na) {
                                var oa = ka.getLoadedNode(la);
                                if (!oa) return;
                                if (na.type == "resize") {
                                    ka._handleResizeMessage(la, na);
                                } else if (na.type == "hide") {
                                    k.hide(oa);
                                } else if (na.type == "rendered") {
                                    var pa = k._findRoot(oa);
                                    k.show(pa);
                                } else if (na.type == "fireevent") l.fire(na.event);
                            }, ma, true, null);
                        },
                        _xdNextHandler: function(la, ma, na, oa) {
                            if (oa) ka._defaultCb[ma] = la;
                            return v.handler(function(pa) {
                                ka._xdRecv(pa, la);
                            }, na) + "&frame=" + ma;
                        },
                        _xdRecv: function(la, ma) {
                            var na = ka.getLoadedNode(la.frame);
                            if (na) if (na.close) {
                                try {
                                    na.close();
                                    if (/iPhone.*Version\/(5|6)/.test(navigator.userAgent) && RegExp.$1 !== "5") window.focus();
                                    ka._popupCount--;
                                } catch (oa) {}
                            } else if (j.containsCss(na, "FB_UI_Hidden")) {
                                setTimeout(function() {
                                    na.parentNode.parentNode.removeChild(na.parentNode);
                                }, 3e3);
                            } else if (j.containsCss(na, "FB_UI_Dialog")) k.remove(na);
                            delete ka._loadedNodes[la.frame];
                            delete ka._defaultCb[la.frame];
                            if (la.e2e) {
                                var pa = k.get(la.frame);
                                pa.trackEvents(la.e2e);
                                pa.trackEvent("close");
                                delete la.e2e;
                            }
                            ma(la);
                        },
                        _xdResult: function(la, ma, na, oa) {
                            return ka._xdNextHandler(function(pa) {
                                la && la(pa.result && pa.result != ka._resultToken && ES("JSON", "parse", false, pa.result));
                            }, ma, na, oa) + "&result=" + encodeURIComponent(ka._resultToken);
                        },
                        xdHandler: function(la, ma, na, oa, pa) {
                            return ka._xdNextHandler(h.xdResponseWrapper(la, oa, pa), ma, na, true);
                        }
                    };
                    q.stub("showDialog");
                    f.exports = ka;
                }, null);
                __d("sdk.ui", [ "Assert", "sdk.Impressions", "Log", "sdk.PlatformVersioning", "sdk.Runtime", "sdk.UIServer", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n) {
                    if (c.__markCompiled) c.__markCompiled();
                    function o(p, q) {
                        h.isObject(p);
                        h.maybeFunction(q);
                        if (l.getIsVersioned()) {
                            k.assertVersionIsSet();
                            if (p.version) {
                                k.assertValidVersion(p.version);
                            } else p.version = l.getVersion();
                        }
                        p = ES("Object", "assign", false, {}, p);
                        if (!p.method) {
                            j.error('"method" is a required parameter for FB.ui().');
                            return null;
                        }
                        if (p.method == "pay.prompt") p.method = "pay";
                        var r = p.method;
                        if (p.redirect_uri) {
                            j.warn("When using FB.ui, you should not specify a redirect_uri.");
                            delete p.redirect_uri;
                        }
                        if ((r == "permissions.request" || r == "permissions.oauth") && (p.display == "iframe" || p.display == "dialog")) p.display = m.checkOauthDisplay(p);
                        if (p.display === "native" && r !== "send") {
                            j.error('display type "native" not supported');
                            return null;
                        }
                        var s = n("e2e_tracking", true);
                        if (s) p.e2e = {};
                        var t = m.prepareCall(p, q || function() {});
                        if (!t) return null;
                        var u = t.params.display;
                        if (u === "dialog") {
                            u = "iframe";
                        } else if (u === "none") u = "hidden";
                        var v = m[u];
                        if (!v) {
                            j.error('"display" must be one of "popup", ' + '"dialog", "iframe", "touch", "async", "hidden", or "none"');
                            return null;
                        }
                        if (s) t.dialog.subscribe("e2e:end", function(w) {
                            w.method = r;
                            w.display = u;
                            j.debug("e2e: %s", ES("JSON", "stringify", false, w));
                            i.log(114, {
                                payload: w
                            });
                        });
                        v(t);
                        return t.dialog;
                    }
                    f.exports = o;
                }, null);
                __d("legacy:fb.auth", [ "sdk.Auth", "sdk.Cookie", "sdk.Event", "FB", "Log", "sdk.Runtime", "sdk.SignedRequest", "sdk.ui" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
                    if (c.__markCompiled) c.__markCompiled();
                    k.provide("", {
                        getLoginStatus: function() {
                            return h.getLoginStatus.apply(h, arguments);
                        },
                        getAuthResponse: function() {
                            return h.getAuthResponse();
                        },
                        getAccessToken: function() {
                            return m.getAccessToken() || null;
                        },
                        getUserID: function() {
                            return m.getUserID() || m.getCookieUserID();
                        },
                        login: function(p, q) {
                            if (q && q.perms && !q.scope) {
                                q.scope = q.perms;
                                delete q.perms;
                                l.warn("OAuth2 specification states that 'perms' " + "should now be called 'scope'.  Please update.");
                            }
                            var r = m.isEnvironment(m.ENVIRONMENTS.CANVAS) || m.isEnvironment(m.ENVIRONMENTS.PAGETAB);
                            o(babelHelpers["extends"]({
                                method: "permissions.oauth",
                                display: r ? "async" : "popup",
                                domain: location.hostname
                            }, q || {}), p);
                        },
                        logout: function(p) {
                            o({
                                method: "auth.logout",
                                display: "hidden"
                            }, p);
                        }
                    });
                    h.subscribe("logout", ES(j.fire, "bind", true, j, "auth.logout"));
                    h.subscribe("login", ES(j.fire, "bind", true, j, "auth.login"));
                    h.subscribe("authresponse.change", ES(j.fire, "bind", true, j, "auth.authResponseChange"));
                    h.subscribe("status.change", ES(j.fire, "bind", true, j, "auth.statusChange"));
                    j.subscribe("init:post", function(p) {
                        if (p.status) h.getLoginStatus();
                        if (m.getClientID()) if (p.authResponse) {
                            h.setAuthResponse(p.authResponse, "connected");
                        } else if (m.getUseCookie()) {
                            var q = i.loadSignedRequest(), r;
                            if (q) {
                                try {
                                    r = n.parse(q);
                                } catch (s) {
                                    i.clearSignedRequestCookie();
                                }
                                if (r && r.user_id) m.setCookieUserID(r.user_id);
                            }
                            i.loadMeta();
                        }
                    });
                }, 3);
                __d("sdk.Canvas.IframeHandling", [ "DOMWrapper", "sdk.RPC" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    var j = null, k;
                    function l() {
                        var p = h.getWindow().document, q = p.body, r = p.documentElement, s = Math.max(q.offsetTop, 0), t = Math.max(r.offsetTop, 0), u = q.scrollHeight + s, v = q.offsetHeight + s, w = r.scrollHeight + t, x = r.offsetHeight + t;
                        return Math.max(u, v, w, x);
                    }
                    function m(p) {
                        if (typeof p != "object") p = {};
                        var q = 0, r = 0;
                        if (!p.height) {
                            p.height = l();
                            q = 16;
                            r = 4;
                        }
                        if (!p.frame) p.frame = window.name || "iframe_canvas";
                        if (k) {
                            var s = k.height, t = p.height - s;
                            if (t <= r && t >= -q) return false;
                        }
                        k = p;
                        i.remote.setSize(p);
                        return true;
                    }
                    function n(p, q) {
                        if (q === undefined && typeof p === "number") {
                            q = p;
                            p = true;
                        }
                        if (p || p === undefined) {
                            if (j === null) j = setInterval(function() {
                                m();
                            }, q || 100);
                            m();
                        } else if (j !== null) {
                            clearInterval(j);
                            j = null;
                        }
                    }
                    i.stub("setSize");
                    var o = {
                        setSize: m,
                        setAutoGrow: n
                    };
                    f.exports = o;
                }, null);
                __d("sdk.Canvas.Navigation", [ "sdk.RPC" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(k) {
                        h.local.navigate = function(l) {
                            k({
                                path: l
                            });
                        };
                        h.remote.setNavigationEnabled(true);
                    }
                    h.stub("setNavigationEnabled");
                    var j = {
                        setUrlHandler: i
                    };
                    f.exports = j;
                }, null);
                __d("sdk.Canvas.Plugin", [ "Log", "sdk.RPC", "sdk.Runtime", "sdk.UA", "sdk.api" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    var m = "CLSID:D27CDB6E-AE6D-11CF-96B8-444553540000", n = "CLSID:444785F1-DE89-4295-863A-D46C3A781394", o = null, p = k.osx() && k.osx.getVersionParts(), q = !(p && p[0] > 10 && p[1] > 10 && (k.chrome() >= 31 || k.webkit() >= 537.71 || k.firefox() >= 25));
                    function r(ba) {
                        ba._hideunity_savedstyle = {};
                        ba._hideunity_savedstyle.left = ba.style.left;
                        ba._hideunity_savedstyle.position = ba.style.position;
                        ba._hideunity_savedstyle.width = ba.style.width;
                        ba._hideunity_savedstyle.height = ba.style.height;
                        ba.style.left = "-10000px";
                        ba.style.position = "absolute";
                        ba.style.width = "1px";
                        ba.style.height = "1px";
                    }
                    function s(ba) {
                        if (ba._hideunity_savedstyle) {
                            ba.style.left = ba._hideunity_savedstyle.left;
                            ba.style.position = ba._hideunity_savedstyle.position;
                            ba.style.width = ba._hideunity_savedstyle.width;
                            ba.style.height = ba._hideunity_savedstyle.height;
                        }
                    }
                    function t(ba) {
                        ba._old_visibility = ba.style.visibility;
                        ba.style.visibility = "hidden";
                    }
                    function u(ba) {
                        ba.style.visibility = ba._old_visibility || "";
                        delete ba._old_visibility;
                    }
                    function v(ba) {
                        var ca = ba.type ? ba.type.toLowerCase() : null, da = ca === "application/x-shockwave-flash" || ba.classid && ba.classid.toUpperCase() == m;
                        if (!da) return false;
                        var ea = /opaque|transparent/i;
                        if (ea.test(ba.getAttribute("wmode"))) return false;
                        for (var fa = 0; fa < ba.childNodes.length; fa++) {
                            var ga = ba.childNodes[fa];
                            if (/param/i.test(ga.nodeName) && /wmode/i.test(ga.name) && ea.test(ga.value)) return false;
                        }
                        return true;
                    }
                    function w(ba) {
                        var ca = ba.type ? ba.type.toLowerCase() : null;
                        return ca === "application/vnd.unity" || ba.classid && ba.classid.toUpperCase() == n;
                    }
                    function x(ba) {
                        var ca = ES("Array", "from", false, window.document.getElementsByTagName("object"));
                        ca = ca.concat(ES("Array", "from", false, window.document.getElementsByTagName("embed")));
                        var da = false, ea = false;
                        ES(ca, "forEach", true, function(ga) {
                            var ha = v(ga), ia = q && w(ga);
                            if (!ha && !ia) return;
                            da = da || ha;
                            ea = ea || ia;
                            var ja = function() {
                                if (ba.state === "opened") {
                                    if (ha) {
                                        t(ga);
                                    } else r(ga);
                                } else if (ha) {
                                    u(ga);
                                } else s(ga);
                            };
                            if (o) {
                                h.info("Calling developer specified callback");
                                var ka = {
                                    state: ba.state,
                                    elem: ga
                                };
                                o(ka);
                                setTimeout(ja, 200);
                            } else ja();
                        });
                        if (Math.random() <= 1 / 1e3) {
                            var fa = {
                                unity: ea,
                                flash: da
                            };
                            l(j.getClientID() + "/occludespopups", "post", fa);
                        }
                    }
                    i.local.hidePluginObjects = function() {
                        h.info("hidePluginObjects called");
                        x({
                            state: "opened"
                        });
                    };
                    i.local.showPluginObjects = function() {
                        h.info("showPluginObjects called");
                        x({
                            state: "closed"
                        });
                    };
                    i.local.showFlashObjects = i.local.showPluginObjects;
                    i.local.hideFlashObjects = i.local.hidePluginObjects;
                    function y() {
                        t();
                        r();
                    }
                    function z() {
                        u();
                        s();
                    }
                    var aa = {
                        _setHidePluginCallback: function(ba) {
                            o = ba;
                        },
                        hidePluginElement: y,
                        showPluginElement: z
                    };
                    f.exports = aa;
                }, null);
                __d("sdk.Canvas.Tti", [ "sdk.RPC", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    function j(o, p) {
                        var q = {
                            appId: i.getClientID(),
                            time: ES("Date", "now", false),
                            name: p
                        }, r = [ q ];
                        if (o) r.push(function(s) {
                            o(s.result);
                        });
                        h.remote.logTtiMessage.apply(null, r);
                    }
                    function k() {
                        j(null, "StartIframeAppTtiTimer");
                    }
                    function l(o) {
                        j(o, "StopIframeAppTtiTimer");
                    }
                    function m(o) {
                        j(o, "RecordIframeAppTti");
                    }
                    h.stub("logTtiMessage");
                    var n = {
                        setDoneLoading: m,
                        startTimer: k,
                        stopTimer: l
                    };
                    f.exports = n;
                }, null);
                __d("legacy:fb.canvas", [ "Assert", "sdk.Canvas.Environment", "sdk.Event", "FB", "sdk.Canvas.IframeHandling", "sdk.Canvas.Navigation", "sdk.Canvas.Plugin", "sdk.RPC", "sdk.Runtime", "sdk.Canvas.Tti" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
                    if (c.__markCompiled) c.__markCompiled();
                    k.provide("Canvas", {
                        setSize: function(r) {
                            h.maybeObject(r, "Invalid argument");
                            return l.setSize.apply(null, arguments);
                        },
                        setAutoGrow: function() {
                            return l.setAutoGrow.apply(null, arguments);
                        },
                        getPageInfo: function(r) {
                            h.isFunction(r, "Invalid argument");
                            return i.getPageInfo.apply(null, arguments);
                        },
                        scrollTo: function(r, s) {
                            h.maybeNumber(r, "Invalid argument");
                            h.maybeNumber(s, "Invalid argument");
                            return i.scrollTo.apply(null, arguments);
                        },
                        setDoneLoading: function(r) {
                            h.maybeFunction(r, "Invalid argument");
                            return q.setDoneLoading.apply(null, arguments);
                        },
                        startTimer: function() {
                            return q.startTimer.apply(null, arguments);
                        },
                        stopTimer: function(r) {
                            h.maybeFunction(r, "Invalid argument");
                            return q.stopTimer.apply(null, arguments);
                        },
                        getHash: function(r) {
                            h.isFunction(r, "Invalid argument");
                            return m.getHash.apply(null, arguments);
                        },
                        setHash: function(r) {
                            h.isString(r, "Invalid argument");
                            return m.setHash.apply(null, arguments);
                        },
                        setUrlHandler: function(r) {
                            h.isFunction(r, "Invalid argument");
                            return m.setUrlHandler.apply(null, arguments);
                        }
                    });
                    o.local.fireEvent = ES(j.fire, "bind", true, j);
                    j.subscribe("init:post", function(r) {
                        if (p.isEnvironment(p.ENVIRONMENTS.CANVAS)) {
                            h.isTrue(!r.hideFlashCallback || !r.hidePluginCallback, "cannot specify deprecated hideFlashCallback and new hidePluginCallback");
                            n._setHidePluginCallback(r.hidePluginCallback || r.hideFlashCallback);
                        }
                    });
                }, 3);
                __d("sdk.Canvas.Prefetcher", [ "JSSDKCanvasPrefetcherConfig", "sdk.Runtime", "sdk.api" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = {
                        AUTOMATIC: 0,
                        MANUAL: 1
                    }, l = h.sampleRate, m = h.blacklist, n = k.AUTOMATIC, o = [];
                    function p() {
                        var u = {
                            object: "data",
                            link: "href",
                            script: "src"
                        };
                        if (n == k.AUTOMATIC) ES(ES("Object", "keys", false, u), "forEach", true, function(v) {
                            var w = u[v];
                            ES(ES("Array", "from", false, document.getElementsByTagName(v)), "forEach", true, function(x) {
                                if (x[w]) o.push(x[w]);
                            });
                        });
                        if (o.length === 0) return;
                        j(i.getClientID() + "/staticresources", "post", {
                            urls: ES("JSON", "stringify", false, o),
                            is_https: location.protocol === "https:"
                        });
                        o = [];
                    }
                    function q() {
                        if (!i.isEnvironment(i.ENVIRONMENTS.CANVAS) || !i.getClientID() || !l) return;
                        if (Math.random() > 1 / l || m == "*" || ~ES(m, "indexOf", true, i.getClientID())) return;
                        setTimeout(p, 3e4);
                    }
                    function r(u) {
                        n = u;
                    }
                    function s(u) {
                        o.push(u);
                    }
                    var t = {
                        COLLECT_AUTOMATIC: k.AUTOMATIC,
                        COLLECT_MANUAL: k.MANUAL,
                        addStaticResource: s,
                        setCollectionMode: r,
                        _maybeSample: q
                    };
                    f.exports = t;
                }, null);
                __d("legacy:fb.canvas.prefetcher", [ "FB", "sdk.Canvas.Prefetcher", "sdk.Event", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.provide("Canvas.Prefetcher", i);
                    j.subscribe("init:post", function(l) {
                        if (k.isEnvironment(k.ENVIRONMENTS.CANVAS)) i._maybeSample();
                    });
                }, 3);
                __d("legacy:fb.canvas.presence", [ "sdk.RPC", "sdk.Event" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    i.subscribe(i.SUBSCRIBE, j);
                    i.subscribe(i.UNSUBSCRIBE, k);
                    h.stub("useFriendsOnline");
                    function j(l, m) {
                        if (l != "canvas.friendsOnlineUpdated") return;
                        if (m.length === 1) h.remote.useFriendsOnline(true);
                    }
                    function k(l, m) {
                        if (l != "canvas.friendsOnlineUpdated") return;
                        if (m.length === 0) h.remote.useFriendsOnline(false);
                    }
                }, 3);
                __d("legacy:fb.canvas.syncrequests", [ "sdk.RPC", "sdk.Event" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.stub("initPendingSyncRequests");
                    function j(k, l) {
                        if (k != "canvas.syncRequestUpdated") return;
                        h.remote.initPendingSyncRequests();
                        i.unsubscribe(i.SUBSCRIBE, j);
                    }
                    i.subscribe(i.SUBSCRIBE, j);
                }, 3);
                __d("legacy:fb.event", [ "FB", "sdk.Event", "sdk.Runtime", "sdk.Scribe", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    var m = [], n = null, o = l("event_subscriptions_log", false);
                    h.provide("Event", {
                        subscribe: function(p, q) {
                            if (o) {
                                m.push(p);
                                if (!n) n = setTimeout(function() {
                                    k.log("jssdk_error", {
                                        appId: j.getClientID(),
                                        error: "EVENT_SUBSCRIPTIONS_LOG",
                                        extra: {
                                            line: 0,
                                            name: "EVENT_SUBSCRIPTIONS_LOG",
                                            script: "N/A",
                                            stack: "N/A",
                                            message: m.sort().join(",")
                                        }
                                    });
                                    m.length = 0;
                                    n = null;
                                }, o);
                            }
                            return i.subscribe(p, q);
                        },
                        unsubscribe: ES(i.unsubscribe, "bind", true, i)
                    });
                }, 3);
                __d("legacy:fb.frictionless", [ "FB", "sdk.Frictionless" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.provide("Frictionless", i);
                }, 3);
                __d("sdk.init", [ "sdk.Cookie", "sdk.ErrorHandling", "sdk.Event", "sdk.Impressions", "Log", "ManagedError", "sdk.PlatformVersioning", "QueryString", "sdk.Runtime", "sdk.URI", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
                    if (c.__markCompiled) c.__markCompiled();
                    function s(u) {
                        var v = typeof u == "number" && u > 0 || typeof u == "string" && /^[0-9a-f]{21,}$|^[0-9]{1,21}$/.test(u);
                        if (v) return u.toString();
                        l.warn("Invalid App Id: Must be a number or numeric string representing " + "the application id.");
                        return null;
                    }
                    function t(u) {
                        if (p.getInitialized()) l.warn("FB.init has already been called - this could indicate a problem");
                        if (p.getIsVersioned()) {
                            if (Object.prototype.toString.call(u) !== "[object Object]") throw new m("Invalid argument");
                            if (u.authResponse) l.warn("Setting authResponse is not supported");
                            if (!u.version) u.version = new q(location.href).getQueryData().sdk_version;
                            n.assertValidVersion(u.version);
                            p.setVersion(u.version);
                        } else {
                            if (/number|string/.test(typeof u)) {
                                l.warn("FB.init called with invalid parameters");
                                u = {
                                    apiKey: u
                                };
                            }
                            u = ES("Object", "assign", false, {
                                status: true
                            }, u || {});
                        }
                        var v = s(u.appId || u.apiKey);
                        if (v !== null) p.setClientID(v);
                        if ("scope" in u) p.setScope(u.scope);
                        if (u.cookie) {
                            p.setUseCookie(true);
                            if (typeof u.cookie === "string") h.setDomain(u.cookie);
                        }
                        if (u.kidDirectedSite) p.setKidDirectedSite(true);
                        p.setInitialized(true);
                        if (r("js_sdk_impression_on_load", true)) k.log(115, {});
                        j.fire("init:post", u);
                    }
                    setTimeout(function() {
                        var u = /(connect\.facebook\.net|\.facebook\.com\/assets.php).*?#(.*)/;
                        ES(ES("Array", "from", false, fb_fif_window.document.getElementsByTagName("script")), "forEach", true, function(v) {
                            if (v.src) {
                                var w = u.exec(v.src);
                                if (w) {
                                    var x = o.decode(w[2]);
                                    for (var y in x) if (x.hasOwnProperty(y)) {
                                        var z = x[y];
                                        if (z == "0") x[y] = 0;
                                    }
                                    t(x);
                                }
                            }
                        });
                        if (window.fbAsyncInit && !window.fbAsyncInit.hasRun) {
                            window.fbAsyncInit.hasRun = true;
                            i.unguard(window.fbAsyncInit)();
                        }
                    }, 0);
                    f.exports = t;
                }, null);
                __d("legacy:fb.init", [ "FB", "sdk.init" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.provide("", {
                        init: i
                    });
                }, 3);
                __d("legacy:fb.ui", [ "FB", "sdk.ui" ], function a(b, c, d, e, f, g, h, i) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.provide("", {
                        ui: i
                    });
                }, 3);
                __d("legacy:fb.versioned-sdk", [ "sdk.Runtime" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    h.setIsVersioned(true);
                }, 3);
                __d("IframePlugin", [ "sdk.Auth", "sdk.DOM", "sdk.Event", "Log", "ObservableMixin", "sdk.PlatformVersioning", "QueryString", "sdk.Runtime", "Type", "sdk.UA", "sdk.URI", "UrlMap", "sdk.XD", "sdk.createIframe", "sdk.feature", "guid", "resolveURI" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) {
                    if (c.__markCompiled) c.__markCompiled();
                    var y = {
                        skin: "string",
                        font: "string",
                        width: "string",
                        height: "px",
                        ref: "string",
                        color_scheme: "string"
                    };
                    function z(ha, ia, ja) {
                        if (ia || ia === 0) if (ia === "100%") {
                            ha.style.width = "100%";
                        } else ha.style.width = ia + "px";
                        if (ja || ja === 0) ha.style.height = ja + "px";
                    }
                    function aa(ha) {
                        return function(ia) {
                            var ja = {
                                width: ia.width,
                                height: ia.height,
                                pluginID: ha
                            };
                            j.fire("xfbml.resize", ja);
                        };
                    }
                    var ba = {
                        string: function(ha) {
                            return ha;
                        },
                        bool: function(ha) {
                            return ha ? /^(?:true|1|yes|on)$/i.test(ha) : undefined;
                        },
                        url: function(ha) {
                            return x(ha);
                        },
                        url_maybe: function(ha) {
                            return ha ? x(ha) : ha;
                        },
                        hostname: function(ha) {
                            return ha || window.location.hostname;
                        },
                        px: function(ha) {
                            return /^(\d+)(?:px)?$/.test(ha) ? parseInt(RegExp.$1, 10) : undefined;
                        },
                        text: function(ha) {
                            return ha;
                        }
                    };
                    function ca(ha, ia) {
                        var ja = ha[ia] || ha[ia.replace(/_/g, "-")] || ha[ia.replace(/_/g, "")] || ha["data-" + ia] || ha["data-" + ia.replace(/_/g, "-")] || ha["data-" + ia.replace(/_/g, "")] || undefined;
                        return ja;
                    }
                    function da(ha, ia, ja, ka) {
                        ES(ES("Object", "keys", false, ha), "forEach", true, function(la) {
                            if (ha[la] == "text" && !ja[la]) {
                                ja[la] = ia.textContent || ia.innerText || "";
                                ia.setAttribute(la, ja[la]);
                            }
                            ka[la] = ba[ha[la]](ca(ja, la));
                        });
                    }
                    function ea(ha) {
                        if (ha === "100%") return "100%";
                        return ha || ha === "0" || ha === 0 ? parseInt(ha, 10) : undefined;
                    }
                    function fa(ha) {
                        if (ha) z(ha, 0, 0);
                    }
                    var ga = p.extend({
                        constructor: function(ha, ia, ja, ka) {
                            this.parent();
                            ja = ja.replace(/-/g, "_");
                            var la = ca(ka, "plugin_id");
                            this.subscribe("xd.resize", aa(la));
                            this.subscribe("xd.resize.flow", aa(la));
                            this.subscribe("xd.resize.flow", ES(function(qa) {
                                ES("Object", "assign", false, this._iframeOptions.root.style, {
                                    verticalAlign: "bottom",
                                    overflow: ""
                                });
                                z(this._iframeOptions.root, ea(qa.width), ea(qa.height));
                                this.updateLift();
                                clearTimeout(this._timeoutID);
                            }, "bind", true, this));
                            this.subscribe("xd.resize", ES(function(qa) {
                                ES("Object", "assign", false, this._iframeOptions.root.style, {
                                    verticalAlign: "bottom",
                                    overflow: ""
                                });
                                z(this._iframeOptions.root, ea(qa.width), ea(qa.height));
                                z(this._iframe, ea(qa.width), ea(qa.height));
                                this._isIframeResized = true;
                                this.updateLift();
                                clearTimeout(this._timeoutID);
                            }, "bind", true, this));
                            this.subscribe("xd.resize.iframe", ES(function(qa) {
                                if (qa.reposition === "true" && v("reposition_iframe", false)) this.reposition(ea(qa.width));
                                z(this._iframe, ea(qa.width), ea(qa.height));
                                this._isIframeResized = true;
                                this.updateLift();
                                clearTimeout(this._timeoutID);
                            }, "bind", true, this));
                            this.subscribe("xd.sdk_event", function(qa) {
                                var ra = ES("JSON", "parse", false, qa.data);
                                ra.pluginID = la;
                                j.fire(qa.event, ra, ha);
                            });
                            var ma = s.resolve("www", true) + "/plugins/" + ja + ".php?", na = {};
                            da(this.getParams(), ha, ka, na);
                            da(y, ha, ka, na);
                            ES("Object", "assign", false, na, {
                                app_id: o.getClientID(),
                                locale: o.getLocale(),
                                sdk: "joey",
                                kid_directed_site: o.getKidDirectedSite(),
                                channel: t.handler(ES(function(qa) {
                                    return this.inform("xd." + qa.type, qa);
                                }, "bind", true, this), "parent.parent", true)
                            });
                            na.container_width = ha.offsetWidth;
                            i.addCss(ha, "fb_iframe_widget");
                            var oa = w();
                            this.subscribe("xd.verify", function(qa) {
                                t.sendToFacebook(oa, {
                                    method: "xd/verify",
                                    params: ES("JSON", "stringify", false, qa.token)
                                });
                            });
                            this.subscribe("xd.refreshLoginStatus", ES(function() {
                                h.removeLogoutState();
                                h.getLoginStatus(ES(this.inform, "bind", true, this, "login.status"), true);
                            }, "bind", true, this));
                            var pa = document.createElement("span");
                            ES("Object", "assign", false, pa.style, {
                                verticalAlign: "top",
                                width: "0px",
                                height: "0px",
                                overflow: "hidden"
                            });
                            this._element = ha;
                            this._ns = ia;
                            this._tag = ja;
                            this._params = na;
                            this._config = this.getConfig();
                            this._iframeOptions = {
                                root: pa,
                                url: ma + n.encode(na),
                                name: oa,
                                width: this._config.mobile_fullsize && q.mobile() ? void 0 : na.width || 1e3,
                                height: na.height || 1e3,
                                style: {
                                    border: "none",
                                    visibility: "hidden"
                                },
                                title: this._ns + ":" + this._tag + " Facebook Social Plugin",
                                onload: ES(function() {
                                    return this.inform("render");
                                }, "bind", true, this),
                                onerror: ES(function() {
                                    return fa(this._iframe);
                                }, "bind", true, this)
                            };
                            if (this.isFluid() && na.width !== "auto") {
                                i.addCss(this._element, "fb_iframe_widget_fluid_desktop");
                                if (!na.width && this._config.full_width) {
                                    this._element.style.width = "100%";
                                    this._iframeOptions.root.style.width = "100%";
                                    this._iframeOptions.style.width = "100%";
                                    this._params.container_width = this._element.offsetWidth;
                                    this._iframeOptions.url = ma + n.encode(this._params);
                                }
                            }
                        },
                        process: function() {
                            if (o.getIsVersioned()) {
                                m.assertVersionIsSet();
                                var ha = new r(this._iframeOptions.url);
                                this._iframeOptions.url = ha.setPath("/" + o.getVersion() + ha.getPath()).toString();
                            }
                            var ia = ES("Object", "assign", false, {}, this._params);
                            delete ia.channel;
                            var ja = n.encode(ia);
                            if (this._element.getAttribute("fb-iframe-plugin-query") == ja) {
                                k.info("Skipping render: %s:%s %s", this._ns, this._tag, ja);
                                this.inform("render");
                                return;
                            }
                            this._element.setAttribute("fb-iframe-plugin-query", ja);
                            this.subscribe("render", ES(function() {
                                this._iframe.style.visibility = "visible";
                                if (!this._isIframeResized) fa(this._iframe);
                            }, "bind", true, this));
                            while (this._element.firstChild) this._element.removeChild(this._element.firstChild);
                            this._element.appendChild(this._iframeOptions.root);
                            var ka = q.mobile() ? 120 : 45;
                            this._timeoutID = setTimeout(ES(function() {
                                fa(this._iframe);
                                k.warn("%s:%s failed to resize in %ss", this._ns, this._tag, ka);
                            }, "bind", true, this), ka * 1e3);
                            this._iframe = u(this._iframeOptions);
                            if (q.mobile() || ia.width === "auto") {
                                i.addCss(this._element, "fb_iframe_widget_fluid");
                                if (!this._iframeOptions.width) {
                                    ES("Object", "assign", false, this._element.style, {
                                        display: "block",
                                        width: "100%",
                                        height: "auto"
                                    });
                                    ES("Object", "assign", false, this._iframeOptions.root.style, {
                                        width: "100%",
                                        height: "auto"
                                    });
                                    var la = {
                                        height: "auto",
                                        position: "static",
                                        width: "100%"
                                    };
                                    if (q.iphone() || q.ipad()) ES("Object", "assign", false, la, {
                                        width: "220px",
                                        "min-width": "100%"
                                    });
                                    ES("Object", "assign", false, this._iframe.style, la);
                                }
                            }
                        },
                        getConfig: function() {
                            return {};
                        },
                        isFluid: function() {
                            var ha = this.getConfig();
                            return ha.fluid;
                        },
                        reposition: function(ha) {
                            var ia = i.getPosition(this._iframe).x, ja = i.getViewportInfo().width, ka = parseInt(i.getStyle(this._iframe, "width"), 10), la = {};
                            if (ia + ha > ja && ia > ha) {
                                this._iframe.style.left = parseInt(i.getStyle(this._iframe, "width"), 10) - ha + "px";
                                this._isRepositioned = true;
                                la.type = "reposition";
                            } else if (this._isRepositioned && ka - ha !== 0) {
                                this._iframe.style.left = "0px";
                                this._isRepositioned = false;
                                la.type = "restore";
                            } else return;
                            t.sendToFacebook(this._iframe.name, {
                                method: "xd/reposition",
                                params: ES("JSON", "stringify", false, la)
                            });
                        },
                        updateLift: function() {
                            var ha = this._iframe.style.width === this._iframeOptions.root.style.width && this._iframe.style.height === this._iframeOptions.root.style.height;
                            i[ha ? "removeCss" : "addCss"](this._iframe, "fb_iframe_widget_lift");
                        }
                    }, l);
                    ga.getVal = ca;
                    ga.withParams = function(ha, ia) {
                        return ga.extend({
                            getParams: function() {
                                return ha;
                            },
                            getConfig: function() {
                                return ia ? ia : {};
                            }
                        });
                    };
                    f.exports = ga;
                }, null);
                __d("PluginConfig", [ "sdk.feature" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    var i = {
                        messengerpreconfirmation: {
                            mobile_fullsize: true
                        },
                        messengeraccountconfirmation: {
                            mobile_fullsize: true
                        },
                        messengerbusinesslink: {
                            mobile_fullsize: true
                        },
                        messengertoggle: {
                            mobile_fullsize: true
                        },
                        messengermessageus: {
                            mobile_fullsize: true
                        },
                        send_to_messenger: {
                            mobile_fullsize: true
                        },
                        post: {
                            fluid: h("fluid_embed", false),
                            mobile_fullsize: true
                        }
                    };
                    f.exports = i;
                }, null);
                __d("PluginTags", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        comment_embed: {
                            href: "url",
                            include_parent: "bool"
                        },
                        composer: {
                            action_type: "string",
                            action_properties: "string"
                        },
                        create_event_button: {},
                        follow: {
                            href: "url",
                            layout: "string",
                            show_faces: "bool",
                            size: "string"
                        },
                        like: {
                            href: "url",
                            layout: "string",
                            show_faces: "bool",
                            share: "bool",
                            action: "string",
                            send: "bool",
                            size: "string"
                        },
                        like_box: {
                            href: "string",
                            show_faces: "bool",
                            header: "bool",
                            stream: "bool",
                            force_wall: "bool",
                            show_border: "bool",
                            id: "string",
                            connections: "string",
                            profile_id: "string",
                            name: "string"
                        },
                        page: {
                            href: "string",
                            hide_cta: "bool",
                            hide_cover: "bool",
                            small_header: "bool",
                            adapt_container_width: "bool",
                            show_facepile: "bool",
                            show_posts: "bool",
                            tabs: "string"
                        },
                        messengerpreconfirmation: {
                            messenger_app_id: "string",
                            page_id: "string"
                        },
                        messengeraccountconfirmation: {
                            messenger_app_id: "string",
                            page_id: "string",
                            state: "string"
                        },
                        messengerbusinesslink: {
                            messenger_app_id: "string",
                            page_id: "string",
                            state: "string"
                        },
                        messengertoggle: {
                            messenger_app_id: "string",
                            page_id: "string",
                            token: "string",
                            psid: "string"
                        },
                        messengermessageus: {
                            messenger_app_id: "string",
                            page_id: "string",
                            color: "string",
                            size: "string"
                        },
                        send_to_messenger: {
                            messenger_app_id: "string",
                            page_id: "string",
                            color: "string",
                            size: "string"
                        },
                        page_events: {
                            href: "url"
                        },
                        post: {
                            href: "url",
                            show_text: "bool"
                        },
                        profile_pic: {
                            uid: "string",
                            linked: "bool",
                            href: "string",
                            size: "string",
                            facebook_logo: "bool"
                        },
                        send: {
                            href: "url",
                            size: "string"
                        },
                        send_to_mobile: {
                            max_rows: "string",
                            show_faces: "bool",
                            size: "string"
                        }
                    }, i = {
                        subscribe: "follow",
                        fan: "like_box",
                        likebox: "like_box"
                    };
                    ES(ES("Object", "keys", false, i), "forEach", true, function(j) {
                        h[j] = h[i[j]];
                    });
                    f.exports = h;
                }, null);
                __d("runOnce", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        var j, k;
                        return function() {
                            if (!j) {
                                j = true;
                                k = i();
                            }
                            return k;
                        };
                    }
                    f.exports = h;
                }, null);
                __d("XFBML", [ "Assert", "sdk.DOM", "Log", "ObservableMixin", "sdk.UA", "runOnce" ], function a(b, c, d, e, f, g, h, i, j, k, l, m) {
                    if (c.__markCompiled) c.__markCompiled();
                    var n = {}, o = {}, p = 0, q = new k();
                    function r(y, z) {
                        return ES(y[z] + "", "trim", true);
                    }
                    function s(y) {
                        return y.scopeName ? y.scopeName + ":" + y.nodeName : "";
                    }
                    function t(y) {
                        return n[r(y, "nodeName").toLowerCase()] || n[s(y).toLowerCase()];
                    }
                    function u(y) {
                        var z = ES(r(y, "className").split(/\s+/), "filter", true, function(aa) {
                            return o.hasOwnProperty(aa);
                        });
                        if (z.length === 0) return undefined;
                        if (y.getAttribute("fb-xfbml-state") || !y.childNodes || y.childNodes.length === 0 || y.childNodes.length === 1 && y.childNodes[0].nodeType === 3 || y.children.length === 1 && r(y.children[0], "className") === "fb-xfbml-parse-ignore") return o[z[0]];
                    }
                    function v(y) {
                        var z = {};
                        ES(ES("Array", "from", false, y.attributes), "forEach", true, function(aa) {
                            z[r(aa, "name")] = r(aa, "value");
                        });
                        return z;
                    }
                    function w(y, z, aa) {
                        var ba = document.createElement("div");
                        i.addCss(y, z + "-" + aa);
                        ES(ES("Array", "from", false, y.childNodes), "forEach", true, function(ca) {
                            ba.appendChild(ca);
                        });
                        ES(ES("Array", "from", false, y.attributes), "forEach", true, function(ca) {
                            ba.setAttribute(ca.name, ca.value);
                        });
                        y.parentNode.replaceChild(ba, y);
                        return ba;
                    }
                    function x(y, z, aa) {
                        h.isTrue(y && y.nodeType && y.nodeType === 1 && !!y.getElementsByTagName, "Invalid DOM node passed to FB.XFBML.parse()");
                        h.isFunction(z, "Invalid callback passed to FB.XFBML.parse()");
                        var ba = ++p;
                        j.info("XFBML Parsing Start %s", ba);
                        var ca = 1, da = 0, ea = function() {
                            ca--;
                            if (ca === 0) {
                                j.info("XFBML Parsing Finish %s, %s tags found", ba, da);
                                z();
                                q.inform("render", ba, da);
                            }
                            h.isTrue(ca >= 0, "onrender() has been called too many times");
                        };
                        ES(ES("Array", "from", false, y.getElementsByTagName("*")), "forEach", true, function(ga) {
                            if (!aa && ga.getAttribute("fb-xfbml-state")) return;
                            if (ga.nodeType !== 1) return;
                            var ha = t(ga) || u(ga);
                            if (!ha) return;
                            if (l.ie() < 9 && ga.scopeName) ga = w(ga, ha.xmlns, ha.localName);
                            ca++;
                            da++;
                            var ia = new ha.ctor(ga, ha.xmlns, ha.localName, v(ga));
                            ia.subscribe("render", m(function() {
                                ga.setAttribute("fb-xfbml-state", "rendered");
                                ea();
                            }));
                            var ja = function() {
                                if (ga.getAttribute("fb-xfbml-state") == "parsed") {
                                    q.subscribe("render.queue", ja);
                                } else {
                                    ga.setAttribute("fb-xfbml-state", "parsed");
                                    ia.process();
                                }
                            };
                            ja();
                        });
                        q.inform("parse", ba, da);
                        var fa = 3e4;
                        setTimeout(function() {
                            if (ca > 0) j.warn("%s tags failed to render in %s ms", ca, fa);
                        }, fa);
                        ea();
                    }
                    q.subscribe("render", function() {
                        var y = q.getSubscribers("render.queue");
                        q.clearSubscribers("render.queue");
                        ES(y, "forEach", true, function(z) {
                            z();
                        });
                    });
                    ES("Object", "assign", false, q, {
                        registerTag: function(y) {
                            var z = y.xmlns + ":" + y.localName;
                            h.isUndefined(n[z], z + " already registered");
                            n[z] = y;
                            o[y.xmlns + "-" + y.localName] = y;
                        },
                        parse: function(y, z) {
                            x(y || document.body, z || function() {}, true);
                        },
                        parseNew: function() {
                            x(document.body, function() {}, false);
                        }
                    });
                    f.exports = q;
                }, null);
                __d("sdk.Arbiter", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = {
                        BEHAVIOR_EVENT: "e",
                        BEHAVIOR_PERSISTENT: "p",
                        BEHAVIOR_STATE: "s"
                    };
                    f.exports = h;
                }, null);
                __d("sdk.XFBML.Element", [ "sdk.DOM", "Type", "ObservableMixin" ], function a(b, c, d, e, f, g, h, i, j) {
                    if (c.__markCompiled) c.__markCompiled();
                    var k = i.extend({
                        constructor: function(l) {
                            this.parent();
                            this.dom = l;
                        },
                        fire: function() {
                            this.inform.apply(this, arguments);
                        },
                        getAttribute: function(l, m, n) {
                            var o = h.getAttr(this.dom, l);
                            return o ? n ? n(o) : o : m;
                        },
                        _getBoolAttribute: function(l, m) {
                            var n = h.getBoolAttr(this.dom, l);
                            return n === null ? m : n;
                        },
                        _getPxAttribute: function(l, m) {
                            return this.getAttribute(l, m, function(n) {
                                var o = parseInt(n, 10);
                                return isNaN(o) ? m : o;
                            });
                        },
                        _getLengthAttribute: function(l, m) {
                            return this.getAttribute(l, m, function(n) {
                                if (n === "100%" || n === "auto") return n;
                                var o = parseInt(n, 10);
                                return isNaN(o) ? m : o;
                            });
                        },
                        _getAttributeFromList: function(l, m, n) {
                            return this.getAttribute(l, m, function(o) {
                                o = o.toLowerCase();
                                return ES(n, "indexOf", true, o) > -1 ? o : m;
                            });
                        },
                        isValid: function() {
                            for (var l = this.dom; l; l = l.parentNode) if (l == document.body) return true;
                        },
                        clear: function() {
                            h.html(this.dom, "");
                        }
                    }, j);
                    f.exports = k;
                }, null);
                __d("sdk.XFBML.IframeWidget", [ "sdk.Arbiter", "sdk.Auth", "sdk.Content", "sdk.DOM", "sdk.Event", "sdk.XFBML.Element", "guid", "insertIframe", "QueryString", "sdk.Runtime", "sdk.ui", "UrlMap", "sdk.XD" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
                    if (c.__markCompiled) c.__markCompiled();
                    var u = m.extend({
                        _iframeName: null,
                        _showLoader: true,
                        _refreshOnAuthChange: false,
                        _allowReProcess: false,
                        _fetchPreCachedLoader: false,
                        _visibleAfter: "load",
                        _widgetPipeEnabled: false,
                        _borderReset: false,
                        _repositioned: false,
                        getUrlBits: function() {
                            throw new Error("Inheriting class needs to implement getUrlBits().");
                        },
                        setupAndValidate: function() {
                            return true;
                        },
                        oneTimeSetup: function() {},
                        getSize: function() {},
                        getIframeName: function() {
                            return this._iframeName;
                        },
                        getIframeTitle: function() {
                            return "Facebook Social Plugin";
                        },
                        getChannelUrl: function() {
                            if (!this._channelUrl) {
                                var y = this;
                                this._channelUrl = t.handler(function(z) {
                                    y.fire("xd." + z.type, z);
                                }, "parent.parent", true);
                            }
                            return this._channelUrl;
                        },
                        getIframeNode: function() {
                            return this.dom.getElementsByTagName("iframe")[0];
                        },
                        arbiterInform: function(event, y, z) {
                            t.sendToFacebook(this.getIframeName(), {
                                method: event,
                                params: ES("JSON", "stringify", false, y || {}),
                                behavior: z || h.BEHAVIOR_PERSISTENT
                            });
                        },
                        _arbiterInform: function(event, y, z) {
                            var aa = 'parent.frames["' + this.getIframeNode().name + '"]';
                            t.inform(event, y, aa, z);
                        },
                        getDefaultWebDomain: function() {
                            return s.resolve("www");
                        },
                        process: function(y) {
                            if (this._done) {
                                if (!this._allowReProcess && !y) return;
                                this.clear();
                            } else this._oneTimeSetup();
                            this._done = true;
                            this._iframeName = this.getIframeName() || this._iframeName || n();
                            if (!this.setupAndValidate()) {
                                this.fire("render");
                                return;
                            }
                            if (this._showLoader) this._addLoader();
                            k.addCss(this.dom, "fb_iframe_widget");
                            if (this._visibleAfter != "immediate") {
                                k.addCss(this.dom, "fb_hide_iframes");
                            } else this.subscribe("iframe.onload", ES(this.fire, "bind", true, this, "render"));
                            var z = this.getSize() || {}, aa = this.getFullyQualifiedURL();
                            if (z.width == "100%") k.addCss(this.dom, "fb_iframe_widget_fluid");
                            this.clear();
                            o({
                                url: aa,
                                root: this.dom.appendChild(document.createElement("span")),
                                name: this._iframeName,
                                title: this.getIframeTitle(),
                                className: q.getRtl() ? "fb_rtl" : "fb_ltr",
                                height: z.height,
                                width: z.width,
                                onload: ES(this.fire, "bind", true, this, "iframe.onload")
                            });
                            this._resizeFlow(z);
                            this.loaded = false;
                            this.subscribe("iframe.onload", ES(function() {
                                this.loaded = true;
                                if (!this._isResizeHandled) k.addCss(this.dom, "fb_hide_iframes");
                            }, "bind", true, this));
                        },
                        generateWidgetPipeIframeName: function() {
                            v++;
                            return "fb_iframe_" + v;
                        },
                        getFullyQualifiedURL: function() {
                            var y = this._getURL();
                            y += "?" + p.encode(this._getQS());
                            if (y.length > 2e3) {
                                y = "about:blank";
                                var z = ES(function() {
                                    this._postRequest();
                                    this.unsubscribe("iframe.onload", z);
                                }, "bind", true, this);
                                this.subscribe("iframe.onload", z);
                            }
                            return y;
                        },
                        _getWidgetPipeShell: function() {
                            return s.resolve("www") + "/common/widget_pipe_shell.php";
                        },
                        _oneTimeSetup: function() {
                            this.subscribe("xd.resize", ES(this._handleResizeMsg, "bind", true, this));
                            this.subscribe("xd.resize", ES(this._bubbleResizeEvent, "bind", true, this));
                            this.subscribe("xd.resize.iframe", ES(this._resizeIframe, "bind", true, this));
                            this.subscribe("xd.resize.flow", ES(this._resizeFlow, "bind", true, this));
                            this.subscribe("xd.resize.flow", ES(this._bubbleResizeEvent, "bind", true, this));
                            this.subscribe("xd.refreshLoginStatus", function() {
                                i.getLoginStatus(function() {}, true);
                            });
                            this.subscribe("xd.logout", function() {
                                r({
                                    method: "auth.logout",
                                    display: "hidden"
                                }, function() {});
                            });
                            if (this._refreshOnAuthChange) this._setupAuthRefresh();
                            if (this._visibleAfter == "load") this.subscribe("iframe.onload", ES(this._makeVisible, "bind", true, this));
                            this.subscribe("xd.verify", ES(function(y) {
                                this.arbiterInform("xd/verify", y.token);
                            }, "bind", true, this));
                            this.oneTimeSetup();
                        },
                        _makeVisible: function() {
                            this._removeLoader();
                            k.removeCss(this.dom, "fb_hide_iframes");
                            this.fire("render");
                        },
                        _setupAuthRefresh: function() {
                            i.getLoginStatus(ES(function(y) {
                                var z = y.status;
                                l.subscribe("auth.statusChange", ES(function(aa) {
                                    if (!this.isValid()) return;
                                    if (z == "unknown" || aa.status == "unknown") this.process(true);
                                    z = aa.status;
                                }, "bind", true, this));
                            }, "bind", true, this));
                        },
                        _handleResizeMsg: function(y) {
                            if (!this.isValid()) return;
                            this._resizeIframe(y);
                            this._resizeFlow(y);
                            if (!this._borderReset) {
                                this.getIframeNode().style.border = "none";
                                this._borderReset = true;
                            }
                            this._isResizeHandled = true;
                            this._makeVisible();
                        },
                        _bubbleResizeEvent: function(y) {
                            var z = {
                                height: y.height,
                                width: y.width,
                                pluginID: this.getAttribute("plugin-id")
                            };
                            l.fire("xfbml.resize", z);
                        },
                        _resizeIframe: function(y) {
                            var z = this.getIframeNode();
                            if (y.reposition === "true") this._repositionIframe(y);
                            y.height && (z.style.height = y.height + "px");
                            y.width && (z.style.width = y.width + "px");
                            this._updateIframeZIndex();
                        },
                        _resizeFlow: function(y) {
                            var z = this.dom.getElementsByTagName("span")[0];
                            y.height && (z.style.height = y.height + "px");
                            y.width && (z.style.width = y.width + "px");
                            this._updateIframeZIndex();
                        },
                        _updateIframeZIndex: function() {
                            var y = this.dom.getElementsByTagName("span")[0], z = this.getIframeNode(), aa = z.style.height === y.style.height && z.style.width === y.style.width, ba = aa ? "removeCss" : "addCss";
                            k[ba](z, "fb_iframe_widget_lift");
                        },
                        _repositionIframe: function(y) {
                            var z = this.getIframeNode(), aa = parseInt(k.getStyle(z, "width"), 10), ba = k.getPosition(z).x, ca = k.getViewportInfo().width, da = parseInt(y.width, 10);
                            if (ba + da > ca && ba > da) {
                                z.style.left = aa - da + "px";
                                this.arbiterInform("xd/reposition", {
                                    type: "horizontal"
                                });
                                this._repositioned = true;
                            } else if (this._repositioned) {
                                z.style.left = "0px";
                                this.arbiterInform("xd/reposition", {
                                    type: "restore"
                                });
                                this._repositioned = false;
                            }
                        },
                        _addLoader: function() {
                            if (!this._loaderDiv) {
                                k.addCss(this.dom, "fb_iframe_widget_loader");
                                this._loaderDiv = document.createElement("div");
                                this._loaderDiv.className = "FB_Loader";
                                this.dom.appendChild(this._loaderDiv);
                            }
                        },
                        _removeLoader: function() {
                            if (this._loaderDiv) {
                                k.removeCss(this.dom, "fb_iframe_widget_loader");
                                if (this._loaderDiv.parentNode) this._loaderDiv.parentNode.removeChild(this._loaderDiv);
                                this._loaderDiv = null;
                            }
                        },
                        _getQS: function() {
                            return ES("Object", "assign", false, {
                                api_key: q.getClientID(),
                                locale: q.getLocale(),
                                sdk: "joey",
                                kid_directed_site: q.getKidDirectedSite(),
                                ref: this.getAttribute("ref")
                            }, this.getUrlBits().params);
                        },
                        _getURL: function() {
                            var y = this.getDefaultWebDomain(), z = "";
                            return y + "/plugins/" + z + this.getUrlBits().name + ".php";
                        },
                        _postRequest: function() {
                            j.submitToTarget({
                                url: this._getURL(),
                                target: this.getIframeNode().name,
                                params: this._getQS()
                            });
                        }
                    }), v = 0, w = {};
                    function x() {
                        var y = {};
                        for (var z in w) {
                            var aa = w[z];
                            y[z] = {
                                widget: aa.getUrlBits().name,
                                params: aa._getQS()
                            };
                        }
                        return y;
                    }
                    f.exports = u;
                }, null);
                __d("sdk.XFBML.Comments", [ "sdk.Event", "sdk.XFBML.IframeWidget", "QueryString", "sdk.Runtime", "JSSDKConfig", "sdk.UA", "UrlMap" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n) {
                    if (c.__markCompiled) c.__markCompiled();
                    var o = i.extend({
                        _visibleAfter: "immediate",
                        _refreshOnAuthChange: true,
                        setupAndValidate: function() {
                            var p = {
                                channel_url: this.getChannelUrl(),
                                colorscheme: this.getAttribute("colorscheme"),
                                skin: this.getAttribute("skin"),
                                numposts: this.getAttribute("num-posts", 10),
                                width: this._getLengthAttribute("width"),
                                href: this.getAttribute("href"),
                                permalink: this.getAttribute("permalink"),
                                publish_feed: this.getAttribute("publish_feed"),
                                order_by: this.getAttribute("order_by"),
                                mobile: this._getBoolAttribute("mobile"),
                                version: this.getAttribute("version")
                            };
                            if (!p.width && !p.permalink) p.width = 550;
                            if (l.initSitevars.enableMobileComments && m.mobile() && p.mobile !== false) {
                                p.mobile = true;
                                delete p.width;
                            }
                            if (!p.skin) p.skin = p.colorscheme;
                            if (!p.href) {
                                p.migrated = this.getAttribute("migrated");
                                p.xid = this.getAttribute("xid");
                                p.title = this.getAttribute("title", document.title);
                                p.url = this.getAttribute("url", document.URL);
                                p.quiet = this.getAttribute("quiet");
                                p.reverse = this.getAttribute("reverse");
                                p.simple = this.getAttribute("simple");
                                p.css = this.getAttribute("css");
                                p.notify = this.getAttribute("notify");
                                if (!p.xid) {
                                    var q = ES(document.URL, "indexOf", true, "#");
                                    if (q > 0) {
                                        p.xid = encodeURIComponent(document.URL.substring(0, q));
                                    } else p.xid = encodeURIComponent(document.URL);
                                }
                                if (p.migrated) p.href = n.resolve("www") + "/plugins/comments_v1.php?" + "app_id=" + k.getClientID() + "&xid=" + encodeURIComponent(p.xid) + "&url=" + encodeURIComponent(p.url);
                            } else {
                                var r = this.getAttribute("fb_comment_id");
                                if (!r) {
                                    r = j.decode(document.URL.substring(ES(document.URL, "indexOf", true, "?") + 1)).fb_comment_id;
                                    if (r && ES(r, "indexOf", true, "#") > 0) r = r.substring(0, ES(r, "indexOf", true, "#"));
                                }
                                if (r) {
                                    p.fb_comment_id = r;
                                    this.subscribe("render", ES(function() {
                                        if (!window.location.hash) window.location.hash = this.getIframeNode().id;
                                    }, "bind", true, this));
                                }
                            }
                            if (!p.version) p.version = k.getVersion();
                            this._attr = p;
                            return true;
                        },
                        oneTimeSetup: function() {
                            this.subscribe("xd.sdk_event", function(p) {
                                h.fire(p.event, ES("JSON", "parse", false, p.data));
                            });
                        },
                        getSize: function() {
                            if (!this._attr.permalink) return {
                                width: this._attr.mobile || this._attr.width === "auto" ? "100%" : this._attr.width,
                                height: 100
                            };
                        },
                        getUrlBits: function() {
                            return {
                                name: "comments",
                                params: this._attr
                            };
                        },
                        getDefaultWebDomain: function() {
                            return n.resolve("www", true);
                        }
                    });
                    f.exports = o;
                }, null);
                __d("sdk.XFBML.CommentsCount", [ "ApiClient", "sdk.DOM", "sdk.XFBML.Element", "sprintf" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    var l = j.extend({
                        process: function() {
                            i.addCss(this.dom, "fb_comments_count_zero");
                            var m = this.getAttribute("href", window.location.href);
                            h.scheduleBatchCall("/v2.1/" + encodeURIComponent(m), {
                                fields: "share"
                            }, ES(function(n) {
                                var o = n.share && n.share.comment_count || 0;
                                i.html(this.dom, k('<span class="fb_comments_count">%s</span>', o));
                                if (o > 0) i.removeCss(this.dom, "fb_comments_count_zero");
                                this.fire("render");
                            }, "bind", true, this));
                        }
                    });
                    f.exports = l;
                }, null);
                __d("safeEval", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i, j) {
                        if (i === null || typeof i === "undefined") return;
                        if (typeof i !== "string") return i;
                        if (/^\w+$/.test(i) && typeof window[i] === "function") return window[i].apply(null, j || []);
                        return Function('return eval("' + i.replace(/"/g, '\\"') + '");').apply(null, j || []);
                    }
                    f.exports = h;
                }, null);
                __d("sdk.Helper", [ "sdk.ErrorHandling", "sdk.Event", "UrlMap", "safeEval", "sprintf" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    var m = {
                        isUser: function(n) {
                            return n < 22e8 || n >= 1e14 && n <= 0x5b0a58f100ef || n >= 89e12 && n <= 89999999999999 || n >= 6000001e7 && n <= 60000019999999;
                        },
                        upperCaseFirstChar: function(n) {
                            if (n.length > 0) {
                                return n.substr(0, 1).toUpperCase() + n.substr(1);
                            } else return n;
                        },
                        getProfileLink: function(n, o, p) {
                            if (!p && n) p = l("%s/profile.php?id=%s", j.resolve("www"), n.uid || n.id);
                            if (p) o = l('<a class="fb_link" href="%s">%s</a>', p, o);
                            return o;
                        },
                        invokeHandler: function(n, o, p) {
                            if (n) if (typeof n === "string") {
                                h.unguard(k)(n, p);
                            } else if (n.apply) h.unguard(n).apply(o, p || []);
                        },
                        fireEvent: function(n, o) {
                            var p = o._attr.href;
                            o.fire(n, p);
                            i.fire(n, p, o);
                        },
                        executeFunctionByName: function(n) {
                            var o = Array.prototype.slice.call(arguments, 1), p = n.split("."), q = p.pop(), r = window;
                            for (var s = 0; s < p.length; s++) r = r[p[s]];
                            return r[q].apply(this, o);
                        }
                    };
                    f.exports = m;
                }, null);
                __d("sdk.XFBML.LoginButton", [ "sdk.Helper", "IframePlugin", "Log", "sdk.ui" ], function a(b, c, d, e, f, g, h, i, j, k) {
                    if (c.__markCompiled) c.__markCompiled();
                    var l = i.extend({
                        constructor: function(m, n, o, p) {
                            this.parent(m, n, o, p);
                            var q = i.getVal(p, "on_login"), r = null;
                            if (q) {
                                r = function(s) {
                                    if (s.error_code) {
                                        j.debug("Plugin Return Error (%s): %s", s.error_code, s.error_message || s.error_description);
                                        return;
                                    }
                                    h.invokeHandler(q, null, [ s ]);
                                };
                                this.subscribe("login.status", r);
                            }
                            this.subscribe("xd.login_button_native_open", function(s) {
                                k(ES("JSON", "parse", false, s.params), r);
                            });
                        },
                        getParams: function() {
                            return {
                                scope: "string",
                                perms: "string",
                                size: "string",
                                login_text: "text",
                                show_faces: "bool",
                                max_rows: "string",
                                show_login_face: "bool",
                                registration_url: "url_maybe",
                                auto_logout_link: "bool",
                                one_click: "bool",
                                show_banner: "bool",
                                auth_type: "string",
                                default_audience: "string"
                            };
                        }
                    });
                    f.exports = l;
                }, null);
                __d("escapeHTML", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    var h = /[&<>"'\/]/g, i = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#039;",
                        "/": "&#x2F;"
                    };
                    function j(k) {
                        return k.replace(h, function(l) {
                            return i[l];
                        });
                    }
                    f.exports = j;
                }, null);
                __d("sdk.XFBML.Name", [ "ApiClient", "escapeHTML", "sdk.Event", "sdk.XFBML.Element", "sdk.Helper", "Log", "sdk.Runtime" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n) {
                    if (c.__markCompiled) c.__markCompiled();
                    var o = {}.hasOwnProperty, p = k.extend({
                        process: function() {
                            ES("Object", "assign", false, this, {
                                _uid: this.getAttribute("uid"),
                                _firstnameonly: this._getBoolAttribute("first-name-only"),
                                _lastnameonly: this._getBoolAttribute("last-name-only"),
                                _possessive: this._getBoolAttribute("possessive"),
                                _reflexive: this._getBoolAttribute("reflexive"),
                                _objective: this._getBoolAttribute("objective"),
                                _linked: this._getBoolAttribute("linked", true),
                                _subjectId: this.getAttribute("subject-id")
                            });
                            if (!this._uid) {
                                m.error('"uid" is a required attribute for <fb:name>');
                                this.fire("render");
                                return;
                            }
                            var q = [];
                            if (this._firstnameonly) {
                                q.push("first_name");
                            } else if (this._lastnameonly) {
                                q.push("last_name");
                            } else q.push("name");
                            if (this._subjectId) {
                                q.push("gender");
                                if (this._subjectId == n.getUserID()) this._reflexive = true;
                            }
                            j.monitor("auth.statusChange", ES(function() {
                                if (!this.isValid()) {
                                    this.fire("render");
                                    return true;
                                }
                                if (!this._uid || this._uid == "loggedinuser") this._uid = n.getUserID();
                                if (!this._uid) return;
                                h.scheduleBatchCall("/v1.0/" + this._uid, {
                                    fields: q.join(",")
                                }, ES(function(r) {
                                    if (o.call(r, "error")) {
                                        m.warn("The name is not found for ID: " + this._uid);
                                        return;
                                    }
                                    if (this._subjectId == this._uid) {
                                        this._renderPronoun(r);
                                    } else this._renderOther(r);
                                    this.fire("render");
                                }, "bind", true, this));
                            }, "bind", true, this));
                        },
                        _renderPronoun: function(q) {
                            var r = "", s = this._objective;
                            if (this._subjectId) {
                                s = true;
                                if (this._subjectId === this._uid) this._reflexive = true;
                            }
                            if (this._uid == n.getUserID() && this._getBoolAttribute("use-you", true)) {
                                if (this._possessive) {
                                    if (this._reflexive) {
                                        r = "your own";
                                    } else r = "your";
                                } else if (this._reflexive) {
                                    r = "yourself";
                                } else r = "you";
                            } else switch (q.gender) {
                              case "male":
                                if (this._possessive) {
                                    r = this._reflexive ? "his own" : "his";
                                } else if (this._reflexive) {
                                    r = "himself";
                                } else if (s) {
                                    r = "him";
                                } else r = "he";
                                break;

                              case "female":
                                if (this._possessive) {
                                    r = this._reflexive ? "her own" : "her";
                                } else if (this._reflexive) {
                                    r = "herself";
                                } else if (s) {
                                    r = "her";
                                } else r = "she";
                                break;

                              default:
                                if (this._getBoolAttribute("use-they", true)) {
                                    if (this._possessive) {
                                        if (this._reflexive) {
                                            r = "their own";
                                        } else r = "their";
                                    } else if (this._reflexive) {
                                        r = "themselves";
                                    } else if (s) {
                                        r = "them";
                                    } else r = "they";
                                } else if (this._possessive) {
                                    if (this._reflexive) {
                                        r = "his/her own";
                                    } else r = "his/her";
                                } else if (this._reflexive) {
                                    r = "himself/herself";
                                } else if (s) {
                                    r = "him/her";
                                } else r = "he/she";
                                break;
                            }
                            if (this._getBoolAttribute("capitalize", false)) r = l.upperCaseFirstChar(r);
                            this.dom.innerHTML = r;
                        },
                        _renderOther: function(q) {
                            var r = "", s = "";
                            if (this._uid == n.getUserID() && this._getBoolAttribute("use-you", true)) {
                                if (this._reflexive) {
                                    if (this._possessive) {
                                        r = "your own";
                                    } else r = "yourself";
                                } else if (this._possessive) {
                                    r = "your";
                                } else r = "you";
                            } else if (q) {
                                if (null === q.first_name) q.first_name = "";
                                if (null === q.last_name) q.last_name = "";
                                if (this._firstnameonly && q.first_name !== undefined) {
                                    r = i(q.first_name);
                                } else if (this._lastnameonly && q.last_name !== undefined) r = i(q.last_name);
                                if (!r) r = i(q.name);
                                if (r !== "" && this._possessive) r += "'s";
                            }
                            if (!r) r = i(this.getAttribute("if-cant-see", "Facebook User"));
                            if (r) {
                                if (this._getBoolAttribute("capitalize", false)) r = l.upperCaseFirstChar(r);
                                if (q && this._linked) {
                                    s = l.getProfileLink(q, r, this.getAttribute("href", null));
                                } else s = r;
                            }
                            this.dom.innerHTML = s;
                        }
                    });
                    f.exports = p;
                }, null);
                __d("UnicodeUtils", [ "invariant" ], function a(b, c, d, e, f, g, h) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var i = 55296, j = 56319, k = 56320, l = 57343, m = /[\uD800-\uDFFF]/;
                    function n(w) {
                        return i <= w && w <= l;
                    }
                    function o(w, x) {
                        !(0 <= x && x < w.length) ? h(0) : void 0;
                        if (x + 1 === w.length) return false;
                        var y = w.charCodeAt(x), z = w.charCodeAt(x + 1);
                        return i <= y && y <= j && k <= z && z <= l;
                    }
                    function p(w) {
                        return m.test(w);
                    }
                    function q(w, x) {
                        return 1 + n(w.charCodeAt(x));
                    }
                    function r(w) {
                        if (!p(w)) return w.length;
                        var x = 0;
                        for (var y = 0; y < w.length; y += q(w, y)) x++;
                        return x;
                    }
                    function s(w, x, y) {
                        x = x || 0;
                        y = y === undefined ? Infinity : y || 0;
                        if (!p(w)) return w.substr(x, y);
                        var z = w.length;
                        if (z <= 0 || x > z || y <= 0) return "";
                        var aa = 0;
                        if (x > 0) {
                            for (;x > 0 && aa < z; x--) aa += q(w, aa);
                            if (aa >= z) return "";
                        } else if (x < 0) {
                            for (aa = z; x < 0 && 0 < aa; x++) aa -= q(w, aa - 1);
                            if (aa < 0) aa = 0;
                        }
                        var ba = z;
                        if (y < z) for (ba = aa; y > 0 && ba < z; y--) ba += q(w, ba);
                        return w.substring(aa, ba);
                    }
                    function t(w, x, y) {
                        x = x || 0;
                        y = y === undefined ? Infinity : y || 0;
                        if (x < 0) x = 0;
                        if (y < 0) y = 0;
                        var z = Math.abs(y - x);
                        x = x < y ? x : y;
                        return s(w, x, z);
                    }
                    function u(w) {
                        var x = [];
                        for (var y = 0; y < w.length; y += q(w, y)) x.push(w.codePointAt(y));
                        return x;
                    }
                    var v = {
                        getCodePoints: u,
                        getUTF16Length: q,
                        hasSurrogateUnit: p,
                        isCodeUnitInSurrogateRange: n,
                        isSurrogatePair: o,
                        strlen: r,
                        substring: t,
                        substr: s
                    };
                    f.exports = v;
                }, null);
                __d("isNode", [], function a(b, c, d, e, f, g) {
                    if (c.__markCompiled) c.__markCompiled();
                    function h(i) {
                        return !!(i && (typeof Node === "function" ? i instanceof Node : typeof i === "object" && typeof i.nodeType === "number" && typeof i.nodeName === "string"));
                    }
                    f.exports = h;
                }, null);
                __d("isTextNode", [ "isNode" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j) {
                        return h(j) && j.nodeType == 3;
                    }
                    f.exports = i;
                }, null);
                __d("containsNode", [ "isTextNode" ], function a(b, c, d, e, f, g, h) {
                    if (c.__markCompiled) c.__markCompiled();
                    function i(j, k) {
                        if (!j || !k) {
                            return false;
                        } else if (j === k) {
                            return true;
                        } else if (h(j)) {
                            return false;
                        } else if (h(k)) {
                            return i(j, k.parentNode);
                        } else if ("contains" in j) {
                            return ES(j, "contains", true, k);
                        } else if (j.compareDocumentPosition) {
                            return !!(j.compareDocumentPosition(k) & 16);
                        } else return false;
                    }
                    f.exports = i;
                }, null);
                __d("sdk.XFBML.Quote", [ "sdk.DOM", "DOMEventListener", "IframePlugin", "UnicodeUtils", "sdk.UA", "sdk.XD", "containsNode", "sdk.feature" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var p = "fb-quotable", q = 155, r = 70, s = "", t = null, u = [], v = false, w = null, x = l.mobile();
                    function y(ca) {
                        if (!document.getSelection || x) return;
                        var da = document.getSelection();
                        if (da.rangeCount === 0) {
                            aa();
                            return;
                        }
                        var ea = u.length;
                        aa();
                        if (ea) {
                            var fa = false;
                            for (var ga = 0; ga < ea; ga++) if (n(u[ga], da.focusNode)) {
                                fa = true;
                                break;
                            }
                            if (!fa) return;
                        }
                        s = da.toString();
                        if (s === "") {
                            aa();
                            return;
                        }
                        s = ES(s.toString().replace(/\s+/g, " "), "trim", true);
                        var ha = Number(o("sharequotelimit", 500));
                        if (k.strlen(s) > ha) {
                            s = k.substr(s, 0, ha - 3) + "...";
                        } else s = k.substr(s, 0, ha);
                        if (!v && w) {
                            var ia = z(da);
                            w.style.left = ia.x + "px";
                            w.style.top = ia.y + "px";
                        }
                    }
                    function z(ca) {
                        var da = w && w.offsetWidth, ea = da ? w.offsetHeight : r, fa = da ? w.offsetWidth : q, ga = ca.getRangeAt(0), ha = document.createElement("span"), ia = document.createElement("span"), ja = document.createRange();
                        ja.setStart(ga.startContainer, ga.startOffset);
                        ja.insertNode(ha);
                        var ka = document.createRange();
                        ka.setStart(ga.endContainer, ga.endOffset);
                        ka.insertNode(ia);
                        var la = ha.offsetTop - ea, ma = ha.offsetLeft + (ia.offsetLeft - ha.offsetLeft) / 2 - fa / 2;
                        ha.parentNode.removeChild(ha);
                        ia.parentNode.removeChild(ia);
                        return {
                            x: ma,
                            y: la
                        };
                    }
                    function aa() {
                        s = "";
                        if (!v && w) w.style.left = "-9999px";
                    }
                    var ba = j.extend({
                        constructor: function(ca, da, ea, fa) {
                            if (t) return t;
                            this.parent(ca, da, ea, fa);
                            v = h.getAttr(ca, "layout") === "button";
                            w = ca;
                            w.style.position = "absolute";
                            w.style.display = "";
                            i.add(document, "keyup", y);
                            i.add(document, "mouseup", y);
                            this.subscribe("xd.getTextSelection", ES(function() {
                                m.sendToFacebook(this._iframeOptions.name, {
                                    method: "setTextSelection",
                                    params: ES("JSON", "stringify", false, {
                                        text: s
                                    })
                                });
                                aa();
                            }, "bind", true, this));
                            u = ES(ES("Array", "from", false, document.getElementsByTagName("*")), "filter", true, function(ga) {
                                return ga.nodeName.toLowerCase() === "article" || h.containsCss(ga, p);
                            });
                            aa();
                            t = this;
                            return t;
                        },
                        getParams: function() {
                            return {
                                href: "url",
                                layout: "string"
                            };
                        }
                    });
                    f.exports = ba;
                }, null);
                __d("sdk.XFBML.Save", [ "sdk.Content", "sdk.DialogUtils", "sdk.DOM", "sdk.Event", "IframePlugin", "QueryString", "sdk.UA", "sdk.XD", "sdk.createIframe" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var q = l.extend({
                        constructor: function(r, s, t, u) {
                            this.parent(r, s, t, u);
                            var v = n.mobile();
                            this.subscribe("xd.savePluginGetBlankIframe", ES(function(w) {
                                var x = void 0, y = void 0, z = void 0, aa = function(fa) {
                                    if (fa) j.removeCss(fa, "fb_invisible");
                                }, ba = function(fa) {
                                    if (fa) j.addCss(fa, "fb_invisible");
                                };
                                if (v) {
                                    x = i.setupNewDarkOverlay();
                                    ba(x);
                                    h.append(x);
                                    i.addDoubleClickAction(x, function() {
                                        return ES(z, "forEach", true, ba);
                                    }, 5e3);
                                }
                                y = this.setupNewIframeDialog(ES("JSON", "parse", false, w.data), w.fromIframe, ES("JSON", "parse", false, w.isHTTPS));
                                ba(y);
                                h.append(y);
                                z = [ y, x ];
                                var ca = function() {
                                    ES(z, "forEach", true, ba);
                                    i.onDialogHideCleanup(v);
                                }, da = void 0;
                                this.subscribe("xd.savePluginShowIframe", ES(function() {
                                    k.fire("savePlugin:hideDialog");
                                    ES(z, "forEach", true, aa);
                                    this.positionOnScreen(y, x);
                                    if (!v && !da) da = i.addIdleDesktopAction(y, ca, 7e3);
                                }, "bind", true, this));
                                this.subscribe("xd.savePluginHideIframe", function() {
                                    return ca();
                                });
                                k.subscribe("savePlugin:hideDialog", function() {
                                    return ca();
                                });
                                var ea = setInterval(function() {
                                    var fa = document.getElementsByName(w.fromIframe);
                                    if (fa.length === 0) {
                                        clearTimeout(ea);
                                        ca();
                                        ES(z, "forEach", true, function(ga) {
                                            ga && ga.parentNode.removeChild(ga);
                                        });
                                    }
                                }, 500);
                            }, "bind", true, this));
                        },
                        positionOnScreen: function(r, s) {
                            var t = n.mobile();
                            if (t) {
                                (function() {
                                    var u = function(v, w) {
                                        if (w != null) i.setDialogPositionToCenter(w, t);
                                        i.setDialogPositionToCenter(v, t);
                                    };
                                    u(r, s);
                                    i.addMobileOrientationChangeAction(function(v) {
                                        u(r, s);
                                    });
                                    setInterval(function() {
                                        return u(r, s);
                                    }, 100);
                                })();
                            } else {
                                j.setStyle(r, "position", "fixed");
                                j.setStyle(r, "top", "20px");
                                j.setStyle(r, "right", "20px");
                            }
                        },
                        setupNewIframeDialog: function(r, s, t) {
                            var u = "#" + m.encode({
                                forIframe: s
                            }), v = i.setupNewDialog();
                            p({
                                url: o.getXDArbiterURL(t) + u,
                                name: "blank_" + this._iframeOptions.name,
                                root: v.contentRoot,
                                tabindex: -1
                            });
                            j.addCss(v.contentRoot, "fb_dialog_iframe");
                            ES("Object", "assign", false, v.dialogElement.style, r.style || {});
                            j.setStyle(v.dialogElement, "width", r.width + "px");
                            j.setStyle(v.dialogElement, "height", r.height + "px");
                            ES(r.classList, "forEach", true, function(w) {
                                return j.addCss(v.dialogElement, w);
                            });
                            j.removeCss(v.dialogElement, "fb_dialog_advanced");
                            return v.dialogElement;
                        },
                        getParams: function() {
                            return {
                                uri: "url",
                                url_category: "string",
                                size: "string"
                            };
                        }
                    });
                    f.exports = q;
                }, null);
                __d("sdk.XFBML.ShareButton", [ "IframePlugin", "sdk.UA", "sdk.ui" ], function a(b, c, d, e, f, g, h, i, j) {
                    "use strict";
                    if (c.__markCompiled) c.__markCompiled();
                    var k = h.extend({
                        constructor: function(l, m, n, o) {
                            this.parent(l, m, n, o);
                            this.subscribe("xd.shareTriggerMobileIframe", function(p) {
                                var q = ES("JSON", "parse", false, p.data);
                                j({
                                    method: "share",
                                    href: q.href,
                                    mobile_iframe: i.mobile()
                                });
                            });
                        },
                        getParams: function() {
                            return {
                                href: "url",
                                layout: "string",
                                mobile_iframe: "bool",
                                type: "string",
                                size: "string"
                            };
                        }
                    });
                    f.exports = k;
                }, null);
                __d("sdk.XFBML.Video", [ "Assert", "sdk.Event", "IframePlugin", "ObservableMixin", "sdk.XD" ], function a(b, c, d, e, f, g, h, i, j, k, l) {
                    if (c.__markCompiled) c.__markCompiled();
                    function m(p) {
                        "use strict";
                        this.$VideoCache1 = p.isMuted;
                        this.$VideoCache2 = p.volume;
                        this.$VideoCache3 = p.timePosition;
                        this.$VideoCache4 = p.duration;
                    }
                    m.prototype.update = function(p) {
                        "use strict";
                        if (p.isMuted !== undefined) this.$VideoCache1 = p.isMuted;
                        if (p.volume !== undefined) this.$VideoCache2 = p.volume;
                        if (p.timePosition !== undefined) this.$VideoCache3 = p.timePosition;
                        if (p.duration !== undefined) this.$VideoCache4 = p.duration;
                    };
                    m.prototype.isMuted = function() {
                        "use strict";
                        return this.$VideoCache1;
                    };
                    m.prototype.getVolume = function() {
                        "use strict";
                        return this.$VideoCache1 ? 0 : this.$VideoCache2;
                    };
                    m.prototype.getCurrentPosition = function() {
                        "use strict";
                        return this.$VideoCache3;
                    };
                    m.prototype.getDuration = function() {
                        "use strict";
                        return this.$VideoCache4;
                    };
                    function n(p, q, r) {
                        "use strict";
                        this.$VideoController1 = p;
                        this.$VideoController2 = q;
                        this.$VideoController3 = r;
                    }
                    n.prototype.play = function() {
                        "use strict";
                        l.sendToFacebook(this.$VideoController1, {
                            method: "play",
                            params: ES("JSON", "stringify", false, {})
                        });
                    };
                    n.prototype.pause = function() {
                        "use strict";
                        l.sendToFacebook(this.$VideoController1, {
                            method: "pause",
                            params: ES("JSON", "stringify", false, {})
                        });
                    };
                    n.prototype.seek = function(p) {
                        "use strict";
                        h.isNumber(p, "Invalid argument");
                        l.sendToFacebook(this.$VideoController1, {
                            method: "seek",
                            params: ES("JSON", "stringify", false, {
                                target: p
                            })
                        });
                    };
                    n.prototype.mute = function() {
                        "use strict";
                        l.sendToFacebook(this.$VideoController1, {
                            method: "mute",
                            params: ES("JSON", "stringify", false, {})
                        });
                    };
                    n.prototype.unmute = function() {
                        "use strict";
                        l.sendToFacebook(this.$VideoController1, {
                            method: "unmute",
                            params: ES("JSON", "stringify", false, {})
                        });
                    };
                    n.prototype.setVolume = function(p) {
                        "use strict";
                        h.isNumber(p, "Invalid argument");
                        l.sendToFacebook(this.$VideoController1, {
                            method: "setVolume",
                            params: ES("JSON", "stringify", false, {
                                volume: p
                            })
                        });
                    };
                    n.prototype.isMuted = function() {
                        "use strict";
                        return this.$VideoController3.isMuted();
                    };
                    n.prototype.getVolume = function() {
                        "use strict";
                        return this.$VideoController3.getVolume();
                    };
                    n.prototype.getCurrentPosition = function() {
                        "use strict";
                        return this.$VideoController3.getCurrentPosition();
                    };
                    n.prototype.getDuration = function() {
                        "use strict";
                        return this.$VideoController3.getDuration();
                    };
                    n.prototype.subscribe = function(event, p) {
                        "use strict";
                        h.isString(event, "Invalid argument");
                        h.isFunction(p, "Invalid argument");
                        this.$VideoController2.subscribe(event, p);
                        return {
                            release: ES(function() {
                                this.$VideoController2.unsubscribe(event, p);
                            }, "bind", true, this)
                        };
                    };
                    var o = j.extend({
                        constructor: function(p, q, r, s) {
                            this.parent(p, q, r, s);
                            this._videoController = null;
                            this._sharedObservable = null;
                            this._sharedVideoCache = null;
                            this.subscribe("xd.onVideoAPIReady", function(t) {
                                this._sharedObservable = new k();
                                this._sharedVideoCache = new m(ES("JSON", "parse", false, t.data));
                                this._videoController = new n(this._iframeOptions.name, this._sharedObservable, this._sharedVideoCache);
                                i.fire("xfbml.ready", {
                                    type: "video",
                                    id: s.id,
                                    instance: this._videoController
                                });
                            });
                            this.subscribe("xd.stateChange", function(t) {
                                this._sharedObservable.inform(t.state);
                            });
                            this.subscribe("xd.cachedStateUpdateRequest", function(t) {
                                this._sharedVideoCache.update(ES("JSON", "parse", false, t.data));
                            });
                        },
                        getParams: function() {
                            return {
                                allowfullscreen: "bool",
                                autoplay: "bool",
                                controls: "bool",
                                href: "url",
                                show_captions: "bool",
                                show_text: "bool"
                            };
                        },
                        getConfig: function() {
                            return {
                                fluid: true,
                                full_width: true
                            };
                        }
                    });
                    f.exports = o;
                }, null);
                __d("legacy:fb.xfbml", [ "Assert", "sdk.Event", "FB", "IframePlugin", "PluginConfig", "PluginTags", "XFBML", "sdk.domReady", "sdk.feature", "wrapFunction", "sdk.XFBML.Comments", "sdk.XFBML.CommentsCount", "sdk.XFBML.LoginButton", "sdk.XFBML.Name", "sdk.XFBML.Quote", "sdk.XFBML.Save", "sdk.XFBML.ShareButton", "sdk.XFBML.Video" ], function a(b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {
                    if (c.__markCompiled) c.__markCompiled();
                    var r = {
                        comments: c("sdk.XFBML.Comments"),
                        comments_count: c("sdk.XFBML.CommentsCount"),
                        login_button: c("sdk.XFBML.LoginButton"),
                        name: c("sdk.XFBML.Name"),
                        quote: c("sdk.XFBML.Quote"),
                        save: c("sdk.XFBML.Save"),
                        share_button: c("sdk.XFBML.ShareButton"),
                        video: c("sdk.XFBML.Video")
                    }, s = p("plugin_tags_blacklist", []);
                    ES(ES("Object", "keys", false, m), "forEach", true, function(u) {
                        if (ES(s, "indexOf", true, u) !== -1) return;
                        n.registerTag({
                            xmlns: "fb",
                            localName: u.replace(/_/g, "-"),
                            ctor: k.withParams(m[u], l[u])
                        });
                    });
                    ES(ES("Object", "keys", false, r), "forEach", true, function(u) {
                        if (ES(s, "indexOf", true, u) !== -1) return;
                        n.registerTag({
                            xmlns: "fb",
                            localName: u.replace(/_/g, "-"),
                            ctor: r[u]
                        });
                    });
                    j.provide("XFBML", {
                        parse: function(u) {
                            h.maybeXfbml(u, "Invalid argument");
                            if (u && u.nodeType === 9) u = u.body;
                            return n.parse.apply(null, arguments);
                        }
                    });
                    n.subscribe("parse", ES(i.fire, "bind", true, i, "xfbml.parse"));
                    n.subscribe("render", ES(i.fire, "bind", true, i, "xfbml.render"));
                    i.subscribe("init:post", function(u) {
                        if (u.xfbml) setTimeout(q(ES(o, "bind", true, null, n.parse), "entry", "init:post:xfbml.parse"), 0);
                    });
                    h.define("Xfbml", function(u) {
                        return (u.nodeType === 1 || u.nodeType === 9) && typeof u.nodeName === "string";
                    });
                    try {
                        if (document.namespaces && !document.namespaces.item.fb) document.namespaces.add("fb");
                    } catch (t) {}
                }, 3);
            }
        }).call(global);
    }(window.inDapIF ? parent.window : window, window);
} catch (e) {
    new Image().src = "https://www.facebook.com/" + "common/scribe_endpoint.php?c=jssdk_error&m=" + encodeURIComponent('{"error":"LOAD", "extra": {"name":"' + e.name + '","line":"' + (e.lineNumber || e.line) + '","script":"' + (e.fileName || e.sourceURL || e.script) + '","stack":"' + (e.stackTrace || e.stack) + '","revision":"2425895","namespace":"FB","message":"' + e.message + '"}}');
}

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function() {
    function n(n) {
        function t(t, r, e, u, i, o) {
            for (;i >= 0 && o > i; i += n) {
                var a = u ? u[i] : i;
                e = r(e, t[a], a, t);
            }
            return e;
        }
        return function(r, e, u, i) {
            e = b(e, i, 4);
            var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1;
            return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a);
        };
    }
    function t(n) {
        return function(t, r, e) {
            r = x(r, e);
            for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i;
            return -1;
        };
    }
    function r(n, t, r) {
        return function(e, u, i) {
            var o = 0, a = O(e);
            if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), 
            e[i] === u ? i : -1;
            if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1;
            for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i;
            return -1;
        };
    }
    function e(n, t) {
        var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = "constructor";
        for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--; ) i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i);
    }
    var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function() {}, m = function(n) {
        return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), 
    exports._ = m) : u._ = m, m.VERSION = "1.8.3";
    var b = function(n, t, r) {
        if (t === void 0) return n;
        switch (null == r ? 3 : r) {
          case 1:
            return function(r) {
                return n.call(t, r);
            };

          case 2:
            return function(r, e) {
                return n.call(t, r, e);
            };

          case 3:
            return function(r, e, u) {
                return n.call(t, r, e, u);
            };

          case 4:
            return function(r, e, u, i) {
                return n.call(t, r, e, u, i);
            };
        }
        return function() {
            return n.apply(t, arguments);
        };
    }, x = function(n, t, r) {
        return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n);
    };
    m.iteratee = function(n, t) {
        return x(n, t, 1 / 0);
    };
    var _ = function(n, t) {
        return function(r) {
            var e = arguments.length;
            if (2 > e || null == r) return r;
            for (var u = 1; e > u; u++) for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {
                var f = o[c];
                t && r[f] !== void 0 || (r[f] = i[f]);
            }
            return r;
        };
    }, j = function(n) {
        if (!m.isObject(n)) return {};
        if (y) return y(n);
        d.prototype = n;
        var t = new d();
        return d.prototype = null, t;
    }, w = function(n) {
        return function(t) {
            return null == t ? void 0 : t[n];
        };
    }, A = Math.pow(2, 53) - 1, O = w("length"), k = function(n) {
        var t = O(n);
        return "number" == typeof t && t >= 0 && A >= t;
    };
    m.each = m.forEach = function(n, t, r) {
        t = b(t, r);
        var e, u;
        if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n); else {
            var i = m.keys(n);
            for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n);
        }
        return n;
    }, m.map = m.collect = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {
            var a = e ? e[o] : o;
            i[o] = t(n[a], a, n);
        }
        return i;
    }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function(n, t, r) {
        var e;
        return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0;
    }, m.filter = m.select = function(n, t, r) {
        var e = [];
        return t = x(t, r), m.each(n, function(n, r, u) {
            t(n, r, u) && e.push(n);
        }), e;
    }, m.reject = function(n, t, r) {
        return m.filter(n, m.negate(x(t)), r);
    }, m.every = m.all = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (!t(n[o], o, n)) return !1;
        }
        return !0;
    }, m.some = m.any = function(n, t, r) {
        t = x(t, r);
        for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {
            var o = e ? e[i] : i;
            if (t(n[o], o, n)) return !0;
        }
        return !1;
    }, m.contains = m.includes = m.include = function(n, t, r, e) {
        return k(n) || (n = m.values(n)), ("number" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0;
    }, m.invoke = function(n, t) {
        var r = l.call(arguments, 2), e = m.isFunction(t);
        return m.map(n, function(n) {
            var u = e ? t : n[t];
            return null == u ? u : u.apply(n, r);
        });
    }, m.pluck = function(n, t) {
        return m.map(n, m.property(t));
    }, m.where = function(n, t) {
        return m.filter(n, m.matcher(t));
    }, m.findWhere = function(n, t) {
        return m.find(n, m.matcher(t));
    }, m.max = function(n, t, r) {
        var e, u, i = -1 / 0, o = -1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], e > i && (i = e);
        } else t = x(t, r), m.each(n, function(n, r, e) {
            u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u);
        });
        return i;
    }, m.min = function(n, t, r) {
        var e, u, i = 1 / 0, o = 1 / 0;
        if (null == t && null != n) {
            n = k(n) ? n : m.values(n);
            for (var a = 0, c = n.length; c > a; a++) e = n[a], i > e && (i = e);
        } else t = x(t, r), m.each(n, function(n, r, e) {
            u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u);
        });
        return i;
    }, m.shuffle = function(n) {
        for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) t = m.random(0, i), 
        t !== i && (u[i] = u[t]), u[t] = r[i];
        return u;
    }, m.sample = function(n, t, r) {
        return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t));
    }, m.sortBy = function(n, t, r) {
        return t = x(t, r), m.pluck(m.map(n, function(n, r, e) {
            return {
                value: n,
                index: r,
                criteria: t(n, r, e)
            };
        }).sort(function(n, t) {
            var r = n.criteria, e = t.criteria;
            if (r !== e) {
                if (r > e || r === void 0) return 1;
                if (e > r || e === void 0) return -1;
            }
            return n.index - t.index;
        }), "value");
    };
    var F = function(n) {
        return function(t, r, e) {
            var u = {};
            return r = x(r, e), m.each(t, function(e, i) {
                var o = r(e, i, t);
                n(u, e, o);
            }), u;
        };
    };
    m.groupBy = F(function(n, t, r) {
        m.has(n, r) ? n[r].push(t) : n[r] = [ t ];
    }), m.indexBy = F(function(n, t, r) {
        n[r] = t;
    }), m.countBy = F(function(n, t, r) {
        m.has(n, r) ? n[r]++ : n[r] = 1;
    }), m.toArray = function(n) {
        return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : [];
    }, m.size = function(n) {
        return null == n ? 0 : k(n) ? n.length : m.keys(n).length;
    }, m.partition = function(n, t, r) {
        t = x(t, r);
        var e = [], u = [];
        return m.each(n, function(n, r, i) {
            (t(n, r, i) ? e : u).push(n);
        }), [ e, u ];
    }, m.first = m.head = m.take = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t);
    }, m.initial = function(n, t, r) {
        return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)));
    }, m.last = function(n, t, r) {
        return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t));
    }, m.rest = m.tail = m.drop = function(n, t, r) {
        return l.call(n, null == t || r ? 1 : t);
    }, m.compact = function(n) {
        return m.filter(n, m.identity);
    };
    var S = function(n, t, r, e) {
        for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {
            var c = n[o];
            if (k(c) && (m.isArray(c) || m.isArguments(c))) {
                t || (c = S(c, t, r));
                var f = 0, l = c.length;
                for (u.length += l; l > f; ) u[i++] = c[f++];
            } else r || (u[i++] = c);
        }
        return u;
    };
    m.flatten = function(n, t) {
        return S(n, t, !1);
    }, m.without = function(n) {
        return m.difference(n, l.call(arguments, 1));
    }, m.uniq = m.unique = function(n, t, r, e) {
        m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e));
        for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {
            var c = n[o], f = r ? r(c, o, n) : c;
            t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c);
        }
        return u;
    }, m.union = function() {
        return m.uniq(S(arguments, !0, !0));
    }, m.intersection = function(n) {
        for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {
            var i = n[e];
            if (!m.contains(t, i)) {
                for (var o = 1; r > o && m.contains(arguments[o], i); o++) ;
                o === r && t.push(i);
            }
        }
        return t;
    }, m.difference = function(n) {
        var t = S(arguments, !0, !0, 1);
        return m.filter(n, function(n) {
            return !m.contains(t, n);
        });
    }, m.zip = function() {
        return m.unzip(arguments);
    }, m.unzip = function(n) {
        for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e);
        return r;
    }, m.object = function(n, t) {
        for (var r = {}, e = 0, u = O(n); u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1];
        return r;
    }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function(n, t, r, e) {
        r = x(r, e, 1);
        for (var u = r(t), i = 0, o = O(n); o > i; ) {
            var a = Math.floor((i + o) / 2);
            r(n[a]) < u ? i = a + 1 : o = a;
        }
        return i;
    }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), 
    m.range = function(n, t, r) {
        null == t && (t = n || 0, n = 0), r = r || 1;
        for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, 
        n += r) u[i] = n;
        return u;
    };
    var E = function(n, t, r, e, u) {
        if (!(e instanceof t)) return n.apply(r, u);
        var i = j(n.prototype), o = n.apply(i, u);
        return m.isObject(o) ? o : i;
    };
    m.bind = function(n, t) {
        if (g && n.bind === g) return g.apply(n, l.call(arguments, 1));
        if (!m.isFunction(n)) throw new TypeError("Bind must be called on a function");
        var r = l.call(arguments, 2), e = function() {
            return E(n, e, t, this, r.concat(l.call(arguments)));
        };
        return e;
    }, m.partial = function(n) {
        var t = l.call(arguments, 1), r = function() {
            for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o];
            for (;e < arguments.length; ) i.push(arguments[e++]);
            return E(n, r, this, this, i);
        };
        return r;
    }, m.bindAll = function(n) {
        var t, r, e = arguments.length;
        if (1 >= e) throw new Error("bindAll must be passed function names");
        for (t = 1; e > t; t++) r = arguments[t], n[r] = m.bind(n[r], n);
        return n;
    }, m.memoize = function(n, t) {
        var r = function(e) {
            var u = r.cache, i = "" + (t ? t.apply(this, arguments) : e);
            return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i];
        };
        return r.cache = {}, r;
    }, m.delay = function(n, t) {
        var r = l.call(arguments, 2);
        return setTimeout(function() {
            return n.apply(null, r);
        }, t);
    }, m.defer = m.partial(m.delay, m, 1), m.throttle = function(n, t, r) {
        var e, u, i, o = null, a = 0;
        r || (r = {});
        var c = function() {
            a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null);
        };
        return function() {
            var f = m.now();
            a || r.leading !== !1 || (a = f);
            var l = t - (f - a);
            return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), 
            a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), 
            i;
        };
    }, m.debounce = function(n, t, r) {
        var e, u, i, o, a, c = function() {
            var f = m.now() - o;
            t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), 
            e || (i = u = null)));
        };
        return function() {
            i = this, u = arguments, o = m.now();
            var f = r && !e;
            return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a;
        };
    }, m.wrap = function(n, t) {
        return m.partial(t, n);
    }, m.negate = function(n) {
        return function() {
            return !n.apply(this, arguments);
        };
    }, m.compose = function() {
        var n = arguments, t = n.length - 1;
        return function() {
            for (var r = t, e = n[t].apply(this, arguments); r--; ) e = n[r].call(this, e);
            return e;
        };
    }, m.after = function(n, t) {
        return function() {
            return --n < 1 ? t.apply(this, arguments) : void 0;
        };
    }, m.before = function(n, t) {
        var r;
        return function() {
            return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r;
        };
    }, m.once = m.partial(m.before, 2);
    var M = !{
        toString: null
    }.propertyIsEnumerable("toString"), I = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
    m.keys = function(n) {
        if (!m.isObject(n)) return [];
        if (v) return v(n);
        var t = [];
        for (var r in n) m.has(n, r) && t.push(r);
        return M && e(n, t), t;
    }, m.allKeys = function(n) {
        if (!m.isObject(n)) return [];
        var t = [];
        for (var r in n) t.push(r);
        return M && e(n, t), t;
    }, m.values = function(n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]];
        return e;
    }, m.mapObject = function(n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) e = u[a], o[e] = t(n[e], e, n);
        return o;
    }, m.pairs = function(n) {
        for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [ t[u], n[t[u]] ];
        return e;
    }, m.invert = function(n) {
        for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e];
        return t;
    }, m.functions = m.methods = function(n) {
        var t = [];
        for (var r in n) m.isFunction(n[r]) && t.push(r);
        return t.sort();
    }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function(n, t, r) {
        t = x(t, r);
        for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (e = u[i], t(n[e], e, n)) return e;
    }, m.pick = function(n, t, r) {
        var e, u, i = {}, o = n;
        if (null == o) return i;
        m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), 
        e = function(n, t, r) {
            return t in r;
        }, o = Object(o));
        for (var a = 0, c = u.length; c > a; a++) {
            var f = u[a], l = o[f];
            e(l, f, o) && (i[f] = l);
        }
        return i;
    }, m.omit = function(n, t, r) {
        if (m.isFunction(t)) t = m.negate(t); else {
            var e = m.map(S(arguments, !1, !1, 1), String);
            t = function(n, t) {
                return !m.contains(e, t);
            };
        }
        return m.pick(n, t, r);
    }, m.defaults = _(m.allKeys, !0), m.create = function(n, t) {
        var r = j(n);
        return t && m.extendOwn(r, t), r;
    }, m.clone = function(n) {
        return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n;
    }, m.tap = function(n, t) {
        return t(n), n;
    }, m.isMatch = function(n, t) {
        var r = m.keys(t), e = r.length;
        if (null == n) return !e;
        for (var u = Object(n), i = 0; e > i; i++) {
            var o = r[i];
            if (t[o] !== u[o] || !(o in u)) return !1;
        }
        return !0;
    };
    var N = function(n, t, r, e) {
        if (n === t) return 0 !== n || 1 / n === 1 / t;
        if (null == n || null == t) return n === t;
        n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped);
        var u = s.call(n);
        if (u !== s.call(t)) return !1;
        switch (u) {
          case "[object RegExp]":
          case "[object String]":
            return "" + n == "" + t;

          case "[object Number]":
            return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t;

          case "[object Date]":
          case "[object Boolean]":
            return +n === +t;
        }
        var i = "[object Array]" === u;
        if (!i) {
            if ("object" != typeof n || "object" != typeof t) return !1;
            var o = n.constructor, a = t.constructor;
            if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && "constructor" in n && "constructor" in t) return !1;
        }
        r = r || [], e = e || [];
        for (var c = r.length; c--; ) if (r[c] === n) return e[c] === t;
        if (r.push(n), e.push(t), i) {
            if (c = n.length, c !== t.length) return !1;
            for (;c--; ) if (!N(n[c], t[c], r, e)) return !1;
        } else {
            var f, l = m.keys(n);
            if (c = l.length, m.keys(t).length !== c) return !1;
            for (;c--; ) if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1;
        }
        return r.pop(), e.pop(), !0;
    };
    m.isEqual = function(n, t) {
        return N(n, t);
    }, m.isEmpty = function(n) {
        return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length;
    }, m.isElement = function(n) {
        return !(!n || 1 !== n.nodeType);
    }, m.isArray = h || function(n) {
        return "[object Array]" === s.call(n);
    }, m.isObject = function(n) {
        var t = typeof n;
        return "function" === t || "object" === t && !!n;
    }, m.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(n) {
        m["is" + n] = function(t) {
            return s.call(t) === "[object " + n + "]";
        };
    }), m.isArguments(arguments) || (m.isArguments = function(n) {
        return m.has(n, "callee");
    }), "function" != typeof /./ && "object" != typeof Int8Array && (m.isFunction = function(n) {
        return "function" == typeof n || !1;
    }), m.isFinite = function(n) {
        return isFinite(n) && !isNaN(parseFloat(n));
    }, m.isNaN = function(n) {
        return m.isNumber(n) && n !== +n;
    }, m.isBoolean = function(n) {
        return n === !0 || n === !1 || "[object Boolean]" === s.call(n);
    }, m.isNull = function(n) {
        return null === n;
    }, m.isUndefined = function(n) {
        return n === void 0;
    }, m.has = function(n, t) {
        return null != n && p.call(n, t);
    }, m.noConflict = function() {
        return u._ = i, this;
    }, m.identity = function(n) {
        return n;
    }, m.constant = function(n) {
        return function() {
            return n;
        };
    }, m.noop = function() {}, m.property = w, m.propertyOf = function(n) {
        return null == n ? function() {} : function(t) {
            return n[t];
        };
    }, m.matcher = m.matches = function(n) {
        return n = m.extendOwn({}, n), function(t) {
            return m.isMatch(t, n);
        };
    }, m.times = function(n, t, r) {
        var e = Array(Math.max(0, n));
        t = b(t, r, 1);
        for (var u = 0; n > u; u++) e[u] = t(u);
        return e;
    }, m.random = function(n, t) {
        return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1));
    }, m.now = Date.now || function() {
        return new Date().getTime();
    };
    var B = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, T = m.invert(B), R = function(n) {
        var t = function(t) {
            return n[t];
        }, r = "(?:" + m.keys(n).join("|") + ")", e = RegExp(r), u = RegExp(r, "g");
        return function(n) {
            return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, t) : n;
        };
    };
    m.escape = R(B), m.unescape = R(T), m.result = function(n, t, r) {
        var e = null == n ? void 0 : n[t];
        return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e;
    };
    var q = 0;
    m.uniqueId = function(n) {
        var t = ++q + "";
        return n ? n + t : t;
    }, m.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var K = /(.)^/, z = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, D = /\\|'|\r|\n|\u2028|\u2029/g, L = function(n) {
        return "\\" + z[n];
    };
    m.template = function(n, t, r) {
        !t && r && (t = r), t = m.defaults({}, t, m.templateSettings);
        var e = RegExp([ (t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source ].join("|") + "|$", "g"), u = 0, i = "__p+='";
        n.replace(e, function(t, r, e, o, a) {
            return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : e ? i += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : o && (i += "';\n" + o + "\n__p+='"), 
            t;
        }), i += "';\n", t.variable || (i = "with(obj||{}){\n" + i + "}\n"), i = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + i + "return __p;\n";
        try {
            var o = new Function(t.variable || "obj", "_", i);
        } catch (a) {
            throw a.source = i, a;
        }
        var c = function(n) {
            return o.call(this, n, m);
        }, f = t.variable || "obj";
        return c.source = "function(" + f + "){\n" + i + "}", c;
    }, m.chain = function(n) {
        var t = m(n);
        return t._chain = !0, t;
    };
    var P = function(n, t) {
        return n._chain ? m(t).chain() : t;
    };
    m.mixin = function(n) {
        m.each(m.functions(n), function(t) {
            var r = m[t] = n[t];
            m.prototype[t] = function() {
                var n = [ this._wrapped ];
                return f.apply(n, arguments), P(this, r.apply(m, n));
            };
        });
    }, m.mixin(m), m.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(n) {
        var t = o[n];
        m.prototype[n] = function() {
            var r = this._wrapped;
            return t.apply(r, arguments), "shift" !== n && "splice" !== n || 0 !== r.length || delete r[0], 
            P(this, r);
        };
    }), m.each([ "concat", "join", "slice" ], function(n) {
        var t = o[n];
        m.prototype[n] = function() {
            return P(this, t.apply(this._wrapped, arguments));
        };
    }), m.prototype.value = function() {
        return this._wrapped;
    }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function() {
        return "" + this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return m;
    });
}).call(this);

function Event() {
    var subscriptions = {};
    //Remove a listener for an event
    this.unsubscribe = function(eventName, callbackFunction) {
        //Check if there are listeners for the event type
        if (!subscriptions[eventName]) {
            return false;
        }
        //Remove the existing listner
        var subscriptionIndex = subscriptions[eventName].indexOf(callbackFunction);
        if (subscriptionIndex < 0) {
            return false;
        }
        subscriptions[eventName].splice(subscriptionIndex, 1);
        return true;
    };
    //Add a listener for an event
    this.subscribe = function(eventName, callbackFunction) {
        //Create a list of listeners for a certain event type if it doesn't exist yet
        if (!subscriptions[eventName]) {
            subscriptions[eventName] = [];
        }
        //Check if the listener already exists
        if (subscriptions[eventName].indexOf(callbackFunction) < 0) {
            subscriptions[eventName].push(callbackFunction);
        }
    };
    //Fire an event
    this.publish = function(eventName, caller, eventData) {
        //Check if there are subscriptions for the event type
        if (!subscriptions[eventName]) {
            return false;
        }
        //Notify each of the subscriptions
        var i;
        for (i = 0; i < subscriptions[eventName].length; i++) {
            subscriptions[eventName][i].call(caller, eventName, eventData);
        }
    };
}

function ScreenManager() {
    var self = this, screens = [], events = new Event();
    this.container = null;
    //Get the current screen (the last screen in the chain)
    function getCurrentScreen() {
        var screenCount = screens.length, screenIndex = screenCount - 1;
        return screens[screenIndex];
    }
    function getPreviousScreen() {
        var screenCount = screens.length, screenIndex = screenCount - 2;
        return screens[screenIndex] || false;
    }
    //Check if the screen is a root screen and remove all previous screens if so
    function rootScreen(target) {
        if (!target.root && !target.forceRoot) {
            return;
        }
        var i, removeCount = screens.length - 1;
        //Destroy the screens that will be removed
        for (i = 0; i < removeCount; i++) {
            screens[i].destroy();
        }
        screens.splice(0, removeCount);
    }
    //Destroy and remove the last screen
    function clearLastScreen() {
        var screenCount = screens.length, lastIndex = screenCount - 1;
        screens[lastIndex].destroy();
        screens.splice(lastIndex, 1);
    }
    function queueScreenSlideLeft(direction) {
        direction = direction || 1;
        var target = getCurrentScreen(), prevScreen = getPreviousScreen(), startPos = 100, endPos = 0, tweener = new Tweenable();
        if (direction === -1) {
            startPos = 0;
            endPos = 100;
            target.container.style.left = "0%";
            if (prevScreen) {
                prevScreen.container.style.display = "";
            }
        } else {
            target.container.style.left = "100%";
            target.container.style.visibility = "";
        }
        tweener.tween({
            from: {
                left: startPos
            },
            to: {
                left: endPos
            },
            easing: "easeInOutCubic",
            duration: 400,
            step: function(state) {
                target.container.style.left = state["left"] + "%";
            },
            finish: function(state) {
                if (direction === 1) {
                    if (prevScreen) {
                        prevScreen.container.style.display = "none";
                    }
                    rootScreen(target);
                } else {
                    clearLastScreen();
                }
            }
        });
    }
    //Show a screen with no transition
    function queueScreenNoTransition(direction) {
        direction = direction || 1;
        var target = getCurrentScreen(), prevScreen = getPreviousScreen();
        if (direction === 1) {
            target.container.style.visibility = "";
            target.container.style.display = "";
            if (prevScreen) {
                prevScreen.container.style.display = "none";
            }
            rootScreen(target);
        } else {
            target.container.style.visibility = "hidden";
            target.container.style.display = "none";
            if (prevScreen) {
                prevScreen.container.style.display = "";
            }
            clearLastScreen();
        }
    }
    //Trigger a screen transition animation
    function triggerScreenTransition(direction) {
        direction = direction || 1;
        var target = getCurrentScreen();
        switch (target.transition) {
          case "slideLeft":
            queueScreenSlideLeft(direction);
            break;

          default:
            queueScreenNoTransition(direction);
            break;
        }
    }
    //Add the screen to the history and 
    function screenReady() {
        events.unsubscribe(this.id + "ContainerReady", screenReady);
        screens.push(this);
        triggerScreenTransition();
    }
    //Go back one screen
    this.goBack = function() {
        triggerScreenTransition(-1);
    };
    //Init a screen from its constructor
    this.addScreen = function(screen, screenData, forceRoot) {
        var screenConstructor = new screen(self, events, screenData, forceRoot);
        //Listen for when the screen container and its contents are ready to be displayed
        events.subscribe(screenConstructor.id + "ContainerReady", screenReady);
        screenConstructor.init();
    };
    //Destroy the screen manager and all the currently loaded screens
    this.destroy = function() {
        var i;
        for (i = 0; i < screens.length; i++) {
            screens[i].destroy();
        }
        screens = [];
    };
    //Initiate the screen manager
    this.init = function() {
        this.container = document.getElementById("app");
        //Load StartScreen by default
        if (StartScreen) {
            this.addScreen(StartScreen);
        }
    };
    this.init();
}

var FormHandler = function(userConfig) {
    var validate, fieldErrors = {}, fieldErrorContainers = {}, config = {
        form: false,
        submitBlacklist: {},
        onFieldChanged: false,
        onSubmitSuccess: false
    }, request, submitting = false;
    for (i in userConfig) {
        if (userConfig.hasOwnProperty(i)) {
            config[i] = userConfig[i];
        }
    }
    function resetValidation() {
        var i, wrapper;
        for (i in fieldErrors) {
            if (i && fieldErrors.hasOwnProperty(i)) {
                wrapper = getParentWithClass(config["form"].elements[i], "field-wrapper");
                wrapper.className = "field-wrapper";
            }
        }
        for (i in fieldErrorContainers) {
            if (i && fieldErrorContainers.hasOwnProperty(i)) {
                fieldErrorContainers[i].innerHTML = "";
            }
        }
        fieldErrors = {};
        fieldErrorContainers = {};
    }
    function updateFieldError(field) {
        var wrapper = getParentWithClass(field, "field-wrapper");
        if (fieldErrors[field.name]) {
            swapClass(wrapper, "ok", "error");
            if (!fieldErrorContainers[field.name]) {
                fieldErrorContainers[field.name] = wrapper.querySelector("p.field-error");
            }
            if (fieldErrorContainers[field.name]) {
                fieldErrorContainers[field.name].textContent = fieldErrors[field.name];
            }
        } else {
            swapClass(wrapper, "error", "ok");
            if (fieldErrorContainers[field.name]) {
                fieldErrorContainers[field.name].innerHTML = "";
            }
        }
    }
    //Full processing of a single field validation
    function validateField(e) {
        var field = e.target || e, fieldName = field.name, fieldValidation = validate.field(field), linkedField;
        //Update form errors
        if (fieldValidation.valid && fieldErrors[fieldName]) {
            fieldErrors[fieldName] = false;
        } else {
            fieldErrors[fieldName] = fieldValidation.error;
        }
        updateFieldError(field);
        if (e.target && config.onFieldChanged) {
            config.onFieldChanged(fieldName, fieldValidation);
        }
        linkedField = field.getAttribute("linkeddate") || field.getAttribute("linkedtime") || false;
        //Validate linked field
        //Compare the field and value of e to avoid an infinite loop of linked fields
        if (linkedField && field !== e) {
            linkedField = field.form.elements[linkedField];
            validateField(linkedField);
        }
        return fieldValidation;
    }
    //Full processing of an entire form validation
    function validateForm() {
        var isValid = true, fields = config["form"].elements, i, fieldValidation, validationBlacklist = [ "fieldset", "button", "hidden", "reset", "submit" ];
        for (i = 0; i < fields.length; i++) {
            if (validationBlacklist.indexOf(fields[i].type) < 0) {
                fieldValidation = validateField(fields[i]);
                if (!fieldValidation.valid) {
                    isValid = false;
                }
            }
        }
        return isValid;
    }
    function disableFormActions() {
        var formFields = config["form"].elements;
        if (formFields["submit-btn"]) {
            formFields["submit-btn"].disabled = true;
        }
        if (formFields["reset-btn"]) {
            formFields["reset-btn"].disabled = true;
        }
    }
    function enableFormActions() {
        var formFields = config["form"].elements;
        if (formFields["submit-btn"]) {
            formFields["submit-btn"].disabled = false;
        }
        if (formFields["reset-btn"]) {
            formFields["reset-btn"].disabled = false;
        }
    }
    function formResponse(e) {
        var target = e.target, response, onSuccessGoTo;
        if (target.readyState !== 4) {
            return;
        }
        if (target.status >= 200 && target.status < 400) {
            response = JSON.parse(target.responseText);
            if (response.success) {
                onSuccessGoTo = config["form"].getAttribute("onsuccessgoto");
                if (onSuccessGoTo) {
                    return window.location = onSuccessGoTo;
                }
                if (config["onSubmitSuccess"]) {
                    config["onSubmitSuccess"]();
                }
            } else {}
            if (config["form"].getAttribute("onsuccessgoto")) {}
        } else {
            console.error("Error submitting form.", target.responseText);
        }
        enableFormActions();
        submitting = false;
    }
    function serializeFormData() {
        var fields = config["form"].elements, fieldType, i, j, valuePairs = [];
        for (i = 0; i < fields.length; i++) {
            if (fields[i].name && !config.submitBlacklist[fields[i].name]) {
                fieldType = fields[i].type;
                nodeName = fields[i].nodeName.toLowerCase();
                if (nodeName === "button" || nodeName === "fieldset") {
                    continue;
                }
                if (fieldType === "checkbox" || fieldType === "radio") {
                    if (!fields[i].checked) {
                        continue;
                    }
                }
                if (fieldType !== "select-multiple") {
                    valuePairs.push(encodeURIComponent(fields[i].name) + "=" + encodeURIComponent(fields[i].value));
                    continue;
                }
                for (j = 0; j < fields[i].selectedOptions.length; j += 1) {
                    valuePairs.push(encodeURIComponent(fields[i].name) + "=" + encodeURIComponent(fields[i].selectedOptions[j].value));
                }
            }
        }
        return valuePairs.join("&");
    }
    function sendFormData() {
        var formData = serializeFormData(), method = config["form"].method.toUpperCase(), action = config["form"].action + (method === "GET" ? "?" + formData : "");
        request = new XMLHttpRequest();
        request.onreadystatechange = formResponse;
        request.open(method, action, true);
        request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        if (method === "POST") {
            request.send(formData);
        } else {
            request.send();
        }
    }
    function submitForm(e) {
        e.preventDefault();
        if (submitting) {
            return;
        }
        var isValid = validateForm(), formData;
        if (isValid) {
            submitting = true;
            config["form"].classList.add("submitting");
            disableFormActions();
            sendFormData();
        } else {
            console.log("errors in the form");
        }
    }
    function formReset() {
        var photoPreviews = config.form.getElementsByClassName("photo-crop-preview"), photoPreview, i;
        for (i = 0; i < photoPreviews.length; i++) {
            photoPreview = photoPreviews[i];
            photoPreview.parentNode.removeChild(photoPreview);
        }
        setTimeout(resetValidation, 50);
    }
    function initDateUI(dateField) {
        dateField.readOnly = true;
        var datePickerOpts = {
            field: dateField,
            format: "YYYY-MM-DD"
        }, datePicker, minDate = dateField.getAttribute("min"), maxDate = dateField.getAttribute("max");
        if (minDate) {
            datePickerOpts["minDate"] = moment(minDate, "YYYY-MM-DD").toDate();
        }
        if (maxDate) {
            datePickerOpts["maxDate"] = moment(maxDate, "YYYY-MM-DD").toDate();
        }
        datePicker = new Pikaday(datePickerOpts);
    }
    function initTimeUI(timeField) {
        timeField.readOnly = true;
        var timePicker = new TimePicker({
            target: timeField
        });
        timePicker.init();
    }
    //Remove event listeners
    function destroy() {
        config["form"].removeEventListener("change", validateForm);
        config["form"].removeEventListener("submit", submitForm);
        config["form"].removeEventListener("reset", formReset);
        config["form"].reset();
        enableFormActions();
        config = {
            form: false,
            submitBlacklist: []
        };
        fieldErrors = undefined;
        fieldErrorContainers = undefined;
        validate = undefined;
        if (request) {
            request.abort();
            request = undefined;
        }
    }
    //Add event listeners and required attributes
    function init() {
        if (!config["form"]) {
            return;
        }
        enableFormActions();
        var i, fields = config["form"].elements, dateInputSupport = dateInputSupported();
        for (i = 0; i < fields.length; i += 1) {
            if (fields[i].getAttribute("type") === "date" && !dateInputSupport) {
                initDateUI(fields[i]);
            } else if (fields[i].getAttribute("type") === "time" && !dateInputSupport) {
                initTimeUI(fields[i]);
            }
        }
        validate = new Validate();
        config["form"].addEventListener("change", validateField);
        config["form"].addEventListener("submit", submitForm);
        config["form"].addEventListener("reset", formReset);
        config["form"].setAttribute("novalidate", "novalidate");
    }
    return {
        init: init,
        destroy: destroy,
        validateField: validateField
    };
};

var Validate = function() {
    //Validate the maximum value of a field
    function isMaxValueValid(field) {
        var output = {
            valid: true,
            field: field
        }, type = field.type, altType = field.getAttribute("type"), max = field.getAttribute("max"), value;
        if (max !== null) {
            if (type === "file") {
                max = parseFloat(max);
                if (field.files.length > max) {
                    output.valid = false;
                    output.error = "The maximum accepted number of uploaded files is " + max + ".";
                }
            } else if (field.value.length > 0) {
                max = parseFloat(max);
                value = parseFloat(field.value);
                if (value > max) {
                    field.value = max;
                    output.valid = false;
                    output.error = "The maximum accepted value is " + max + ".";
                }
            }
        }
        return output;
    }
    //Validate the minimum value of a field
    function isMinValueValid(field) {
        var output = {
            valid: true,
            field: field
        }, type = field.type, altType = field.getAttribute("type"), min = field.getAttribute("min"), value;
        if (min !== null) {
            if (type === "file" && field.files.length > 0) {
                min = parseFloat(min);
                if (field.files.length < min) {
                    output.valid = false;
                    output.error = "The minimum accepted number of uploaded files is " + min + ".";
                }
            } else if (field.value.length > 0) {
                min = parseFloat(min);
                value = parseFloat(field.value);
                if (value < min) {
                    field.value = min;
                    output.valid = false;
                    output.error = "The minimum accepted value is " + min + ".";
                }
            }
        }
        return output;
    }
    //Validate the maximum length of the value of a field
    function isMaxLengthValid(field) {
        var output = {
            valid: true,
            field: field
        }, maxLength = field.getAttribute("maxlength");
        if (maxLength !== null && field.value.length > parseInt(maxLength, 10)) {
            field.value = field.value.substring(0, maxLength);
            output.valid = false;
            output.error = "TThe maximum accepted length is " + maxLength + " characters.";
        }
        return output;
    }
    //Validate the minimum length of the value of a field
    function isMinLengthValid(field) {
        var output = {
            valid: true,
            field: field
        }, minLength = field.getAttribute("minlength");
        if (minLength !== null && field.value.length > 0 && field.value.length < parseInt(minLength, 10)) {
            output.valid = false;
            output.error = "The minimum accepted length is " + minLength + " characters.";
        }
        return output;
    }
    //Validate the value pattern of the field
    function isPatternValid(field) {
        var output = {
            valid: true,
            field: field
        }, pattern = field.getAttribute("pattern");
        pattern = pattern !== null ? new RegExp(pattern) : false;
        if (pattern && field.value.length > 0 && !pattern.test(field.value)) {
            output.valid = false;
            output.error = "The format is not valid.";
        }
        return output;
    }
    //Validate an email address in the field
    function isEmailValid(field) {
        var output = {
            valid: true,
            field: field
        }, type = field.type, emailRegEx = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
        if (type === "email" && field.value.length > 0 && !emailRegEx.test(field.value)) {
            output.valid = false;
            output.error = "The email address provided is not valid.";
        }
        return output;
    }
    //Validate the requirement of a field
    function isRequiredValid(field) {
        var output = {
            valid: true,
            field: field
        }, type = field.type;
        if (field.required) {
            if (type === "file") {
                if (field.files.length === 0) {
                    output.valid = false;
                    output.error = "This field is required.";
                }
            } else if (type === "select-multiple") {
                if (field.selectedOptions.length === 0) {
                    output.valid = false;
                    output.error = "This field is required.";
                }
            } else if (field.value.length === 0) {
                output.valid = false;
                output.error = "This field is required.";
            }
        }
        return output;
    }
    //Full processing of a single field validation
    function validateField(field) {
        if (!field) {
            console.warn("Tried to validate a form field, but no field was provided.");
            return;
        }
        var type = field.type, validationOutput = {
            valid: true,
            field: field
        }, requiredValidations = [ isRequiredValid, isPatternValid, isEmailValid, isMinLengthValid, isMaxLengthValid, isMinValueValid, isMaxValueValid ], i;
        //Remove white space on the ends
        if (type !== "file" && type !== "select" && type !== "select-multiple") {
            if (type === "number") {
                field.value = parseFloat(field.value);
            } else {
                field.value = field.value.trim();
            }
        }
        for (i = 0; i < requiredValidations.length; i++) {
            validationOutput = requiredValidations[i](field);
            if (!validationOutput.valid) {
                return validationOutput;
            }
        }
        return validationOutput;
    }
    return {
        field: validateField
    };
};

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === "object") {
        // CommonJS
        module.exports = factory();
    } else {
        // running in browser
        root.latinize = factory();
    }
})(this, function() {
    function latinize(str) {
        return str.replace(/[^A-Za-z0-9]/g, function(x) {
            return latinize.characters[x] || x;
        });
    }
    latinize.characters = {
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "aa",
        "": "ae",
        "": "ae",
        "": "ae",
        "": "ao",
        "": "au",
        "": "av",
        "": "av",
        "": "ay",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "b",
        "": "o",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "d",
        "": "i",
        "": "j",
        "": "j",
        "": "j",
        "": "dz",
        "": "dz",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "et",
        "": "f",
        "": "f",
        "": "f",
        "": "f",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "h",
        "": "hv",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "d",
        "": "f",
        "": "g",
        "": "r",
        "": "s",
        "": "t",
        "": "is",
        "": "j",
        "": "j",
        "": "j",
        "": "j",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "k",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "lj",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "m",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "nj",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "oi",
        "": "oo",
        "": "e",
        "": "e",
        "": "o",
        "": "o",
        "": "ou",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "p",
        "": "q",
        "": "q",
        "": "q",
        "": "q",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "c",
        "": "c",
        "": "e",
        "": "r",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "g",
        "": "o",
        "": "o",
        "": "u",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "t",
        "": "th",
        "": "a",
        "": "ae",
        "": "e",
        "": "g",
        "": "h",
        "": "h",
        "": "h",
        "": "i",
        "": "k",
        "": "l",
        "": "m",
        "": "m",
        "": "oe",
        "": "r",
        "": "r",
        "": "r",
        "": "r",
        "": "t",
        "": "v",
        "": "w",
        "": "y",
        "": "tz",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "ue",
        "": "um",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "v",
        "": "vy",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "w",
        "": "x",
        "": "x",
        "": "x",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "y",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "z",
        "": "ff",
        "": "ffi",
        "": "ffl",
        "": "fi",
        "": "fl",
        "": "ij",
        "": "oe",
        "": "st",
        "": "a",
        "": "e",
        "": "i",
        "": "j",
        "": "o",
        "": "r",
        "": "u",
        "": "v",
        "": "x"
    };
    return latinize;
});

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
/*global define: false*/
(function defineMustache(global, factory) {
    if (typeof exports === "object" && exports) {
        factory(exports);
    } else if (typeof define === "function" && define.amd) {
        define([ "exports" ], factory);
    } else {
        factory(global.Mustache = {});
    }
})(this, function mustacheFactory(mustache) {
    var objectToString = Object.prototype.toString;
    var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
    };
    function isFunction(object) {
        return typeof object === "function";
    }
    function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
    // See https://github.com/janl/mustache.js/issues/189
    var regExpTest = RegExp.prototype.test;
    function testRegExp(re, string) {
        return regExpTest.call(re, string);
    }
    var nonSpaceRe = /\S/;
    function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
    }
    var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    };
    function escapeHtml(string) {
        return String(string).replace(/[&<>"'\/]/g, function fromEntityMap(s) {
            return entityMap[s];
        });
    }
    var whiteRe = /\s*/;
    var spaceRe = /\s+/;
    var equalsRe = /\s*=/;
    var curlyRe = /\s*\}/;
    var tagRe = /#|\^|\/|>|\{|&|=|!/;
    /**
	 * Breaks up the given `template` string into a tree of tokens. If the `tags`
	 * argument is given here it must be an array with two string values: the
	 * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
	 * course, the default is to use mustaches (i.e. mustache.tags).
	 *
	 * A token is an array with at least 4 elements. The first element is the
	 * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
	 * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
	 * all text that appears outside a symbol this element is "text".
	 *
	 * The second element of a token is its "value". For mustache tags this is
	 * whatever else was inside the tag besides the opening symbol. For text tokens
	 * this is the text itself.
	 *
	 * The third and fourth elements of the token are the start and end indices,
	 * respectively, of the token in the original template.
	 *
	 * Tokens that are the root node of a subtree contain two more elements: 1) an
	 * array of tokens in the subtree and 2) the index in the original template at
	 * which the closing tag for that section begins.
	 */
    function parseTemplate(template, tags) {
        if (!template) return [];
        var sections = [];
        // Stack to hold section tokens
        var tokens = [];
        // Buffer to hold the tokens
        var spaces = [];
        // Indices of whitespace tokens on the current line
        var hasTag = false;
        // Is there a {{tag}} on the current line?
        var nonSpace = false;
        // Is there a non-space char on the current line?
        // Strips all whitespace tokens array for the current line
        // if there was a {{#tag}} on it and otherwise only space.
        function stripSpace() {
            if (hasTag && !nonSpace) {
                while (spaces.length) delete tokens[spaces.pop()];
            } else {
                spaces = [];
            }
            hasTag = false;
            nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
            if (typeof tagsToCompile === "string") tagsToCompile = tagsToCompile.split(spaceRe, 2);
            if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error("Invalid tags: " + tagsToCompile);
            openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
            closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
            closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
            start = scanner.pos;
            // Match any text between tags.
            value = scanner.scanUntil(openingTagRe);
            if (value) {
                for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
                    chr = value.charAt(i);
                    if (isWhitespace(chr)) {
                        spaces.push(tokens.length);
                    } else {
                        nonSpace = true;
                    }
                    tokens.push([ "text", chr, start, start + 1 ]);
                    start += 1;
                    // Check for whitespace on the current line.
                    if (chr === "\n") stripSpace();
                }
            }
            // Match the opening tag.
            if (!scanner.scan(openingTagRe)) break;
            hasTag = true;
            // Get the tag type.
            type = scanner.scan(tagRe) || "name";
            scanner.scan(whiteRe);
            // Get the tag value.
            if (type === "=") {
                value = scanner.scanUntil(equalsRe);
                scanner.scan(equalsRe);
                scanner.scanUntil(closingTagRe);
            } else if (type === "{") {
                value = scanner.scanUntil(closingCurlyRe);
                scanner.scan(curlyRe);
                scanner.scanUntil(closingTagRe);
                type = "&";
            } else {
                value = scanner.scanUntil(closingTagRe);
            }
            // Match the closing tag.
            if (!scanner.scan(closingTagRe)) throw new Error("Unclosed tag at " + scanner.pos);
            token = [ type, value, start, scanner.pos ];
            tokens.push(token);
            if (type === "#" || type === "^") {
                sections.push(token);
            } else if (type === "/") {
                // Check section nesting.
                openSection = sections.pop();
                if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);
                if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
            } else if (type === "name" || type === "{" || type === "&") {
                nonSpace = true;
            } else if (type === "=") {
                // Set the tags for the next time around.
                compileTags(value);
            }
        }
        // Make sure there are no open sections when we're done.
        openSection = sections.pop();
        if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
    }
    /**
	 * Combines the values of consecutive text tokens in the given `tokens` array
	 * to a single token.
	 */
    function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            if (token) {
                if (token[0] === "text" && lastToken && lastToken[0] === "text") {
                    lastToken[1] += token[1];
                    lastToken[3] = token[3];
                } else {
                    squashedTokens.push(token);
                    lastToken = token;
                }
            }
        }
        return squashedTokens;
    }
    /**
	 * Forms the given array of `tokens` into a nested tree structure where
	 * tokens that represent a section have two additional items: 1) an array of
	 * all tokens that appear in that section and 2) the index in the original
	 * template that represents the end of that section.
	 */
    function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            token = tokens[i];
            switch (token[0]) {
              case "#":
              case "^":
                collector.push(token);
                sections.push(token);
                collector = token[4] = [];
                break;

              case "/":
                section = sections.pop();
                section[5] = token[2];
                collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
                break;

              default:
                collector.push(token);
            }
        }
        return nestedTokens;
    }
    /**
	 * A simple string scanner that is used by the template parser to find
	 * tokens in template strings.
	 */
    function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
    }
    /**
	 * Returns `true` if the tail is empty (end of string).
	 */
    Scanner.prototype.eos = function eos() {
        return this.tail === "";
    };
    /**
	 * Tries to match the given regular expression at the current position.
	 * Returns the matched text if it can match, the empty string otherwise.
	 */
    Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0) return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
    };
    /**
	 * Skips all text until the given regular expression can be matched. Returns
	 * the skipped string, which is the entire tail if no match can be made.
	 */
    Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;

          case 0:
            match = "";
            break;

          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
    };
    /**
	 * Represents a rendering context by wrapping a view object and
	 * maintaining a reference to the parent context.
	 */
    function Context(view, parentContext) {
        this.view = view;
        this.cache = {
            ".": this.view
        };
        this.parent = parentContext;
    }
    /**
	 * Creates a new context using the given view with this context
	 * as the parent.
	 */
    Context.prototype.push = function push(view) {
        return new Context(view, this);
    };
    /**
	 * Returns the value of the given name in this context, traversing
	 * up the context hierarchy if the value is absent in this context's view.
	 */
    Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (name in cache) {
            value = cache[name];
        } else {
            var context = this, names, index, lookupHit = false;
            while (context) {
                if (name.indexOf(".") > 0) {
                    value = context.view;
                    names = name.split(".");
                    index = 0;
                    /**
					 * Using the dot notion path in `name`, we descend through the
					 * nested objects.
					 *
					 * To be certain that the lookup has been successful, we have to
					 * check if the last object in the path actually has the property
					 * we are looking for. We store the result in `lookupHit`.
					 *
					 * This is specially necessary for when the value has been set to
					 * `undefined` and we want to avoid looking up parent contexts.
					 **/
                    while (value != null && index < names.length) {
                        if (index === names.length - 1 && value != null) lookupHit = typeof value === "object" && value.hasOwnProperty(names[index]);
                        value = value[names[index++]];
                    }
                } else if (context.view != null && typeof context.view === "object") {
                    value = context.view[name];
                    lookupHit = context.view.hasOwnProperty(name);
                }
                if (lookupHit) break;
                context = context.parent;
            }
            cache[name] = value;
        }
        if (isFunction(value)) value = value.call(this.view);
        return value;
    };
    /**
	 * A Writer knows how to take a stream of tokens and render them to a
	 * string, given a context. It also maintains a cache of templates to
	 * avoid the need to parse the same template twice.
	 */
    function Writer() {
        this.cache = {};
    }
    /**
	 * Clears all cached templates in this writer.
	 */
    Writer.prototype.clearCache = function clearCache() {
        this.cache = {};
    };
    /**
	 * Parses and caches the given `template` and returns the array of tokens
	 * that is generated from the parse.
	 */
    Writer.prototype.parse = function parse(template, tags) {
        var cache = this.cache;
        var tokens = cache[template];
        if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);
        return tokens;
    };
    /**
	 * High-level method that is used to render the given `template` with
	 * the given `view`.
	 *
	 * The optional `partials` argument may be an object that contains the
	 * names and templates of partials that are used in the template. It may
	 * also be a function that is used to load partial templates on the fly
	 * that takes a single argument: the name of the partial.
	 */
    Writer.prototype.render = function render(template, view, partials) {
        var tokens = this.parse(template);
        var context = view instanceof Context ? view : new Context(view);
        return this.renderTokens(tokens, context, partials, template);
    };
    /**
	 * Low-level method that renders the given array of `tokens` using
	 * the given `context` and `partials`.
	 *
	 * Note: The `originalTemplate` is only ever used to extract the portion
	 * of the original template that was contained in a higher-order section.
	 * If the template doesn't use higher-order sections, this argument may
	 * be omitted.
	 */
    Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
            value = undefined;
            token = tokens[i];
            symbol = token[0];
            if (symbol === "#") value = this.renderSection(token, context, partials, originalTemplate); else if (symbol === "^") value = this.renderInverted(token, context, partials, originalTemplate); else if (symbol === ">") value = this.renderPartial(token, context, partials, originalTemplate); else if (symbol === "&") value = this.unescapedValue(token, context); else if (symbol === "name") value = this.escapedValue(token, context); else if (symbol === "text") value = this.rawValue(token);
            if (value !== undefined) buffer += value;
        }
        return buffer;
    };
    Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
        var self = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        // This function is used to render an arbitrary template
        // in the current context by higher-order sections.
        function subRender(template) {
            return self.render(template, context, partials);
        }
        if (!value) return;
        if (isArray(value)) {
            for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
                buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
            }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
            buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
        } else if (isFunction(value)) {
            if (typeof originalTemplate !== "string") throw new Error("Cannot use higher-order sections without the original template");
            // Extract the portion of the original template that the section contains.
            value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
            if (value != null) buffer += value;
        } else {
            buffer += this.renderTokens(token[4], context, partials, originalTemplate);
        }
        return buffer;
    };
    Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
        var value = context.lookup(token[1]);
        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
        if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);
    };
    Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
        if (!partials) return;
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
    };
    Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null) return value;
    };
    Writer.prototype.escapedValue = function escapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null) return mustache.escape(value);
    };
    Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
    };
    mustache.name = "mustache.js";
    mustache.version = "2.0.0";
    mustache.tags = [ "{{", "}}" ];
    // All high-level mustache.* functions use this writer.
    var defaultWriter = new Writer();
    /**
	 * Clears all cached templates in the default writer.
	 */
    mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
    };
    /**
	 * Parses and caches the given template in the default writer and returns the
	 * array of tokens it contains. Doing this ahead of time avoids the need to
	 * parse templates on the fly as they are rendered.
	 */
    mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
    };
    /**
	 * Renders the `template` with the given `view` and `partials` using the
	 * default writer.
	 */
    mustache.render = function render(template, view, partials) {
        return defaultWriter.render(template, view, partials);
    };
    // This is here for backwards compatibility with 0.4.x.,
    /*eslint-disable */
    // eslint wants camel cased function name
    mustache.to_html = function to_html(template, view, partials, send) {
        /*eslint-enable*/
        var result = mustache.render(template, view, partials);
        if (isFunction(send)) {
            send(result);
        } else {
            return result;
        }
    };
    // Export the escaping function so that the user may override it.
    // See https://github.com/janl/mustache.js/issues/244
    mustache.escape = escapeHtml;
    // Export these mainly for testing, but also for advanced usage.
    mustache.Scanner = Scanner;
    mustache.Context = Context;
    mustache.Writer = Writer;
});

(function() {
    var root = this;
    /*!
 * Shifty Core
 * By Jeremy Kahn - jeremyckahn@gmail.com
 */
    var Tweenable = function() {
        "use strict";
        // Aliases that get defined later in this function
        var formula;
        // CONSTANTS
        var DEFAULT_SCHEDULE_FUNCTION;
        var DEFAULT_EASING = "linear";
        var DEFAULT_DURATION = 500;
        var UPDATE_TIME = 1e3 / 60;
        var _now = Date.now ? Date.now : function() {
            return +new Date();
        };
        var now = typeof SHIFTY_DEBUG_NOW !== "undefined" ? SHIFTY_DEBUG_NOW : _now;
        if (typeof window !== "undefined") {
            // requestAnimationFrame() shim by Paul Irish (modified for Shifty)
            // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
            DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.mozCancelRequestAnimationFrame && window.mozRequestAnimationFrame || setTimeout;
        } else {
            DEFAULT_SCHEDULE_FUNCTION = setTimeout;
        }
        function noop() {}
        /*!
	 * Handy shortcut for doing a for-in loop. This is not a "normal" each
	 * function, it is optimized for Shifty.  The iterator function only receives
	 * the property name, not the value.
	 * @param {Object} obj
	 * @param {Function(string)} fn
	 */
        function each(obj, fn) {
            var key;
            for (key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    fn(key);
                }
            }
        }
        /*!
	 * Perform a shallow copy of Object properties.
	 * @param {Object} targetObject The object to copy into
	 * @param {Object} srcObject The object to copy from
	 * @return {Object} A reference to the augmented `targetObj` Object
	 */
        function shallowCopy(targetObj, srcObj) {
            each(srcObj, function(prop) {
                targetObj[prop] = srcObj[prop];
            });
            return targetObj;
        }
        /*!
	 * Copies each property from src onto target, but only if the property to
	 * copy to target is undefined.
	 * @param {Object} target Missing properties in this Object are filled in
	 * @param {Object} src
	 */
        function defaults(target, src) {
            each(src, function(prop) {
                if (typeof target[prop] === "undefined") {
                    target[prop] = src[prop];
                }
            });
        }
        /*!
	 * Calculates the interpolated tween values of an Object for a given
	 * timestamp.
	 * @param {Number} forPosition The position to compute the state for.
	 * @param {Object} currentState Current state properties.
	 * @param {Object} originalState: The original state properties the Object is
	 * tweening from.
	 * @param {Object} targetState: The destination state properties the Object
	 * is tweening to.
	 * @param {number} duration: The length of the tween in milliseconds.
	 * @param {number} timestamp: The UNIX epoch time at which the tween began.
	 * @param {Object} easing: This Object's keys must correspond to the keys in
	 * targetState.
	 */
        function tweenProps(forPosition, currentState, originalState, targetState, duration, timestamp, easing) {
            var normalizedPosition = forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;
            var prop;
            var easingObjectProp;
            var easingFn;
            for (prop in currentState) {
                if (currentState.hasOwnProperty(prop)) {
                    easingObjectProp = easing[prop];
                    easingFn = typeof easingObjectProp === "function" ? easingObjectProp : formula[easingObjectProp];
                    currentState[prop] = tweenProp(originalState[prop], targetState[prop], easingFn, normalizedPosition);
                }
            }
            return currentState;
        }
        /*!
	 * Tweens a single property.
	 * @param {number} start The value that the tween started from.
	 * @param {number} end The value that the tween should end at.
	 * @param {Function} easingFunc The easing curve to apply to the tween.
	 * @param {number} position The normalized position (between 0.0 and 1.0) to
	 * calculate the midpoint of 'start' and 'end' against.
	 * @return {number} The tweened value.
	 */
        function tweenProp(start, end, easingFunc, position) {
            return start + (end - start) * easingFunc(position);
        }
        /*!
	 * Applies a filter to Tweenable instance.
	 * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
	 * upon.
	 * @param {String} filterName The name of the filter to apply.
	 */
        function applyFilter(tweenable, filterName) {
            var filters = Tweenable.prototype.filter;
            var args = tweenable._filterArgs;
            each(filters, function(name) {
                if (typeof filters[name][filterName] !== "undefined") {
                    filters[name][filterName].apply(tweenable, args);
                }
            });
        }
        var timeoutHandler_endTime;
        var timeoutHandler_currentTime;
        var timeoutHandler_isEnded;
        var timeoutHandler_offset;
        /*!
	 * Handles the update logic for one step of a tween.
	 * @param {Tweenable} tweenable
	 * @param {number} timestamp
	 * @param {number} delay
	 * @param {number} duration
	 * @param {Object} currentState
	 * @param {Object} originalState
	 * @param {Object} targetState
	 * @param {Object} easing
	 * @param {Function(Object, *, number)} step
	 * @param {Function(Function,number)}} schedule
	 * @param {number=} opt_currentTimeOverride Needed for accurate timestamp in
	 * Tweenable#seek.
	 */
        function timeoutHandler(tweenable, timestamp, delay, duration, currentState, originalState, targetState, easing, step, schedule, opt_currentTimeOverride) {
            timeoutHandler_endTime = timestamp + delay + duration;
            timeoutHandler_currentTime = Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);
            timeoutHandler_isEnded = timeoutHandler_currentTime >= timeoutHandler_endTime;
            timeoutHandler_offset = duration - (timeoutHandler_endTime - timeoutHandler_currentTime);
            if (tweenable.isPlaying() && !timeoutHandler_isEnded) {
                tweenable._scheduleId = schedule(tweenable._timeoutHandler, UPDATE_TIME);
                applyFilter(tweenable, "beforeTween");
                // If the animation has not yet reached the start point (e.g., there was
                // delay that has not yet completed), just interpolate the starting
                // position of the tween.
                if (timeoutHandler_currentTime < timestamp + delay) {
                    tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
                } else {
                    tweenProps(timeoutHandler_currentTime, currentState, originalState, targetState, duration, timestamp + delay, easing);
                }
                applyFilter(tweenable, "afterTween");
                step(currentState, tweenable._attachment, timeoutHandler_offset);
            } else if (tweenable.isPlaying() && timeoutHandler_isEnded) {
                step(targetState, tweenable._attachment, timeoutHandler_offset);
                tweenable.stop(true);
            }
        }
        /*!
	 * Creates a usable easing Object from a string, a function or another easing
	 * Object.  If `easing` is an Object, then this function clones it and fills
	 * in the missing properties with `"linear"`.
	 * @param {Object.<string|Function>} fromTweenParams
	 * @param {Object|string|Function} easing
	 * @return {Object.<string|Function>}
	 */
        function composeEasingObject(fromTweenParams, easing) {
            var composedEasing = {};
            var typeofEasing = typeof easing;
            if (typeofEasing === "string" || typeofEasing === "function") {
                each(fromTweenParams, function(prop) {
                    composedEasing[prop] = easing;
                });
            } else {
                each(fromTweenParams, function(prop) {
                    if (!composedEasing[prop]) {
                        composedEasing[prop] = easing[prop] || DEFAULT_EASING;
                    }
                });
            }
            return composedEasing;
        }
        /**
	 * Tweenable constructor.
	 * @class Tweenable
	 * @param {Object=} opt_initialState The values that the initial tween should
	 * start at if a `from` object is not provided to `{{#crossLink
	 * "Tweenable/tween:method"}}{{/crossLink}}` or `{{#crossLink
	 * "Tweenable/setConfig:method"}}{{/crossLink}}`.
	 * @param {Object=} opt_config Configuration object to be passed to
	 * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
	 * @module Tweenable
	 * @constructor
	 */
        function Tweenable(opt_initialState, opt_config) {
            this._currentState = opt_initialState || {};
            this._configured = false;
            this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;
            // To prevent unnecessary calls to setConfig do not set default
            // configuration here.  Only set default configuration immediately before
            // tweening if none has been set.
            if (typeof opt_config !== "undefined") {
                this.setConfig(opt_config);
            }
        }
        /**
	 * Configure and start a tween.
	 * @method tween
	 * @param {Object=} opt_config Configuration object to be passed to
	 * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
	 * @chainable
	 */
        Tweenable.prototype.tween = function(opt_config) {
            if (this._isTweening) {
                return this;
            }
            // Only set default config if no configuration has been set previously and
            // none is provided now.
            if (opt_config !== undefined || !this._configured) {
                this.setConfig(opt_config);
            }
            this._timestamp = now();
            this._start(this.get(), this._attachment);
            return this.resume();
        };
        /**
	 * Configure a tween that will start at some point in the future.
	 *
	 * @method setConfig
	 * @param {Object} config The following values are valid:
	 * - __from__ (_Object=_): Starting position.  If omitted, `{{#crossLink
	 *   "Tweenable/get:method"}}get(){{/crossLink}}` is used.
	 * - __to__ (_Object=_): Ending position.
	 * - __duration__ (_number=_): How many milliseconds to animate for.
	 * - __delay__ (_delay=_): How many milliseconds to wait before starting the
	 *   tween.
	 * - __start__ (_Function(Object, *)_): Function to execute when the tween
	 *   begins.  Receives the state of the tween as the first parameter and
	 *   `attachment` as the second parameter.
	 * - __step__ (_Function(Object, *, number)_): Function to execute on every
	 *   tick.  Receives `{{#crossLink
	 *   "Tweenable/get:method"}}get(){{/crossLink}}` as the first parameter,
	 *   `attachment` as the second parameter, and the time elapsed since the
	 *   start of the tween as the third. This function is not called on the
	 *   final step of the animation, but `finish` is.
	 * - __finish__ (_Function(Object, *)_): Function to execute upon tween
	 *   completion.  Receives the state of the tween as the first parameter and
	 *   `attachment` as the second parameter.
	 * - __easing__ (_Object.<string|Function>|string|Function=_): Easing curve
	 *   name(s) or function(s) to use for the tween.
	 * - __attachment__ (_*_): Cached value that is passed to the
	 *   `step`/`start`/`finish` methods.
	 * @chainable
	 */
        Tweenable.prototype.setConfig = function(config) {
            config = config || {};
            this._configured = true;
            // Attach something to this Tweenable instance (e.g.: a DOM element, an
            // object, a string, etc.);
            this._attachment = config.attachment;
            // Init the internal state
            this._pausedAtTime = null;
            this._scheduleId = null;
            this._delay = config.delay || 0;
            this._start = config.start || noop;
            this._step = config.step || noop;
            this._finish = config.finish || noop;
            this._duration = config.duration || DEFAULT_DURATION;
            this._currentState = shallowCopy({}, config.from) || this.get();
            this._originalState = this.get();
            this._targetState = shallowCopy({}, config.to) || this.get();
            var self = this;
            this._timeoutHandler = function() {
                timeoutHandler(self, self._timestamp, self._delay, self._duration, self._currentState, self._originalState, self._targetState, self._easing, self._step, self._scheduleFunction);
            };
            // Aliases used below
            var currentState = this._currentState;
            var targetState = this._targetState;
            // Ensure that there is always something to tween to.
            defaults(targetState, currentState);
            this._easing = composeEasingObject(currentState, config.easing || DEFAULT_EASING);
            this._filterArgs = [ currentState, this._originalState, targetState, this._easing ];
            applyFilter(this, "tweenCreated");
            return this;
        };
        /**
	 * @method get
	 * @return {Object} The current state.
	 */
        Tweenable.prototype.get = function() {
            return shallowCopy({}, this._currentState);
        };
        /**
	 * @method set
	 * @param {Object} state The current state.
	 */
        Tweenable.prototype.set = function(state) {
            this._currentState = state;
        };
        /**
	 * Pause a tween.  Paused tweens can be resumed from the point at which they
	 * were paused.  This is different from `{{#crossLink
	 * "Tweenable/stop:method"}}{{/crossLink}}`, as that method
	 * causes a tween to start over when it is resumed.
	 * @method pause
	 * @chainable
	 */
        Tweenable.prototype.pause = function() {
            this._pausedAtTime = now();
            this._isPaused = true;
            return this;
        };
        /**
	 * Resume a paused tween.
	 * @method resume
	 * @chainable
	 */
        Tweenable.prototype.resume = function() {
            if (this._isPaused) {
                this._timestamp += now() - this._pausedAtTime;
            }
            this._isPaused = false;
            this._isTweening = true;
            this._timeoutHandler();
            return this;
        };
        /**
	 * Move the state of the animation to a specific point in the tween's
	 * timeline.  If the animation is not running, this will cause the `step`
	 * handlers to be called.
	 * @method seek
	 * @param {millisecond} millisecond The millisecond of the animation to seek
	 * to.  This must not be less than `0`.
	 * @chainable
	 */
        Tweenable.prototype.seek = function(millisecond) {
            millisecond = Math.max(millisecond, 0);
            var currentTime = now();
            if (this._timestamp + millisecond === 0) {
                return this;
            }
            this._timestamp = currentTime - millisecond;
            if (!this.isPlaying()) {
                this._isTweening = true;
                this._isPaused = false;
                // If the animation is not running, call timeoutHandler to make sure that
                // any step handlers are run.
                timeoutHandler(this, this._timestamp, this._delay, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step, this._scheduleFunction, currentTime);
                this.pause();
            }
            return this;
        };
        /**
	 * Stops and cancels a tween.
	 * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
	 * its current state, and the `finish` handler is not invoked.  If `true`,
	 * the tweened object's values are instantly set to the target values, and
	 * `finish` is invoked.
	 * @method stop
	 * @chainable
	 */
        Tweenable.prototype.stop = function(gotoEnd) {
            this._isTweening = false;
            this._isPaused = false;
            this._timeoutHandler = noop;
            (root.cancelAnimationFrame || root.webkitCancelAnimationFrame || root.oCancelAnimationFrame || root.msCancelAnimationFrame || root.mozCancelRequestAnimationFrame || root.clearTimeout)(this._scheduleId);
            if (gotoEnd) {
                applyFilter(this, "beforeTween");
                tweenProps(1, this._currentState, this._originalState, this._targetState, 1, 0, this._easing);
                applyFilter(this, "afterTween");
                applyFilter(this, "afterTweenEnd");
                this._finish.call(this, this._currentState, this._attachment);
            }
            return this;
        };
        /**
	 * @method isPlaying
	 * @return {boolean} Whether or not a tween is running.
	 */
        Tweenable.prototype.isPlaying = function() {
            return this._isTweening && !this._isPaused;
        };
        /**
	 * Set a custom schedule function.
	 *
	 * If a custom function is not set,
	 * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
	 * is used if available, otherwise
	 * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
	 * is used.
	 * @method setScheduleFunction
	 * @param {Function(Function,number)} scheduleFunction The function to be
	 * used to schedule the next frame to be rendered.
	 */
        Tweenable.prototype.setScheduleFunction = function(scheduleFunction) {
            this._scheduleFunction = scheduleFunction;
        };
        /**
	 * `delete` all "own" properties.  Call this when the `Tweenable` instance
	 * is no longer needed to free memory.
	 * @method dispose
	 */
        Tweenable.prototype.dispose = function() {
            var prop;
            for (prop in this) {
                if (this.hasOwnProperty(prop)) {
                    delete this[prop];
                }
            }
        };
        /*!
	 * Filters are used for transforming the properties of a tween at various
	 * points in a Tweenable's life cycle.  See the README for more info on this.
	 */
        Tweenable.prototype.filter = {};
        /**
	 * This object contains all of the tweens available to Shifty.  It is
	 * extensible - simply attach properties to the `Tweenable.prototype.formula`
	 * Object following the same format as `linear`.
	 *
	 * `pos` should be a normalized `number` (between 0 and 1).
	 * @property formula
	 * @type {Object(function)}
	 */
        Tweenable.prototype.formula = {
            linear: function(pos) {
                return pos;
            }
        };
        formula = Tweenable.prototype.formula;
        shallowCopy(Tweenable, {
            now: now,
            each: each,
            tweenProps: tweenProps,
            tweenProp: tweenProp,
            applyFilter: applyFilter,
            shallowCopy: shallowCopy,
            defaults: defaults,
            composeEasingObject: composeEasingObject
        });
        // `root` is provided in the intro/outro files.
        // A hook used for unit testing.
        if (typeof SHIFTY_DEBUG_NOW === "function") {
            root.timeoutHandler = timeoutHandler;
        }
        // Bootstrap Tweenable appropriately for the environment.
        if (typeof exports === "object") {
            // CommonJS
            module.exports = Tweenable;
        } else if (typeof define === "function" && define.amd) {
            // AMD
            define(function() {
                return Tweenable;
            });
        } else if (typeof root.Tweenable === "undefined") {
            // Browser: Make `Tweenable` globally accessible.
            root.Tweenable = Tweenable;
        }
        return Tweenable;
    }();
    (function() {
        Tweenable.shallowCopy(Tweenable.prototype.formula, {
            easeInQuad: function(pos) {
                return Math.pow(pos, 2);
            },
            easeOutQuad: function(pos) {
                return -(Math.pow(pos - 1, 2) - 1);
            },
            easeInOutQuad: function(pos) {
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(pos, 2);
                }
                return -.5 * ((pos -= 2) * pos - 2);
            },
            easeInCubic: function(pos) {
                return Math.pow(pos, 3);
            },
            easeOutCubic: function(pos) {
                return Math.pow(pos - 1, 3) + 1;
            },
            easeInOutCubic: function(pos) {
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(pos, 3);
                }
                return .5 * (Math.pow(pos - 2, 3) + 2);
            },
            easeInQuart: function(pos) {
                return Math.pow(pos, 4);
            },
            easeOutQuart: function(pos) {
                return -(Math.pow(pos - 1, 4) - 1);
            },
            easeInOutQuart: function(pos) {
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(pos, 4);
                }
                return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
            },
            easeInQuint: function(pos) {
                return Math.pow(pos, 5);
            },
            easeOutQuint: function(pos) {
                return Math.pow(pos - 1, 5) + 1;
            },
            easeInOutQuint: function(pos) {
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(pos, 5);
                }
                return .5 * (Math.pow(pos - 2, 5) + 2);
            },
            easeInSine: function(pos) {
                return -Math.cos(pos * (Math.PI / 2)) + 1;
            },
            easeOutSine: function(pos) {
                return Math.sin(pos * (Math.PI / 2));
            },
            easeInOutSine: function(pos) {
                return -.5 * (Math.cos(Math.PI * pos) - 1);
            },
            easeInExpo: function(pos) {
                return pos === 0 ? 0 : Math.pow(2, 10 * (pos - 1));
            },
            easeOutExpo: function(pos) {
                return pos === 1 ? 1 : -Math.pow(2, -10 * pos) + 1;
            },
            easeInOutExpo: function(pos) {
                if (pos === 0) {
                    return 0;
                }
                if (pos === 1) {
                    return 1;
                }
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(2, 10 * (pos - 1));
                }
                return .5 * (-Math.pow(2, -10 * --pos) + 2);
            },
            easeInCirc: function(pos) {
                return -(Math.sqrt(1 - pos * pos) - 1);
            },
            easeOutCirc: function(pos) {
                return Math.sqrt(1 - Math.pow(pos - 1, 2));
            },
            easeInOutCirc: function(pos) {
                if ((pos /= .5) < 1) {
                    return -.5 * (Math.sqrt(1 - pos * pos) - 1);
                }
                return .5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
            },
            easeOutBounce: function(pos) {
                if (pos < 1 / 2.75) {
                    return 7.5625 * pos * pos;
                } else if (pos < 2 / 2.75) {
                    return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                } else if (pos < 2.5 / 2.75) {
                    return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                } else {
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                }
            },
            easeInBack: function(pos) {
                var s = 1.70158;
                return pos * pos * ((s + 1) * pos - s);
            },
            easeOutBack: function(pos) {
                var s = 1.70158;
                return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
            },
            easeInOutBack: function(pos) {
                var s = 1.70158;
                if ((pos /= .5) < 1) {
                    return .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s));
                }
                return .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
            },
            elastic: function(pos) {
                // jshint maxlen:90
                return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
            },
            swingFromTo: function(pos) {
                var s = 1.70158;
                return (pos /= .5) < 1 ? .5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : .5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
            },
            swingFrom: function(pos) {
                var s = 1.70158;
                return pos * pos * ((s + 1) * pos - s);
            },
            swingTo: function(pos) {
                var s = 1.70158;
                return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
            },
            bounce: function(pos) {
                if (pos < 1 / 2.75) {
                    return 7.5625 * pos * pos;
                } else if (pos < 2 / 2.75) {
                    return 7.5625 * (pos -= 1.5 / 2.75) * pos + .75;
                } else if (pos < 2.5 / 2.75) {
                    return 7.5625 * (pos -= 2.25 / 2.75) * pos + .9375;
                } else {
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + .984375;
                }
            },
            bouncePast: function(pos) {
                if (pos < 1 / 2.75) {
                    return 7.5625 * pos * pos;
                } else if (pos < 2 / 2.75) {
                    return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + .75);
                } else if (pos < 2.5 / 2.75) {
                    return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + .9375);
                } else {
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + .984375);
                }
            },
            easeFromTo: function(pos) {
                if ((pos /= .5) < 1) {
                    return .5 * Math.pow(pos, 4);
                }
                return -.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
            },
            easeFrom: function(pos) {
                return Math.pow(pos, 4);
            },
            easeTo: function(pos) {
                return Math.pow(pos, .25);
            }
        });
    })();
    (function() {
        // port of webkit cubic bezier handling by http://www.netzgesta.de/dev/
        function cubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
            var ax = 0, bx = 0, cx = 0, ay = 0, by = 0, cy = 0;
            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx) * t;
            }
            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy) * t;
            }
            function sampleCurveDerivativeX(t) {
                return (3 * ax * t + 2 * bx) * t + cx;
            }
            function solveEpsilon(duration) {
                return 1 / (200 * duration);
            }
            function solve(x, epsilon) {
                return sampleCurveY(solveCurveX(x, epsilon));
            }
            function fabs(n) {
                if (n >= 0) {
                    return n;
                } else {
                    return 0 - n;
                }
            }
            function solveCurveX(x, epsilon) {
                var t0, t1, t2, x2, d2, i;
                for (t2 = x, i = 0; i < 8; i++) {
                    x2 = sampleCurveX(t2) - x;
                    if (fabs(x2) < epsilon) {
                        return t2;
                    }
                    d2 = sampleCurveDerivativeX(t2);
                    if (fabs(d2) < 1e-6) {
                        break;
                    }
                    t2 = t2 - x2 / d2;
                }
                t0 = 0;
                t1 = 1;
                t2 = x;
                if (t2 < t0) {
                    return t0;
                }
                if (t2 > t1) {
                    return t1;
                }
                while (t0 < t1) {
                    x2 = sampleCurveX(t2);
                    if (fabs(x2 - x) < epsilon) {
                        return t2;
                    }
                    if (x > x2) {
                        t0 = t2;
                    } else {
                        t1 = t2;
                    }
                    t2 = (t1 - t0) * .5 + t0;
                }
                return t2;
            }
            cx = 3 * p1x;
            bx = 3 * (p2x - p1x) - cx;
            ax = 1 - cx - bx;
            cy = 3 * p1y;
            by = 3 * (p2y - p1y) - cy;
            ay = 1 - cy - by;
            return solve(t, solveEpsilon(duration));
        }
        /*!
	 *  getCubicBezierTransition(x1, y1, x2, y2) -> Function
	 *
	 *  Generates a transition easing function that is compatible
	 *  with WebKit's CSS transitions `-webkit-transition-timing-function`
	 *  CSS property.
	 *
	 *  The W3C has more information about CSS3 transition timing functions:
	 *  http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
	 *
	 *  @param {number} x1
	 *  @param {number} y1
	 *  @param {number} x2
	 *  @param {number} y2
	 *  @return {function}
	 */
        function getCubicBezierTransition(x1, y1, x2, y2) {
            return function(pos) {
                return cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
            };
        }
        // End ported code
        /**
	 * Create a Bezier easing function and attach it to `{{#crossLink
	 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  This
	 * function gives you total control over the easing curve.  Matthew Lein's
	 * [Ceaser](http://matthewlein.com/ceaser/) is a useful tool for visualizing
	 * the curves you can make with this function.
	 * @method setBezierFunction
	 * @param {string} name The name of the easing curve.  Overwrites the old
	 * easing function on `{{#crossLink
	 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}` if it
	 * exists.
	 * @param {number} x1
	 * @param {number} y1
	 * @param {number} x2
	 * @param {number} y2
	 * @return {function} The easing function that was attached to
	 * Tweenable.prototype.formula.
	 */
        Tweenable.setBezierFunction = function(name, x1, y1, x2, y2) {
            var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
            cubicBezierTransition.displayName = name;
            cubicBezierTransition.x1 = x1;
            cubicBezierTransition.y1 = y1;
            cubicBezierTransition.x2 = x2;
            cubicBezierTransition.y2 = y2;
            return Tweenable.prototype.formula[name] = cubicBezierTransition;
        };
        /**
	 * `delete` an easing function from `{{#crossLink
	 * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  Be
	 * careful with this method, as it `delete`s whatever easing formula matches
	 * `name` (which means you can delete standard Shifty easing functions).
	 * @method unsetBezierFunction
	 * @param {string} name The name of the easing function to delete.
	 * @return {function}
	 */
        Tweenable.unsetBezierFunction = function(name) {
            delete Tweenable.prototype.formula[name];
        };
    })();
    (function() {
        function getInterpolatedValues(from, current, targetState, position, easing, delay) {
            return Tweenable.tweenProps(position, current, from, targetState, 1, delay, easing);
        }
        // Fake a Tweenable and patch some internals.  This approach allows us to
        // skip uneccessary processing and object recreation, cutting down on garbage
        // collection pauses.
        var mockTweenable = new Tweenable();
        mockTweenable._filterArgs = [];
        /**
	 * Compute the midpoint of two Objects.  This method effectively calculates a
	 * specific frame of animation that `{{#crossLink
	 * "Tweenable/tween:method"}}{{/crossLink}}` does many times over the course
	 * of a full tween.
	 *
	 *     var interpolatedValues = Tweenable.interpolate({
	 *       width: '100px',
	 *       opacity: 0,
	 *       color: '#fff'
	 *     }, {
	 *       width: '200px',
	 *       opacity: 1,
	 *       color: '#000'
	 *     }, 0.5);
	 *
	 *     console.log(interpolatedValues);
	 *     // {opacity: 0.5, width: "150px", color: "rgb(127,127,127)"}
	 *
	 * @static
	 * @method interpolate
	 * @param {Object} from The starting values to tween from.
	 * @param {Object} targetState The ending values to tween to.
	 * @param {number} position The normalized position value (between `0.0` and
	 * `1.0`) to interpolate the values between `from` and `to` for.  `from`
	 * represents `0` and `to` represents `1`.
	 * @param {Object.<string|Function>|string|Function} easing The easing
	 * curve(s) to calculate the midpoint against.  You can reference any easing
	 * function attached to `Tweenable.prototype.formula`, or provide the easing
	 * function(s) directly.  If omitted, this defaults to "linear".
	 * @param {number=} opt_delay Optional delay to pad the beginning of the
	 * interpolated tween with.  This increases the range of `position` from (`0`
	 * through `1`) to (`0` through `1 + opt_delay`).  So, a delay of `0.5` would
	 * increase all valid values of `position` to numbers between `0` and `1.5`.
	 * @return {Object}
	 */
        Tweenable.interpolate = function(from, targetState, position, easing, opt_delay) {
            var current = Tweenable.shallowCopy({}, from);
            var delay = opt_delay || 0;
            var easingObject = Tweenable.composeEasingObject(from, easing || "linear");
            mockTweenable.set({});
            // Alias and reuse the _filterArgs array instead of recreating it.
            var filterArgs = mockTweenable._filterArgs;
            filterArgs.length = 0;
            filterArgs[0] = current;
            filterArgs[1] = from;
            filterArgs[2] = targetState;
            filterArgs[3] = easingObject;
            // Any defined value transformation must be applied
            Tweenable.applyFilter(mockTweenable, "tweenCreated");
            Tweenable.applyFilter(mockTweenable, "beforeTween");
            var interpolatedValues = getInterpolatedValues(from, current, targetState, position, easingObject, delay);
            // Transform values back into their original format
            Tweenable.applyFilter(mockTweenable, "afterTween");
            return interpolatedValues;
        };
    })();
    (function(Tweenable) {
        /*!
	 * @typedef {{
	 *   formatString: string
	 *   chunkNames: Array.<string>
	 * }}
	 */
        var formatManifest;
        // CONSTANTS
        var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
        var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
        var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
        var R_RGB = new RegExp("rgb\\(" + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + /,\s*/.source + R_UNFORMATTED_VALUES.source + "\\)", "g");
        var R_RGB_PREFIX = /^.*\(/;
        var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
        var VALUE_PLACEHOLDER = "VAL";
        // HELPERS
        /*!
	 * @param {Array.number} rawValues
	 * @param {string} prefix
	 *
	 * @return {Array.<string>}
	 */
        function getFormatChunksFrom(rawValues, prefix) {
            var accumulator = [];
            var rawValuesLength = rawValues.length;
            var i;
            for (i = 0; i < rawValuesLength; i++) {
                accumulator.push("_" + prefix + "_" + i);
            }
            return accumulator;
        }
        /*!
	 * @param {string} formattedString
	 *
	 * @return {string}
	 */
        function getFormatStringFrom(formattedString) {
            var chunks = formattedString.match(R_FORMAT_CHUNKS);
            if (!chunks) {
                // chunks will be null if there were no tokens to parse in
                // formattedString (for example, if formattedString is '2').  Coerce
                // chunks to be useful here.
                chunks = [ "", "" ];
            } else if (chunks.length === 1 || // ...or if the string starts with a number component (".", "-", or a
            // digit)...
            formattedString[0].match(R_NUMBER_COMPONENT)) {
                // ...prepend an empty string here to make sure that the formatted number
                // is properly replaced by VALUE_PLACEHOLDER
                chunks.unshift("");
            }
            return chunks.join(VALUE_PLACEHOLDER);
        }
        /*!
	 * Convert all hex color values within a string to an rgb string.
	 *
	 * @param {Object} stateObject
	 *
	 * @return {Object} The modified obj
	 */
        function sanitizeObjectForHexProps(stateObject) {
            Tweenable.each(stateObject, function(prop) {
                var currentProp = stateObject[prop];
                if (typeof currentProp === "string" && currentProp.match(R_HEX)) {
                    stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
                }
            });
        }
        /*!
	 * @param {string} str
	 *
	 * @return {string}
	 */
        function sanitizeHexChunksToRGB(str) {
            return filterStringChunks(R_HEX, str, convertHexToRGB);
        }
        /*!
	 * @param {string} hexString
	 *
	 * @return {string}
	 */
        function convertHexToRGB(hexString) {
            var rgbArr = hexToRGBArray(hexString);
            return "rgb(" + rgbArr[0] + "," + rgbArr[1] + "," + rgbArr[2] + ")";
        }
        var hexToRGBArray_returnArray = [];
        /*!
	 * Convert a hexadecimal string to an array with three items, one each for
	 * the red, blue, and green decimal values.
	 *
	 * @param {string} hex A hexadecimal string.
	 *
	 * @returns {Array.<number>} The converted Array of RGB values if `hex` is a
	 * valid string, or an Array of three 0's.
	 */
        function hexToRGBArray(hex) {
            hex = hex.replace(/#/, "");
            // If the string is a shorthand three digit hex notation, normalize it to
            // the standard six digit notation
            if (hex.length === 3) {
                hex = hex.split("");
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
            hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
            hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));
            return hexToRGBArray_returnArray;
        }
        /*!
	 * Convert a base-16 number to base-10.
	 *
	 * @param {Number|String} hex The value to convert
	 *
	 * @returns {Number} The base-10 equivalent of `hex`.
	 */
        function hexToDec(hex) {
            return parseInt(hex, 16);
        }
        /*!
	 * Runs a filter operation on all chunks of a string that match a RegExp
	 *
	 * @param {RegExp} pattern
	 * @param {string} unfilteredString
	 * @param {function(string)} filter
	 *
	 * @return {string}
	 */
        function filterStringChunks(pattern, unfilteredString, filter) {
            var pattenMatches = unfilteredString.match(pattern);
            var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);
            if (pattenMatches) {
                var pattenMatchesLength = pattenMatches.length;
                var currentChunk;
                for (var i = 0; i < pattenMatchesLength; i++) {
                    currentChunk = pattenMatches.shift();
                    filteredString = filteredString.replace(VALUE_PLACEHOLDER, filter(currentChunk));
                }
            }
            return filteredString;
        }
        /*!
	 * Check for floating point values within rgb strings and rounds them.
	 *
	 * @param {string} formattedString
	 *
	 * @return {string}
	 */
        function sanitizeRGBChunks(formattedString) {
            return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
        }
        /*!
	 * @param {string} rgbChunk
	 *
	 * @return {string}
	 */
        function sanitizeRGBChunk(rgbChunk) {
            var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
            var numbersLength = numbers.length;
            var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];
            for (var i = 0; i < numbersLength; i++) {
                sanitizedString += parseInt(numbers[i], 10) + ",";
            }
            sanitizedString = sanitizedString.slice(0, -1) + ")";
            return sanitizedString;
        }
        /*!
	 * @param {Object} stateObject
	 *
	 * @return {Object} An Object of formatManifests that correspond to
	 * the string properties of stateObject
	 */
        function getFormatManifests(stateObject) {
            var manifestAccumulator = {};
            Tweenable.each(stateObject, function(prop) {
                var currentProp = stateObject[prop];
                if (typeof currentProp === "string") {
                    var rawValues = getValuesFrom(currentProp);
                    manifestAccumulator[prop] = {
                        formatString: getFormatStringFrom(currentProp),
                        chunkNames: getFormatChunksFrom(rawValues, prop)
                    };
                }
            });
            return manifestAccumulator;
        }
        /*!
	 * @param {Object} stateObject
	 * @param {Object} formatManifests
	 */
        function expandFormattedProperties(stateObject, formatManifests) {
            Tweenable.each(formatManifests, function(prop) {
                var currentProp = stateObject[prop];
                var rawValues = getValuesFrom(currentProp);
                var rawValuesLength = rawValues.length;
                for (var i = 0; i < rawValuesLength; i++) {
                    stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
                }
                delete stateObject[prop];
            });
        }
        /*!
	 * @param {Object} stateObject
	 * @param {Object} formatManifests
	 */
        function collapseFormattedProperties(stateObject, formatManifests) {
            Tweenable.each(formatManifests, function(prop) {
                var currentProp = stateObject[prop];
                var formatChunks = extractPropertyChunks(stateObject, formatManifests[prop].chunkNames);
                var valuesList = getValuesList(formatChunks, formatManifests[prop].chunkNames);
                currentProp = getFormattedValues(formatManifests[prop].formatString, valuesList);
                stateObject[prop] = sanitizeRGBChunks(currentProp);
            });
        }
        /*!
	 * @param {Object} stateObject
	 * @param {Array.<string>} chunkNames
	 *
	 * @return {Object} The extracted value chunks.
	 */
        function extractPropertyChunks(stateObject, chunkNames) {
            var extractedValues = {};
            var currentChunkName, chunkNamesLength = chunkNames.length;
            for (var i = 0; i < chunkNamesLength; i++) {
                currentChunkName = chunkNames[i];
                extractedValues[currentChunkName] = stateObject[currentChunkName];
                delete stateObject[currentChunkName];
            }
            return extractedValues;
        }
        var getValuesList_accumulator = [];
        /*!
	 * @param {Object} stateObject
	 * @param {Array.<string>} chunkNames
	 *
	 * @return {Array.<number>}
	 */
        function getValuesList(stateObject, chunkNames) {
            getValuesList_accumulator.length = 0;
            var chunkNamesLength = chunkNames.length;
            for (var i = 0; i < chunkNamesLength; i++) {
                getValuesList_accumulator.push(stateObject[chunkNames[i]]);
            }
            return getValuesList_accumulator;
        }
        /*!
	 * @param {string} formatString
	 * @param {Array.<number>} rawValues
	 *
	 * @return {string}
	 */
        function getFormattedValues(formatString, rawValues) {
            var formattedValueString = formatString;
            var rawValuesLength = rawValues.length;
            for (var i = 0; i < rawValuesLength; i++) {
                formattedValueString = formattedValueString.replace(VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
            }
            return formattedValueString;
        }
        /*!
	 * Note: It's the duty of the caller to convert the Array elements of the
	 * return value into numbers.  This is a performance optimization.
	 *
	 * @param {string} formattedString
	 *
	 * @return {Array.<string>|null}
	 */
        function getValuesFrom(formattedString) {
            return formattedString.match(R_UNFORMATTED_VALUES);
        }
        /*!
	 * @param {Object} easingObject
	 * @param {Object} tokenData
	 */
        function expandEasingObject(easingObject, tokenData) {
            Tweenable.each(tokenData, function(prop) {
                var currentProp = tokenData[prop];
                var chunkNames = currentProp.chunkNames;
                var chunkLength = chunkNames.length;
                var easing = easingObject[prop];
                var i;
                if (typeof easing === "string") {
                    var easingChunks = easing.split(" ");
                    var lastEasingChunk = easingChunks[easingChunks.length - 1];
                    for (i = 0; i < chunkLength; i++) {
                        easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
                    }
                } else {
                    for (i = 0; i < chunkLength; i++) {
                        easingObject[chunkNames[i]] = easing;
                    }
                }
                delete easingObject[prop];
            });
        }
        /*!
	 * @param {Object} easingObject
	 * @param {Object} tokenData
	 */
        function collapseEasingObject(easingObject, tokenData) {
            Tweenable.each(tokenData, function(prop) {
                var currentProp = tokenData[prop];
                var chunkNames = currentProp.chunkNames;
                var chunkLength = chunkNames.length;
                var firstEasing = easingObject[chunkNames[0]];
                var typeofEasings = typeof firstEasing;
                if (typeofEasings === "string") {
                    var composedEasingString = "";
                    for (var i = 0; i < chunkLength; i++) {
                        composedEasingString += " " + easingObject[chunkNames[i]];
                        delete easingObject[chunkNames[i]];
                    }
                    easingObject[prop] = composedEasingString.substr(1);
                } else {
                    easingObject[prop] = firstEasing;
                }
            });
        }
        Tweenable.prototype.filter.token = {
            tweenCreated: function(currentState, fromState, toState, easingObject) {
                sanitizeObjectForHexProps(currentState);
                sanitizeObjectForHexProps(fromState);
                sanitizeObjectForHexProps(toState);
                this._tokenData = getFormatManifests(currentState);
            },
            beforeTween: function(currentState, fromState, toState, easingObject) {
                expandEasingObject(easingObject, this._tokenData);
                expandFormattedProperties(currentState, this._tokenData);
                expandFormattedProperties(fromState, this._tokenData);
                expandFormattedProperties(toState, this._tokenData);
            },
            afterTween: function(currentState, fromState, toState, easingObject) {
                collapseFormattedProperties(currentState, this._tokenData);
                collapseFormattedProperties(fromState, this._tokenData);
                collapseFormattedProperties(toState, this._tokenData);
                collapseEasingObject(easingObject, this._tokenData);
            }
        };
    })(Tweenable);
}).call(null);

/*********************

Authors:
	Luis Rodrigues

Description:
	Age Gate class

*********************/
function AgeGateScreen() {
    var self = this, ageGateForm, dayField, monthField, yearField, formValidation = new Validate(), isSubmitting = false;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "age-gate-screen";
    this.name = "Age gate";
    this.templateId = "age-gate-template";
    // added function to set custom button and to be able to get the users data
    function fb_login() {
        FB.login(function(response) {
            if (!response.authResponse) {
                return console.log("User cancelled login or did not fully authorize.");
            }
            FB.api("/me?fields=age_range,first_name,last_name,email", function(response) {
                console.log(response);
                var user_email = response.email, user_firstName = response.first_name, user_lastName = response.last_name, day = 1, month = 1, // Facebook only returns a minimum age, for our purposes this is enough
                // as we don't really care when the user was born, just that they are
                // old enough
                currentYear = new Date().getFullYear(), year = currentYear - response.age_range.min;
                currentUser.set("email", user_email);
                currentUser.set("name", user_firstName + " " + user_lastName);
                dayField.value = day;
                monthField.value = month;
                yearField.value = year;
                validateInputs();
            });
        }, {
            scope: "email,user_birthday"
        });
    }
    // Facebook widget END
    function loadUserDetailsPage() {
        self.scrManager.addScreen(UserDetailsScreen);
    }
    function validateInputs(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        if (isSubmitting) {
            return;
        }
        isSubmitting = true;
        var errorWrapper = document.getElementById("error-overlay"), errorMessage = document.getElementById("dateErrorMessage"), generalDateMessage = "but you must be 18 or over to celebrate National Pia Colada Day with us.";
        if (parseInt(yearField.value, 10) == 1998 && parseInt(monthField.value, 10) == 1 && parseInt(dayField.value, 10) == 1) {
            document.getElementById("birth-month").value = "";
            document.getElementById("birth-day").value = "";
            document.getElementById("birth-day").style.display = "inline";
            document.getElementById("birth-month").style.display = "inline";
            isSubmitting = false;
            return false;
        }
        if (!formValidation.field(dayField).valid || !formValidation.field(monthField).valid || !formValidation.field(yearField).valid) {
            errorMessage.textContent = generalDateMessage;
            errorWrapper.style.display = "block";
            isSubmitting = false;
            return false;
        }
        var minAge = 18, dayVal = dayField.value, monthVal = monthField.value - 1, yearVal = yearField.value, today = new Date(), minBirthDateUnix = new Date(today.getFullYear() - minAge, today.getMonth(), today.getDate() + 1, 12, 0, 0, 0).getTime(), usersBirthday = new Date(yearVal, monthVal, dayVal, 12, 0, 0, 0), usersBirthdayUnix = usersBirthday.getTime();
        if (usersBirthdayUnix - minBirthDateUnix < 0) {
            ga("send", "event", "Age Gate", "Submit", "submit success");
            currentUser.set("birthday", usersBirthday);
            loadUserDetailsPage();
        } else {
            ga("send", "event", "Age Gate", "Submit", "submit fail");
            errorMessage.textContent = generalDateMessage;
            errorWrapper.style.display = "block";
            isSubmitting = false;
            return false;
        }
        return true;
    }
    function limitFieldInput(e) {
        var target = e.target, maxLength = target.getAttribute("maxlength");
        if (maxLength && target.value.length >= maxLength) {
            e.preventDefault();
            return false;
        }
        return true;
    }
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    function validateFieldInput(e) {
        var key = e.keyCode, field = e.target, nextSibling = field.nextElementSibling, maxLength = field.getAttribute("maxlength");
        if ((e.charCode < 48 || e.charCode > 57 || field.value.length >= parseInt(maxLength, 10)) && key !== 8 && key !== 13 && key !== 9) {
            return false;
        }
        if (key === 8) {
            return true;
        }
        if (field.value.length >= maxLength - 1) {
            if (nextSibling && nextSibling.tagName.toLowerCase() === "input") {
                setTimeout(function() {
                    nextSibling.focus();
                }, 10);
            } else {
                setTimeout(function() {
                    field.blur();
                }, 10);
            }
        }
    }
    function validateFieldInputYear(e) {
        var yearField = document.getElementById("birth-year").value;
        var monthField = document.getElementById("birth-month").value;
        var dayField = document.getElementById("birth-day").value;
        if (parseInt(yearField, 10) == 1998 && parseInt(monthField, 10) == 0 && parseInt(dayField, 10) == 0) {
            document.getElementById("birth-month").value = "";
            document.getElementById("birth-day").value = "";
            document.getElementById("birth-day").style.display = "inline";
            document.getElementById("birth-month").style.display = "inline";
            e.preventDefault();
            return false;
        }
        return true;
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        dayField = document.getElementById("birth-day");
        monthField = document.getElementById("birth-month");
        yearField = document.getElementById("birth-year");
        ageGateForm = document.getElementById("age-validation-form");
        ageGateForm.addEventListener("submit", validateInputs);
        ageGateForm.addEventListener("keypress", validateFieldInput);
        ageGateForm.addEventListener("keypress", limitFieldInput);
        ageGateForm.addEventListener("keyup", validateFieldInputYear);
        document.getElementById("facebook-login-button").addEventListener("click", fb_login);
        document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        return this.container;
    };
}

AgeGateScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Voucher page class

*********************/
function BarsListScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "bars-list-screen";
    this.name = "Bars list page";
    this.templateId = "bars-list-template";
    function showBarsMap() {
        // console.log('Will change page and switch to map view');
        self.scrManager.addScreen(MapPageScreen);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        document.getElementById("show-map").addEventListener("click", showBarsMap);
        return this.container;
    };
}

BarsListScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	CommingSoonScreen over class

*********************/
function CommingSoonScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "comming-soon-screen";
    this.name = "CommingSoon";
    this.templateId = "comming-soon-template";
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        return this.container;
    };
}

CommingSoonScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Home page class

*********************/
function HomePageScreen() {
    var self = this, //var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    startDate = new Date(2016, 6, 8, 12, 0, 0, 0), now = new Date(), voucherCTA, checkDate;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "home-page-screen";
    this.name = "Home page";
    this.templateId = "home-page-template";
    function loadMapPage(e) {
        e.preventDefault();
        self.scrManager.addScreen(MapPageScreen);
        ga("send", "event", "Find a bar", "click", "click initial button");
    }
    function loadEnterVoucherPage(e) {
        e.preventDefault();
        if (now >= startDate) {
            ga("send", "event", "Voucher", "click", "click initial button");
            self.scrManager.addScreen(VoucherPageScreen);
        } else {
            // self.scrManager.addScreen(VoucherPageScreen);
            var errorWrapper = document.getElementById("error-overlay"), errorMessage = document.getElementById("dateErrorMessage"), voucherError = "Youre keen! Its not quite time to enjoy a Pia Colada just yet though, youll have to wait until midday on the 8th, 9th and 10th of July.";
            errorMessage.textContent = voucherError;
            errorWrapper.style.display = "block";
        }
    }
    function updateVoucherStatus() {
        if (now >= startDate) {
            clearInterval(checkDate);
            voucherCTA.style.opacity = "";
        } else {
            return;
        }
    }
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        document.getElementById("find-a-bar-btn").addEventListener("click", loadMapPage);
        document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        voucherCTA = document.getElementById("voucher-cta");
        if (now < startDate) {
            voucherCTA.style.opacity = "0.5";
            checkDate = setInterval(updateVoucherStatus, 5e3);
        }
        voucherCTA.addEventListener("click", loadEnterVoucherPage);
        // var calendarCTA = document.getElementById("calendarCTA"),
        // 	ua = navigator.userAgent.toLowerCase(),
        // 	isAndroid = ua.indexOf("android") > -1;
        // if(ua.indexOf('ios') >= 0 || ua.indexOf('os x') >= 0 || ua.indexOf('macintosh') >= 0) {
        // 	calendarCTA.href = "/calendar/mnpcd.ics";
        // 	calendarCTA.addEventListener('click', function() {
        // 		ga('send', 'event', 'Calendar', 'click');
        // 	});
        // } else {
        //calendarCTA.style.display = "none";
        //}
        return this.container;
    };
}

HomePageScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Location over class

*********************/
function LocationScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "location-screen";
    this.name = "Location";
    this.templateId = "location-template";
    function loadAgeGatePage(e) {
        e.preventDefault();
        self.scrManager.addScreen(AgeGateScreen);
    }
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        document.getElementById("register-anyway-btn").addEventListener("click", loadAgeGatePage);
        document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        return this.container;
    };
}

LocationScreen.prototype = new Screen();

/*********************

Authors:
	Dan Dvoracek
	Luis Rodrigues

Description:
	Map page class

*********************/
function MapPageScreen() {
    var self = this, listWrap, barList, map, geoCoder, minZoomLevel = 6, mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(49.378087, (-8.906589)), new google.maps.LatLng(56.039487, 2.730992)), barBounds, userLocation, mapCenterLocation, mapMarkers = [], barListItemTemplate = "", listedBars = [], activeBar, directionsService, directionsDisplay, errorMessage = document.getElementById("dateErrorMessage"), errorWrapper = document.getElementById("error-overlay"), isReceivingData = false, userSearch = "";
    barListItemTemplate += '<h2 class="bar-name" data-bar="{{ index }}">{{ name }}</h2>';
    barListItemTemplate += "{{#directionsEnabled}}";
    barListItemTemplate += '<div class="bar-more-info">';
    barListItemTemplate += '<span class="distance">{{ distance }}</span>';
    barListItemTemplate += '<span class="getDirectionsArrow" data-bar="{{ index }}"></span>';
    barListItemTemplate += "</div>";
    barListItemTemplate += "{{/directionsEnabled}}";
    barListItemTemplate += "<address>{{ address }}</address>";
    barListItemTemplate += '<p class="phoneNumber" >{{ phoneLabel }} <a href="tel:{{ phoneClean }}" title="Call the bar!">{{ phone }}</a></p>';
    barListItemTemplate += '<div class="clearfix"></div>';
    barListItemTemplate += '<div class="dots-border"></div>';
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "map-page-screen";
    this.name = "Map page";
    this.templateId = "map-page-template";
    this.root = false;
    if (localStorage && localStorage.getItem("usersLocation")) {
        var userCoordinates = JSON.parse(localStorage.getItem("usersLocation"));
        userLocation = new google.maps.LatLng(userCoordinates[0], userCoordinates[1]);
    }
    // Close that same popup...
    function hideBarDetails(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        if (directionsDisplay) {
            directionsDisplay.setMap(null);
        }
        var barInfoOverlay = document.getElementById("bar-details-overlay");
        barInfoOverlay.style.display = "none";
    }
    // Show the bar list on map-page; different behavior depending on if the user enabled geolocation or not
    function showBarsList(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
            ga("send", "event", "Find a bar", "click", "List");
        }
        var filtersMap = document.getElementById("show-map"), filtersList = document.getElementById("show-list"), listOverlay = self.container.querySelector(".bars-list-view"), listWrap = document.getElementById("bars-list-wrap");
        listOverlay.style.display = "block";
        hideBarDetails();
        if (filtersMap.className.indexOf("map-filter-active") >= 0) {
            filtersMap.className = "";
            filtersList.className = "map-filter-active";
        }
    }
    // Hide bar list when switch to map view
    function hideBarsList(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
            ga("send", "event", "Find a bar", "click", "Map");
        }
        var listOverlay = self.container.querySelector(".bars-list-view"), filtersMap = document.getElementById("show-map"), filtersList = document.getElementById("show-list");
        if (filtersList.className.indexOf("map-filter-active") >= 0) {
            filtersList.className = "";
            filtersMap.className = "map-filter-active";
        }
        listOverlay.style.display = "none";
    }
    //Prevent zooming out the map too much
    function restrictMapZoom() {
        if (map.getZoom() < minZoomLevel) {
            map.setZoom(minZoomLevel);
        }
    }
    //Prevent panning the map to other countries
    function restrictMapCenter() {
        var center = map.getCenter(), x, y, maxX, maxY, minX, minY;
        if (!mapBounds.contains(center)) {
            x = center.lng(), y = center.lat(), maxX = mapBounds.getNorthEast().lng(), maxY = mapBounds.getNorthEast().lat(), 
            minX = mapBounds.getSouthWest().lng(), minY = mapBounds.getSouthWest().lat();
            if (x < minX) {
                x = minX;
            } else if (x > maxX) {
                x = maxX;
            }
            if (y < minY) {
                y = minY;
            } else if (y > maxY) {
                y = maxY;
            }
            map.setCenter(new google.maps.LatLng(y, x));
        }
    }
    function getDirectionsToBar(e, barData) {
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        ga("send", "event", "Find a bar", "Search", "get directions");
        barData = barData || activeBar;
        var request = {
            origin: userLocation || mapCenterLocation,
            destination: new google.maps.LatLng(barData.latitude, barData.longitude),
            travelMode: google.maps.TravelMode.DRIVING
        };
        hideBarDetails();
        directionsDisplay.setMap(map);
        directionsService.route(request, function(result, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(result);
            } else {
                errorMessage.textContent = "It was not possible to get directions from the location provided.";
                errorWrapper.style.display = "block";
            }
        });
    }
    function showBarDetails(barData) {
        if (!barData) {
            ga("send", "event", "Find a bar", "Search", "select bar");
        }
        if (barData && barData.latLng) {
            barData = false;
        }
        var barMarker = this, barData = barData || barMarker.get("barData"), nameField = document.getElementById("barName"), addressField = document.getElementById("barAddress"), phoneNumField = document.getElementById("barPhoneNum"), barInfoOverlay = document.getElementById("bar-details-overlay"), barPostcode = document.getElementById("barPostcode"), distance = document.getElementById("barDistance"), distanceOrigin = userLocation || mapCenterLocation || false, distanceToBar;
        if (distanceOrigin) {
            distanceToBar = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(barData.latitude, barData.longitude), distanceOrigin);
            distanceToBar = (distanceToBar * .000621371192).toFixed(2) + " miles";
        }
        barInfoOverlay.style.display = "block";
        nameField.textContent = barData.name1 + (barData.name2 ? " " + barData.name2 : "");
        addressField.textContent = barData.address1 + (barData.address2 ? "\n" + barData.address2 : "") + (barData.address3 ? "\n" + barData.address3 : "") + (barData.address4 ? "\n" + barData.address4 : "");
        barPostcode.textContent = barData.postcode;
        distance.textContent = "goto";
        // distanceToBar ? distanceToBar : '';
        if (barData.phone) {
            phoneNumField.innerHTML = barData.phone;
            phoneNumField.href = "tel:" + barData.phone.replace(/ /g, "");
            phoneNumField.parentNode.style.display = "block";
        } else {
            phoneNumField.parentNode.style.display = "none";
        }
        activeBar = barData;
    }
    function addBarMarker(barData) {
        barData = barData.attributes;
        var barCoordinates = new google.maps.LatLng(barData.latitude, barData.longitude), barMarker = new google.maps.Marker({
            position: barCoordinates,
            map: map,
            icon: "assets/img/pin.png",
            title: barData.name1 + (barData.name2 ? " " + barData.name2 : "")
        });
        barMarker.set("barData", barData);
        google.maps.event.addListener(barMarker, "click", showBarDetails);
        mapMarkers.push(barMarker);
        barBounds.extend(barCoordinates);
    }
    function addBarMarkerNonSelected(barData) {
        var barCoordinates = new google.maps.LatLng(barData.latitude, barData.longitude), barMarker = new google.maps.Marker({
            position: barCoordinates,
            map: map,
            icon: "assets/img/pin.png",
            title: barData.name1 + (barData.name2 ? " " + barData.name2 : "")
        });
        barMarker.set("barData", barData);
        google.maps.event.addListener(barMarker, "click", showBarDetails);
        mapMarkers.push(barMarker);
        barBounds.extend(barCoordinates);
    }
    function addBarMarkerSelected(barData) {
        var barCoordinates = new google.maps.LatLng(barData.latitude, barData.longitude), barMarker = new google.maps.Marker({
            position: barCoordinates,
            map: map,
            icon: "assets/img/pin-user.png",
            title: barData.name1 + (barData.name2 ? " " + barData.name2 : "")
        });
        barMarker.set("barData", barData);
        google.maps.event.addListener(barMarker, "click", showBarDetails);
        mapMarkers.push(barMarker);
        barBounds.extend(barCoordinates);
    }
    function addOneBarMarker(barData) {
        //var tmp=mapMarkers;
        //removeBarPins();
        _.each(mapMarkers, function(item) {
            if (item.barData.num_id == barData.num_id) {
                item.setMap(null);
                addBarMarkerSelected(item.barData);
            } else {
                if (item.barData.latitude !== undefined) {
                    item.setMap(null);
                    addBarMarkerNonSelected(item.barData);
                }
            }
        });
        var barCoordinates = new google.maps.LatLng(barData.latitude, barData.longitude);
        barBounds.extend(barCoordinates);
        map.setCenter(barCoordinates);
        map.setZoom(14);
    }
    function renderBarListItem(barData, index) {
        barData = barData.attributes;
        var template, barItemData, distanceOrigin = userLocation || mapCenterLocation || false, distanceToBar;
        if (distanceOrigin) {
            distanceToBar = google.maps.geometry.spherical.computeDistanceBetween(new google.maps.LatLng(barData.latitude, barData.longitude), distanceOrigin);
            distanceToBar = (distanceToBar * .000621371192).toFixed(2) + " miles";
        }
        barItemData = {
            name: barData.name1 + (barData.name2 ? " " + barData.name2 : ""),
            distance: distanceToBar,
            address: barData.address1 + (barData.address2 ? "\n" + barData.address2 : "") + (barData.address3 ? "\n" + barData.address3 : "") + (barData.address4 ? "\n" + barData.address4 : "") + (barData.postcode ? "\n" + barData.postcode : ""),
            phone: barData.phone,
            phoneLabel: barData.phone ? "Tel." : "",
            phoneClean: barData.phone ? barData.phone.replace(/ /g, "") : false,
            directionsEnabled: !distanceToBar || self.screenData.standalone ? false : true,
            index: index
        };
        return Mustache.render(barListItemTemplate, barItemData);
    }
    function removeBarPins() {
        var i;
        for (i = 0; i < mapMarkers.length; i++) {
            mapMarkers[i].setMap(null);
        }
    }
    function populateBars(barData) {
        //console.log(barData.length);
        if (barData.length > 0) {
            var i, output = "";
            listedBars = barData;
            barBounds = new google.maps.LatLngBounds();
            //Only deal with map markers if not showing the standalone bar list
            if (!self.screenData.standalone) {
                removeBarPins();
                mapMarkers = [];
                for (i = 0; i < barData.length; i++) {
                    addBarMarker(barData[i]);
                }
            }
            for (i = 0; i < barData.length; i++) {
                output += renderBarListItem(barData[i], i);
            }
            if (map && barBounds) {
                map.fitBounds(barBounds);
            }
            barList.innerHTML = output;
            isReceivingData = false;
        } else {
            showNoResults();
        }
    }
    function getAllNearestToMapCenter() {
        if (!mapCenterLocation) {
            return;
        }
        // //No bars should be displayed with no user location or addres searched
        // if (!userSearch && !userLocation) {
        // 	isReceivingData = false;
        // 	return removeBarPins();
        // }
        isReceivingData = true;
        var BarsList = Parse.Object.extend("Bars"), query = new Parse.Query(BarsList), parseGeopoint = new Parse.GeoPoint(51.50618, (-.12978));
        //london
        // if (!self.screenData.standalone) {
        // 	query.limit(25);
        // } else {
        // 	query.limit(1000);
        // }
        query.limit(850);
        query.near("geopoints", parseGeopoint);
        query.find().then(populateBars);
    }
    function getNearestToMapCenter2(addres) {
        //console.log(addres);
        if (addres.length == 0) {
            document.getElementById("list-search").innerHTML = "";
            document.getElementById("list-search").style.border = "0px";
            return;
        } else {
            document.getElementById("results-search").innerHTML = "";
            isReceivingData = true;
            var BarsList = Parse.Object.extend("Bars"), query = new Parse.Query(BarsList);
            query.matches("address2", addres, "i");
            query.limit(850);
            query.find().then(populateBars);
        }
    }
    function initMap() {
        var defaultZoom = 10;
        mapCenterLocation = userLocation || mapBounds.getCenter();
        map = new google.maps.Map(document.getElementById("map-canvas"), {
            center: mapCenterLocation,
            zoom: defaultZoom,
            disableDefaultUI: true
        });
        directionsService = new google.maps.DirectionsService();
        directionsDisplay = new google.maps.DirectionsRenderer({
            suppressMarkers: true
        });
        geoCoder = new google.maps.Geocoder();
        if (userLocation) {
            new google.maps.Marker({
                position: userLocation,
                map: map,
                icon: "assets/img/pin-user.png"
            });
        }
        //Prevent zooming out too much
        google.maps.event.addListener(map, "zoom_changed", restrictMapZoom);
        //Prevent panning to other countries
        google.maps.event.addListener(map, "center_changed", restrictMapCenter);
    }
    function showNoResults() {
        errorMessage.textContent = "No bars were found near the location provided.";
        errorWrapper.style.display = "block";
        isReceivingData = false;
    }
    function showErrors() {
        errorMessage.textContent = "GPS Error.";
        errorWrapper.style.display = "block";
        isReceivingData = false;
    }
    function showRestrictedResults() {
        errorMessage.textContent = "You are restricted search from out of UK.";
        errorWrapper.style.display = "block";
        isReceivingData = false;
    }
    function searchNearAddress(address) {
        isReceivingData = true;
        getNearestToMapCenter2(address);
    }
    function getDirectionsFromList(e) {
        if (e.target.className === "bar-name" || e.target.className === "getDirectionsArrow") {
            e.preventDefault();
            activeBar = listedBars[e.target.getAttribute("data-bar")];
            activeBar = activeBar.attributes;
            //console.log(activeBar);
            ga("send", "event", "Bar selected", activeBar.name1, activeBar.name1);
            hideBarsList();
            //removeBarPins();
            //console.log(activeBar);
            addOneBarMarker(activeBar);
        }
    }
    function resetSearch() {
        if (userLocation) {
            mapCenterLocation = userLocation;
        }
        map.setCenter(mapCenterLocation);
    }
    function searchFromList(e) {
        e.preventDefault();
        if (isReceivingData) {
            return;
        }
        isReceivingData = true;
        var listSearchField = document.getElementById("list-search");
        //,mapSearchField = document.getElementById('map-search');
        //mapSearchField.value = listSearchField.value.trim();
        userSearch = listSearchField.value.trim();
        ga("send", "event", "Find a bar", "Search", userSearch);
        if (userSearch) {
            getNearestToMapCenter2(userSearch);
        } else {}
    }
    // function searchFromMap(e) {
    // 	e.preventDefault();
    // 	if (isReceivingData) {
    // 		return;
    // 	}
    // 	isReceivingData = true;
    // 	var listSearchField = document.getElementById('list-search'),
    // 		mapSearchField = document.getElementById('map-search');
    // 	listSearchField.value = mapSearchField.value.trim();
    // 	userSearch = listSearchField.value;
    // 	ga('send', 'event', 'Find a bar', 'Search', listSearchField.value);
    // 	if (listSearchField.value) {
    // 		getNearestToMapCenter2(mapSearchField.value);
    // 	} else {
    // 		resetSearch();
    // 	}
    // }
    function LoadCityBox(e) {
        e.preventDefault();
        var searchedCtrl = document.getElementById("list-search");
        var searchedText = searchedCtrl.value.trim();
        var results = document.getElementById("results-search");
        //console.log(searchedText);
        if (searchedText == "") {
            results.style.border = "0px";
            results.innerHTML = "";
            return;
        } else {
            var BarsList = Parse.Object.extend("Bars"), query = new Parse.Query(BarsList);
            query.matches("address2", searchedText, "i");
            query.select("address2");
            //query.limit(10);
            query.find().then(function(Things) {
                var addArray = [];
                for (var i = Things.length - 1; i >= 0; i--) {
                    addArray.push(Things[i].get("address2"));
                }
                var bars = _.uniq(addArray);
                results.innerHTML = "";
                $.each(bars, function(i, item) {
                    //addArray.push(item.get('address2'));
                    results.innerHTML += "<div>" + item + "</div>";
                });
            });
        }
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        var backBtn = document.getElementById("backBtn"), getDirectionsBtn;
        listWrap = this.container.querySelector(".bar-list-wrapper");
        barList = document.getElementById("bars-list-wrap");
        if (this.screenData.standalone) {
            mapCenterLocation = userLocation || mapBounds.getCenter();
            showBarsList();
            this.container.className += " standalone-version";
            listWrap.style.paddingTop = "60px";
            backBtn.parentNode.removeChild(backBtn);
        } else {
            this.container.className += " full-version";
            document.getElementById("show-list").addEventListener("click", showBarsList);
            document.getElementById("show-map").addEventListener("click", hideBarsList);
            document.getElementById("closeBtn").addEventListener("click", hideBarDetails);
            //document.getElementById('list-search').addEventListener("keyup", LoadCityBox);
            document.getElementById("barsByPostcode").addEventListener("click", searchFromList);
            //document.getElementById('getDirections').addEventListener("click", getDirectionsToBar);
            backBtn.addEventListener("click", self.scrManager.goBack);
            listWrap.addEventListener("click", getDirectionsFromList);
            initMap();
        }
        getAllNearestToMapCenter();
        return this.container;
    };
}

MapPageScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Voucher page class

*********************/
function PrivacyPolicyScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "privacy-policy-screen";
    this.name = "Privacy Policy page";
    this.templateId = "privacy-policy-template";
    this.root = false;
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        ga("send", "event", "Privacy Policy", "Viewed");
        var backBtn = document.getElementById("backBtn");
        if (this.screenData.standalone) {
            backBtn.parentNode.removeChild(backBtn);
        } else {
            backBtn.addEventListener("click", self.scrManager.goBack);
        }
        return this.container;
    };
}

ThankYouScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Promotion over class

*********************/
function PromotionOverScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "promotion-over-screen";
    this.name = "Promotion over";
    this.templateId = "promotion-over-template";
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        return this.container;
    };
}

PromotionOverScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Base screen class

*********************/
function Screen(scrManager, events, screenData, forceRoot) {
    //Screen properties
    this.id = "screenId";
    this.name = "Base screen";
    this.template = "";
    this.templateId = false;
    this.templateUrl = false;
    this.templateData = {};
    this.container = null;
    this.transition = "slideLeft";
    this.root = true;
    if (forceRoot) {
        this.forceRoot = true;
    } else {
        this.forceRoot = false;
    }
    this.templateRequest;
    this.scrManager = scrManager;
    this.events = events;
    this.screenData = screenData || {};
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        return this.container;
    };
    //Create the screen container element
    this.createContainer = function(template) {
        var scrollableArea;
        this.container = document.createElement("div");
        this.container.className = "screen " + this.id;
        this.container.style.visibility = "hidden";
        scrollableArea = document.createElement("div");
        scrollableArea.className = "scrollable";
        scrollableArea.innerHTML = template;
        this.container.appendChild(scrollableArea);
        //Add the screen to the app container
        this.scrManager.container.appendChild(this.container);
        this.processContainer();
    };
    this.populateTemplate = function() {
        return Mustache.render(this.template, this.templateData);
    };
    //Check if the screen is ready and do all required actions before the screen is displayed
    this.isReady = function() {
        if (!this.template) {
            return false;
        }
        var tplRender = this.populateTemplate();
        this.createContainer(tplRender);
        return true;
    };
    //Notify that the template is ready and check if all the requirements are met
    this.templateReady = function() {
        this.isReady();
    };
    //Process the template loaded from a URL
    this.templateUrlLoaded = function(e) {
        var target = e.target;
        if (target.readyState !== 4) {
            return;
        }
        if (target.status >= 200 && target.status < 400) {
            this.template = target.responseText;
            this.templateReady();
        }
        return;
    };
    //Load the template from the inner HTML of a DOM element
    this.loadTemplateFromDOM = function(templateId) {
        var templateContainer = document.getElementById(templateId);
        if (!templateContainer) {
            console.error('Template container with ID "' + templateId + '" not found.');
            return "";
        }
        this.template = templateContainer.innerHTML;
        this.templateReady();
        return this.template;
    };
    //Load the template from a given URL through AJAX
    this.loadTemplateFromUrl = function(templateUrl) {
        var self = this;
        this.templateRequest = new XMLHttpRequest();
        this.templateRequest.onreadystatechange = function(e) {
            self.templateUrlLoaded.call(self, e);
        };
        this.templateRequest.open("GET", templateUrl);
        this.templateRequest.send();
    };
    //Get the screen template
    this.loadTemplate = function() {
        if (this.template) {
            this.templateReady();
            return;
        }
        if (this.templateId) {
            this.loadTemplateFromDOM(this.templateId);
            return;
        }
        if (this.templateUrl) {
            this.loadTemplateFromUrl(this.templateUrl);
            return;
        }
    };
    //Destroy the screen
    this.destroy = function() {
        if (this.templateRequest) {
            this.templateRequest.abort();
        }
        if (this.container) {
            this.container.parentNode.removeChild(this.container);
            this.container = null;
        }
    };
    //Prepare the screen
    this.init = function() {
        this.loadTemplate();
    };
}

/*********************

Authors:
	Luis Rodrigues

Description:
	Start screen class

*********************/
function StartScreen() {
    var self = this, endDate = new Date(2016, 6, 12, 0, 0, 0, 0), now = new Date(), contentLoadedCheck, cssLoaded = false, greenBackground, whiteBackground, headerBackground, progressContainer, loggedIn = false, sessionExpired = false, isAllow = false, geoCoder = new google.maps.Geocoder(), errorMessage = document.getElementById("dateErrorMessage"), errorWrapper = document.getElementById("error-overlay"), isReceivingData = false;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "start-screen";
    this.name = "Loading";
    this.templateId = "start-template";
    this.transition = false;
    // CACHE geolocation -- I suppose it's a good thing to do it here as later it takes way too much time...(on the map page)
    function getUserLocation() {
        // sayswho= (function(){
        //    var N= navigator.appName, ua= navigator.userAgent, tem;
        //    var M= ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
        //    if(M && (tem= ua.match(/version\/([\.\d]+)/i))!= null) M[2]= tem[1];
        //    M= M? [M[1], M[2]]: [N, navigator.appVersion,'-?'];
        //    return M;
        // });
        // var nAgt = sayswho();
        //if(location.protocol=="https")
        // if ((verOffset=nAgt.indexOf("Safari"))!=-1) { 61.039487, 2.730992
        window.UsersLat = 61.039487;
        window.UsersLng = 2.730992;
        window.UsersLatLng = [ window.UsersLat, window.UsersLng ];
        localStorage.setItem("usersLocation", window.UsersLatLng);
        console.log("Safari");
        isAllow = true;
        showRestrictedResults(isAllow);
    }
    function showRestrictedResults(isAllow) {
        //errorMessage.textContent = 'You are restricted search from '+uk_only;
        //errorWrapper.style.display = 'block';
        //localStorage.setItem("uk_only", false);
        //isReceivingData = false;
        //return self.scrManager.addScreen(UserDetailsScreen);
        isAllow = true;
        var isExternal = window.location.hash;
        if (isExternal == "#/requestFrom/fb") {
            return self.scrManager.addScreen(UserDetailsScreen);
        } else if (isExternal == "#/login") {
            return self.scrManager.addScreen(UserDetailsScreen);
        } else if (isExternal == "#/bars") {
            return self.scrManager.addScreen(MapPageScreen);
        } else if (isExternal == "#/voucher") {
            return self.scrManager.addScreen(HomePageScreen);
        } else if (isAllow) {
            return self.scrManager.addScreen(AgeGateScreen);
        } else {
            return self.scrManager.addScreen(LocationScreen);
        }
    }
    function callbackPosition(position) {
        localStorage.setItem("uk_only", true);
        //console.log(position);
        var latitude = position.coords.latitude, longitude = position.coords.longitude;
        var latlng = {
            lat: parseFloat(latitude),
            lng: parseFloat(longitude)
        };
        if (navigator.geolocation) {
            geoCoder.geocode({
                location: latlng
            }, function(results, status) {
                if (status === google.maps.GeocoderStatus.OK) {
                    console.log(results);
                    var addr = results[0].address_components;
                    var add_length = addr.length;
                    for (var i = addr.length - 1; i >= 0; i--) {
                        var uk_only = addr[i].short_name;
                        console.log(uk_only);
                        if (uk_only == "England" || uk_only == "Wales" || uk_only == "GB") {
                            isAllow = true;
                        }
                    }
                    //isAllow = true;
                    showRestrictedResults(isAllow);
                    console.log(isAllow);
                } else {
                    isAllow = true;
                    showRestrictedResults(isAllow);
                }
            });
        } else {
            window.alert("Geocoder failed due to: " + status);
        }
        window.UsersLat = latitude;
        window.UsersLng = longitude;
        window.UsersLatLng = [ latitude, longitude ];
        localStorage.setItem("usersLocation", JSON.stringify(UsersLatLng));
    }
    function errorPositionCallBack() {}
    function updateProgress(loaded, total) {}
    function checkLoadedAssets() {
        var loadedAssets = 1, totalAssets = 7;
        if (currentUser) {
            totalAssets = 8;
        }
        if (currentUser && loggedIn) {
            loadedAssets += 1;
        }
        //Check if Facebook SDK is loaded
        //Only needed if a user is not logged in
        if (typeof FB !== "undefined") {
            loadedAssets += 1;
        }
        //Check if Google Maps is loaded
        if (typeof google !== "undefined" && typeof google.maps !== "undefined") {
            loadedAssets += 1;
        }
        //Check if the CSS is loaded
        if (cssLoaded) {
            loadedAssets += 1;
        }
        //Check if the green background is loaded
        if (greenBackground.complete) {
            loadedAssets += 1;
        }
        //Check if the white background is loaded
        if (whiteBackground.complete) {
            loadedAssets += 1;
        }
        //Check if the header background is loaded
        if (headerBackground.complete) {
            loadedAssets += 1;
        }
        progressContainer.style.width = Math.round(loadedAssets / totalAssets * 100) + "%";
        if (loadedAssets < totalAssets) {
            return false;
        }
        clearInterval(contentLoadedCheck);
        self.routeUser();
    }
    self.routeUser = function() {
        //alert(startDate);
        if (false) //now < startDate)
        {
            return self.scrManager.addScreen(CommingSoonScreen, {
                standalone: true
            }, true);
        }
        if (now >= endDate) {
            return self.scrManager.addScreen(PromotionOverScreen, {
                standalone: true
            }, true);
        }
        if (window.location.pathname === "/bars") {
            return self.scrManager.addScreen(MapPageScreen, {
                standalone: true
            }, true);
        }
        if (window.location.pathname === "/privacy-policy") {
            return self.scrManager.addScreen(PrivacyPolicyScreen, {
                standalone: true
            }, true);
        }
        if (loggedIn && !sessionExpired && currentUser.attributes.drinkRedeemed) {
            return self.scrManager.addScreen(ThankYouScreen);
        } else if (loggedIn && !sessionExpired) {
            return self.scrManager.addScreen(HomePageScreen);
        } else {
            currentUser = new Parse.User();
            getUserLocation();
        }
    };
    //Do post container creation processing
    self.processContainer = function() {
        currentUser = Parse.User.current();
        if (currentUser) {
            Parse.User.logIn(currentUser.attributes.email, currentUser.attributes.name, {
                success: function(user) {
                    currentUser = user;
                    loggedIn = true;
                    sessionExpired = false;
                },
                error: function(user, error) {
                    Parse.User.logOut();
                    loggedIn = true;
                    sessionExpired = true;
                    console.warn(user, error);
                }
            });
        }
        self.events.publish(self.id + "ContainerReady", self);
        progressContainer = document.getElementById("progress-container");
        progressContainer.style.width = "0%";
        //getUserLocation();
        greenBackground = new Image();
        greenBackground.src = "/assets/img/backgrounds/mobile-footer-wrap-bg.png";
        whiteBackground = new Image();
        whiteBackground.src = "/assets/img/backgrounds/mobile-body-bg.png";
        headerBackground = new Image();
        headerBackground.src = "/assets/img/backgrounds/mobile-header-bg.png";
        self.cssRequest = new XMLHttpRequest();
        self.cssRequest.onreadystatechange = function(e) {
            self.processLoadedCSS.call(self, e);
        };
        self.cssRequest.open("GET", "/assets/css/main.css");
        self.cssRequest.send();
        contentLoadedCheck = setInterval(checkLoadedAssets, 100);
        return self.container;
    };
    self.processLoadedCSS = function(e) {
        var target = e.target;
        if (target.readyState !== 4) {
            return;
        }
        if (target.status >= 200 && target.status < 400) {
            document.getElementById("mainStylesheet").innerHTML = target.responseText;
            cssLoaded = true;
        }
        return;
    };
}

StartScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Voucher page class

*********************/
function ThankYouScreen() {
    var self = this;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    var subscribeSection, subscribeBtn;
    this.id = "thank-you-screen";
    this.name = "Thank you page";
    this.templateId = "thank-you-template";
    this.templateData = {
        userName: currentUser.attributes.name,
        userSubscribedNewsletter: currentUser.attributes.receiveEmails
    };
    function loadPrivacyPolicy(e) {
        e.preventDefault();
        self.scrManager.addScreen(PrivacyPolicyScreen);
    }
    this.subscribeNewsletter = function(e) {
        currentUser.set("receiveEmails", true);
        currentUser.save();
        signUpNewsletter();
        subscribeSection.innerHTML = "<p>Thank you!</p>";
    };
    //Do post container creation processing
    this.processContainer = function() {
        subscribeSection = document.getElementById("newsletter-signup-section");
        if (subscribeSection) {
            subscribeBtn = subscribeSection.querySelector("#subscribe-newsletter-btn");
            subscribeBtn.addEventListener("click", this.subscribeNewsletter);
        }
        this.events.publish(this.id + "ContainerReady", this);
        //document.getElementById("privacy-policy-link").addEventListener("click", loadPrivacyPolicy);
        return this.container;
    };
}

ThankYouScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Voucher page class

*********************/
function UserDetailsScreen() {
    var self = this, detailsForm, fullName, email, postcode, termsAndCond, newsletterSignup, validator = new Validate(), isSubmitting = false;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "user-details-screen";
    this.name = "User details page";
    this.templateId = "user-details-template";
    function loadHomePage() {
        self.scrManager.addScreen(HomePageScreen);
    }
    function validateFields(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        if (isSubmitting) {
            return;
        }
        isSubmitting = true;
        var errorCount = 0, nameError = document.getElementById("nameError"), emailError = document.getElementById("emailError"), postcodeError = document.getElementById("postcodeError"), generalError = document.getElementById("generalError"), nameValidation = validator.field(fullName), emailValidation = validator.field(email), postcodeValidation = validator.field(postcode), fullNameStr = fullName.value.toLowerCase().trim(), emailStr = email.value.toLowerCase().trim();
        fullNameStr = latinize(fullNameStr);
        emailStr = latinize(emailStr);
        if (nameValidation.valid) {
            nameError.innerHTML = "";
        } else {
            errorCount = errorCount + 1;
            nameError.textContent = "Check your name.";
        }
        if (emailValidation.valid) {
            emailError.innerHTML = "";
        } else {
            errorCount = errorCount + 1;
            emailError.textContent = "Check the email format.";
        }
        if (postcodeValidation.valid) {
            postcodeError.innerHTML = "";
        }
        if (termsAndCond.checked == false) {
            errorCount = errorCount + 1;
            generalError.textContent = "Please accept Terms / Conditions.";
        } else {
            generalError.innerHTML = "";
        }
        if (errorCount == 0) {
            var updateCRM = true;
            //if (currentUser.attributes.receiveEmails != newsletterSignup.checked) {
            //	updateCRM = true;
            //}
            // save data first
            currentUser.set("username", emailStr);
            currentUser.set("password", fullNameStr);
            currentUser.set("email", emailStr);
            currentUser.set("name", fullNameStr);
            currentUser.set("postcode", postcode.value);
            currentUser.set("receiveEmails", newsletterSignup.checked);
            if (updateCRM) {}
            currentUser.signUp(null, {
                success: function(user) {
                    currentUser = user;
                    //welcomeNewUser();
                    signUpNewsletter();
                    loadHomePage();
                    ga("send", "event", "Details", "Submit", "submit success");
                },
                error: function(user, error) {
                    if (error.code === 202) {
                        Parse.User.logIn(emailStr, fullNameStr, {
                            success: function(user) {
                                currentUser = user;
                                if (user.attributes.drinkRedeemed) {
                                    return self.scrManager.addScreen(ThankYouScreen);
                                } else {
                                    return loadHomePage();
                                }
                            },
                            error: function(user, error) {
                                isSubmitting = false;
                                if (error.code === 101) {
                                    emailError.textContent = "The email address is already registered.";
                                } else {
                                    console.error(error);
                                }
                                ga("send", "event", "Details", "Submit", "submit fail");
                            }
                        });
                    } else {
                        ga("send", "event", "Details", "Submit", "submit fail");
                    }
                }
            });
        } else {
            ga("send", "event", "Details", "Submit", "submit fail");
            isSubmitting = false;
            return false;
        }
    }
    function limitFieldInput(e) {
        var target = e.target, maxLength = target.getAttribute("maxlength");
        if (maxLength && target.value.length >= maxLength) {
            e.preventDefault();
            return false;
        }
        return true;
    }
    function signUpNewsletter() {
        var newsletterRequest, formData = getUserCrmData();
        function getUserCrmData() {
            var userData = {
                email: currentUser.attributes.email,
                name: currentUser.attributes.name,
                dobDay: currentUser.attributes.birthday.getDate(),
                dobMonth: currentUser.attributes.birthday.getMonth() + 1,
                dobYear: currentUser.attributes.birthday.getFullYear(),
                postCode: currentUser.attributes.postcode || "",
                optIn: currentUser.attributes.receiveEmails ? true : false
            }, keyValuePairs = [], i;
            for (i in userData) {
                if (userData.hasOwnProperty(i)) {
                    keyValuePairs.push(encodeURIComponent(i) + "=" + encodeURIComponent(userData[i]));
                }
            }
            return keyValuePairs.join("&");
        }
        function signupResponse(e) {
            var target = e.target, response;
            if (target.readyState !== 4) {
                return;
            }
            if (target.status >= 200 && target.status < 400) {
                response = JSON.parse(target.responseText);
                if (response.success) {
                    console.log(response);
                } else {
                    console.error(response);
                }
            } else {
                console.error("Error submitting form.", target.responseText);
            }
        }
        newsletterRequest = new XMLHttpRequest();
        newsletterRequest.onreadystatechange = signupResponse;
        newsletterRequest.open("POST", "/subscribe-exactTarget", true);
        newsletterRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        newsletterRequest.send(formData);
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        detailsForm = document.getElementById("detailsForm");
        fullName = document.getElementById("fullNameInput");
        email = document.getElementById("emailInput");
        postcode = document.getElementById("postcodeInput");
        termsAndCond = document.getElementById("checkboxOne");
        newsletterSignup = document.getElementById("checkboxTwo");
        fullName.value = currentUser.attributes.name;
        email.value = currentUser.attributes.email;
        if (fullName.value === "undefined" && email.value === "undefined") {
            fullName.value = "";
            email.value = "";
        }
        detailsForm.addEventListener("keypress", limitFieldInput);
        detailsForm.addEventListener("submit", validateFields);
        return this.container;
    };
}

UserDetailsScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Voucher page class

*********************/
function VoucherPageScreen() {
    var self = this, form, validator = new Validate();
    isSubmitting = false;
    Screen.apply(this, Array.prototype.slice.call(arguments));
    this.id = "voucher-page-screen";
    this.name = "Voucher page";
    this.templateId = "enter-code-template";
    this.root = false;
    function loadThankYouPage(e) {
        e.preventDefault();
        self.scrManager.addScreen(ThankYouScreen);
    }
    function codeNotValid(invalidPin) {
        alert("The code you entered is not valid.");
    }
    function codeIsValid(barObject) {
        var relation;
        barObject.increment("drinksRedeemed");
        barObject.save();
        relation = currentUser.relation("redeemedAtBar");
        relation.add(barObject);
        currentUser.set("drinkRedeemed", true);
        currentUser.save();
        self.scrManager.addScreen(ThankYouScreen);
    }
    //Check that a bar with the code provided exists
    function redeemVoucher(code) {
        var BarsList = Parse.Object.extend("Bars"), query = new Parse.Query(BarsList);
        query.equalTo("pinNumber", code);
        query.first({
            success: function(object) {
                ga("send", "event", "Voucher", "click", "Validate");
                if (object) {
                    codeIsValid(object);
                } else {
                    codeNotValid(true);
                }
                isSubmitting = false;
            },
            error: function(error) {
                codeNotValid(true);
                isSubmitting = false;
            }
        });
    }
    //Make sure a 4 digit code is input
    function validateCode(e) {
        if (e && e.preventDefault) {
            e.preventDefault();
        }
        if (isSubmitting) {
            return false;
        }
        isSubmitting = true;
        var fields = form.elements, i, code = "";
        for (i = 0; i < fields.length; i++) {
            if (fields[i].tagName.toLowerCase() === "input") {
                if (!validator.field(fields[i]).valid) {
                    return codeNotValid();
                } else {
                    code += fields[i].value;
                }
            }
        }
        //4 digit valid code present
        redeemVoucher(code);
    }
    //Make sure that only one digit is input into the field
    function validateFieldInput(e) {
        var key = e.keyCode, field = e.target, nextSibling = field.nextElementSibling;
        if ((e.charCode < 48 || e.charCode > 57 || field.value.length) && key !== 8 && key !== 13 && key !== 9) {
            return false;
        }
        if (key === 8) {
            return true;
        }
        if (nextSibling && nextSibling.tagName.toLowerCase() === "input") {
            setTimeout(function() {
                nextSibling.focus();
            }, 10);
        } else {
            setTimeout(function() {
                field.blur();
            }, 10);
        }
    }
    function limitFieldInput(e) {
        var target = e.target, maxLength = target.getAttribute("maxlength");
        if (maxLength && target.value.length >= maxLength) {
            e.preventDefault();
            return false;
        }
        return true;
    }
    //Do post container creation processing
    this.processContainer = function() {
        this.events.publish(this.id + "ContainerReady", this);
        form = document.getElementById("enter-code-form");
        form.addEventListener("submit", validateCode);
        form.addEventListener("keypress", validateFieldInput);
        document.getElementById("backBtn").addEventListener("click", self.scrManager.goBack);
        form.elements["digit1"].focus();
        form.addEventListener("keypress", limitFieldInput);
        return this.container;
    };
}

VoucherPageScreen.prototype = new Screen();

/*********************

Authors:
	Luis Rodrigues

Description:
	Main application script

*********************/
var parseIds = {
    "www.pinacoladaday.co.uk": {
        appId: "AbIPr3QJYyDT9CffQ2M5UDumVMg7NqQ5SI7bGi3p",
        jsKey: "lXTxsEZ7PkfkPseO2kOlPptCrEjtna3cYDX1Ejbn"
    },
    "npcd2016.parseapp.com": {
        appId: "AbIPr3QJYyDT9CffQ2M5UDumVMg7NqQ5SI7bGi3p",
        jsKey: "lXTxsEZ7PkfkPseO2kOlPptCrEjtna3cYDX1Ejbn"
    },
    "127.0.0.1": {
        appId: "AbIPr3QJYyDT9CffQ2M5UDumVMg7NqQ5SI7bGi3p",
        jsKey: "lXTxsEZ7PkfkPseO2kOlPptCrEjtna3cYDX1Ejbn"
    },
    "192.168.10.100": {
        appId: "AbIPr3QJYyDT9CffQ2M5UDumVMg7NqQ5SI7bGi3p",
        jsKey: "lXTxsEZ7PkfkPseO2kOlPptCrEjtna3cYDX1Ejbn"
    }
}, parseId = {
    appId: "",
    jsKey: ""
};

// default (invalid host)                
if (!parseIds[window.location.host.replace("/", "")]) {
    console.error("Parse ID error: Host not valid (no Parse id defined).");
} else {
    parseId = parseIds[window.location.host.replace("/", "")];
}

Parse.initialize(parseId["appId"], parseId["jsKey"]);

window.getCookie = function(name) {
    var name = name;
    match = document.cookie.match(new RegExp(name + "=([^;]+)"));
    if (match) return match[1];
};

function setCookie() {
    var cssString = "margin-top: 0px; transition: all 0.2s ease-in;";
    document.getElementById("app").style.cssText = cssString;
    document.getElementById("cookieWrap").style.display = "none";
    document.cookie = "MalibuNpcdCookie2016 = accepted";
}

function hideErrorWrapper() {
    var errorWrapper = document.getElementById("error-overlay");
    errorWrapper.style.display = "none";
}

function App() {
    var screenMngr;
    this.destroy = function() {
        if (screenMngr) {
            screenMngr.destroy();
        }
        window.removeEventListener("unload", this.destroy);
    };
    this.checkCookie = function() {
        var cookie = window.getCookie("MalibuNpcdCookie2016");
        if (cookie == "accepted") {
            document.getElementById("cookieWrap").style.display = "none";
        } else {
            document.getElementById("cookieWrap").style.display = "block";
        }
    };
    this.init = function() {
        screenMngr = new ScreenManager();
        document.getElementById("cookie-alert").addEventListener("click", setCookie);
        document.getElementById("close-btn").addEventListener("click", hideErrorWrapper);
    };
    this.checkCookie();
    this.init();
}

function welcomeNewUser() {
    //if (window.location.host !== 'www.pinacoladaday.co.uk') {
    //	return;
    //}
    var formData = getUserCrmData();
    function getUserCrmData() {
        var userData = {
            email: currentUser.attributes.email
        }, keyValuePairs = [], i;
        for (i in userData) {
            if (userData.hasOwnProperty(i)) {
                keyValuePairs.push(encodeURIComponent(i) + "=" + encodeURIComponent(userData[i]));
            }
        }
        return keyValuePairs.join("&");
    }
    function emailTriggerResponse(e) {
        var target = e.target, response;
        if (target.readyState !== 4) {
            return;
        }
        if (target.status >= 200 && target.status < 400) {
            response = JSON.parse(target.responseText);
            if (response.success) {
                console.log(response);
            } else {
                console.error(response);
            }
        } else {
            console.error("Error submitting form.", target.responseText);
        }
    }
    var emailTriggerRequest = new XMLHttpRequest();
    //emailTriggerRequest.onreadystatechange = emailTriggerResponse;
    emailTriggerRequest.open("POST", "/subscribe-exactTarget", true);
    emailTriggerRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    emailTriggerRequest.send(formData);
}

function signUpNewsletter() {
    if (window.location.host !== "www.pinacoladaday.co.uk") {
        return;
    }
    var newsletterRequest, formData = getUserCrmData();
    function getUserCrmData() {
        var userData = {
            email: currentUser.attributes.email,
            name: currentUser.attributes.name,
            dobDay: currentUser.attributes.birthday.getDate(),
            dobMonth: currentUser.attributes.birthday.getMonth() + 1,
            dobYear: currentUser.attributes.birthday.getFullYear(),
            postCode: currentUser.attributes.postcode || "",
            optIn: currentUser.attributes.receiveEmails ? true : false
        }, keyValuePairs = [], i;
        for (i in userData) {
            if (userData.hasOwnProperty(i)) {
                keyValuePairs.push(encodeURIComponent(i) + "=" + encodeURIComponent(userData[i]));
            }
        }
        return keyValuePairs.join("&");
    }
    function signupResponse(e) {
        var target = e.target, response;
        if (target.readyState !== 4) {
            return;
        }
        if (target.status >= 200 && target.status < 400) {
            response = JSON.parse(target.responseText);
            if (response.success) {
                console.log(response);
            } else {
                console.error(response);
            }
        } else {
            console.error("Error submitting form.", target.responseText);
        }
    }
    newsletterRequest = new XMLHttpRequest();
    //newsletterRequest.onreadystatechange = signupResponse;
    newsletterRequest.open("POST", "/subscribe-exactTarget", true);
    newsletterRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    newsletterRequest.send(formData);
}

// Listen for orientation changes
window.addEventListener("orientationchange", function() {
    // do something when device orientation changes
    var appContainer = document.getElementById(app), scrollableContainer = document.getElementsByClassName("scrollable")[0], fullHeight = window.innerHeight;
    appContainer.style.height = fullHeight;
    scrollableContainer.style.height = fullHeight;
}, false);

var currentUser, app = new App();